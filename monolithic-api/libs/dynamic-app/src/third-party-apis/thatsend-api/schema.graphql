"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

input AcademicDegreeCreateInput {
  """Job nature ID of the academicdegree."""
  acadfield_id: Int!

  """Title of the academicdegree."""
  title: String!

  """Description of the academicdegree."""
  desc: String
}

type AcademicDegreeCreateOutput {
  """Unique ID of the academicdegree, auto generated."""
  id: Int

  """Job nature ID of the academicdegree."""
  acadfield_id: Int

  """Title of the academicdegree."""
  title: String

  """Description of the academicdegree."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides academic feild list."""
  fr_academic_field: AcademicFieldEntity
}

input AcademicDegreeDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicDegreeDeleteInputWhere!]
}

input AcademicDegreeDeleteInputWhere {
  """Unique ID of the academicdegree, auto generated."""
  id: FindOperatorDto

  """Job nature ID of the academicdegree."""
  acadfield_id: FindOperatorDto

  """Title of the academicdegree."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides academic feild list."""
  fr_academic_field: [AcademicFieldFindInputWhere!]
}

type AcademicDegreeDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type AcademicDegreeEntity {
  """Unique ID of the academicdegree, auto generated."""
  id: Int

  """Job nature ID of the academicdegree."""
  acadfield_id: Int

  """Title of the academicdegree."""
  title: String

  """Description of the academicdegree."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides academic feild list."""
  fr_academic_field: AcademicFieldEntity
}

input AcademicDegreeFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicDegreeFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: AcademicDegreeFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: AcademicDegreeFindInputSortOrder
}

input AcademicDegreeFindInputGroupBy {
  acadfield_id: Boolean
  title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input AcademicDegreeFindInputSortOrder {
  id: RecordSortDirectionEnum
  acadfield_id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input AcademicDegreeFindInputWhere {
  """Unique ID of the academicdegree, auto generated."""
  id: FindOperatorDto

  """Job nature ID of the academicdegree."""
  acadfield_id: FindOperatorDto

  """Title of the academicdegree."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides academic feild list."""
  fr_academic_field: [AcademicFieldFindInputWhere!]
}

input AcademicDegreeFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type AcademicDegreeFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [AcademicDegreeEntity!]!
}

input AcademicDegreeRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicDegreeRecoverInputWhere!]
}

input AcademicDegreeRecoverInputWhere {
  """Unique ID of the academicdegree, auto generated."""
  id: FindOperatorDto

  """Job nature ID of the academicdegree."""
  acadfield_id: FindOperatorDto

  """Title of the academicdegree."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides academic feild list."""
  fr_academic_field: [AcademicFieldFindInputWhere!]
}

type AcademicDegreeRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AcademicDegreeEntity!]!
}

input AcademicDegreeRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicDegreeRemoveInputWhere!]
}

input AcademicDegreeRemoveInputWhere {
  """Unique ID of the academicdegree, auto generated."""
  id: FindOperatorDto

  """Job nature ID of the academicdegree."""
  acadfield_id: FindOperatorDto

  """Title of the academicdegree."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides academic feild list."""
  fr_academic_field: [AcademicFieldFindInputWhere!]
}

type AcademicDegreeRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AcademicDegreeEntity!]!
}

input AcademicDegreeRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicDegreeRestoreInputWhere!]
}

input AcademicDegreeRestoreInputWhere {
  """Unique ID of the academicdegree, auto generated."""
  id: FindOperatorDto

  """Job nature ID of the academicdegree."""
  acadfield_id: FindOperatorDto

  """Title of the academicdegree."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides academic feild list."""
  fr_academic_field: [AcademicFieldFindInputWhere!]
}

type AcademicDegreeRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input AcademicDegreeSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicDegreeSoftDeleteInputWhere!]
}

input AcademicDegreeSoftDeleteInputWhere {
  """Unique ID of the academicdegree, auto generated."""
  id: FindOperatorDto

  """Job nature ID of the academicdegree."""
  acadfield_id: FindOperatorDto

  """Title of the academicdegree."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides academic feild list."""
  fr_academic_field: [AcademicFieldFindInputWhere!]
}

type AcademicDegreeSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input AcademicDegreeSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicDegreeSoftRemoveInputWhere!]
}

input AcademicDegreeSoftRemoveInputWhere {
  """Unique ID of the academicdegree, auto generated."""
  id: FindOperatorDto

  """Job nature ID of the academicdegree."""
  acadfield_id: FindOperatorDto

  """Title of the academicdegree."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides academic feild list."""
  fr_academic_field: [AcademicFieldFindInputWhere!]
}

type AcademicDegreeSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AcademicDegreeEntity!]!
}

input AcademicDegreeUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicDegreeUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: AcademicDegreeUpdateInputSets!
}

input AcademicDegreeUpdateInputSets {
  """Job nature ID of the academicdegree."""
  acadfield_id: Int

  """Title of the academicdegree."""
  title: String

  """Description of the academicdegree."""
  desc: String
}

input AcademicDegreeUpdateInputWhere {
  """Unique ID of the academicdegree, auto generated."""
  id: FindOperatorDto

  """Job nature ID of the academicdegree."""
  acadfield_id: FindOperatorDto

  """Title of the academicdegree."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides academic feild list."""
  fr_academic_field: [AcademicFieldFindInputWhere!]
}

type AcademicDegreeUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [AcademicDegreeEntity!]!
}

input AcademicDegreeUpsertInput {
  """Job nature ID of the academicdegree."""
  acadfield_id: Int!

  """Title of the academicdegree."""
  title: String!

  """Description of the academicdegree."""
  desc: String

  """Unique ID of the academicdegree, auto generated. undefined"""
  id: Int
}

type AcademicDegreeUpsertOutput {
  """Unique ID of the academicdegree, auto generated."""
  id: Int

  """Job nature ID of the academicdegree."""
  acadfield_id: Int

  """Title of the academicdegree."""
  title: String

  """Description of the academicdegree."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides academic feild list."""
  fr_academic_field: AcademicFieldEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input AcademicFieldCreateInput {
  """Title of the academicdield."""
  title: String!

  """Description of the academic field."""
  desc: String
}

type AcademicFieldCreateOutput {
  """Unique ID of the academicdield, auto generated."""
  id: Int

  """Title of the academicdield."""
  title: String

  """Description of the academic field."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides list of academicd degrees list."""
  fr_academic_degrees: [AcademicDegreeEntity!]
}

input AcademicFieldDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicFieldDeleteInputWhere!]
}

input AcademicFieldDeleteInputWhere {
  """Unique ID of the academicdield, auto generated."""
  id: FindOperatorDto

  """Title of the academicdield."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of academicd degrees list."""
  fr_academic_degrees: [AcademicDegreeFindInputWhere!]
}

type AcademicFieldDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type AcademicFieldEntity {
  """Unique ID of the academicdield, auto generated."""
  id: Int

  """Title of the academicdield."""
  title: String

  """Description of the academic field."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides list of academicd degrees list."""
  fr_academic_degrees: [AcademicDegreeEntity!]
}

input AcademicFieldFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicFieldFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: AcademicFieldFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: AcademicFieldFindInputSortOrder
}

input AcademicFieldFindInputGroupBy {
  title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input AcademicFieldFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input AcademicFieldFindInputWhere {
  """Unique ID of the academicdield, auto generated."""
  id: FindOperatorDto

  """Title of the academicdield."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of academicd degrees list."""
  fr_academic_degrees: [AcademicDegreeFindInputWhere!]
}

input AcademicFieldFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type AcademicFieldFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [AcademicFieldEntity!]!
}

input AcademicFieldRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicFieldRecoverInputWhere!]
}

input AcademicFieldRecoverInputWhere {
  """Unique ID of the academicdield, auto generated."""
  id: FindOperatorDto

  """Title of the academicdield."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of academicd degrees list."""
  fr_academic_degrees: [AcademicDegreeFindInputWhere!]
}

type AcademicFieldRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AcademicFieldEntity!]!
}

input AcademicFieldRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicFieldRemoveInputWhere!]
}

input AcademicFieldRemoveInputWhere {
  """Unique ID of the academicdield, auto generated."""
  id: FindOperatorDto

  """Title of the academicdield."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of academicd degrees list."""
  fr_academic_degrees: [AcademicDegreeFindInputWhere!]
}

type AcademicFieldRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AcademicFieldEntity!]!
}

input AcademicFieldRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicFieldRestoreInputWhere!]
}

input AcademicFieldRestoreInputWhere {
  """Unique ID of the academicdield, auto generated."""
  id: FindOperatorDto

  """Title of the academicdield."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of academicd degrees list."""
  fr_academic_degrees: [AcademicDegreeFindInputWhere!]
}

type AcademicFieldRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input AcademicFieldSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicFieldSoftDeleteInputWhere!]
}

input AcademicFieldSoftDeleteInputWhere {
  """Unique ID of the academicdield, auto generated."""
  id: FindOperatorDto

  """Title of the academicdield."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of academicd degrees list."""
  fr_academic_degrees: [AcademicDegreeFindInputWhere!]
}

type AcademicFieldSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input AcademicFieldSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicFieldSoftRemoveInputWhere!]
}

input AcademicFieldSoftRemoveInputWhere {
  """Unique ID of the academicdield, auto generated."""
  id: FindOperatorDto

  """Title of the academicdield."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of academicd degrees list."""
  fr_academic_degrees: [AcademicDegreeFindInputWhere!]
}

type AcademicFieldSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AcademicFieldEntity!]!
}

input AcademicFieldUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AcademicFieldUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: AcademicFieldUpdateInputSets!
}

input AcademicFieldUpdateInputSets {
  """Title of the academicdield."""
  title: String

  """Description of the academic field."""
  desc: String
}

input AcademicFieldUpdateInputWhere {
  """Unique ID of the academicdield, auto generated."""
  id: FindOperatorDto

  """Title of the academicdield."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of academicd degrees list."""
  fr_academic_degrees: [AcademicDegreeFindInputWhere!]
}

type AcademicFieldUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [AcademicFieldEntity!]!
}

input AcademicFieldUpsertInput {
  """Title of the academicdield."""
  title: String!

  """Description of the academic field."""
  desc: String

  """Unique ID of the academicdield, auto generated. undefined"""
  id: Int
}

type AcademicFieldUpsertOutput {
  """Unique ID of the academicdield, auto generated."""
  id: Int

  """Title of the academicdield."""
  title: String

  """Description of the academic field."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides list of academicd degrees list."""
  fr_academic_degrees: [AcademicDegreeEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""
Used to define setting access type available for end user or internal use.
"""
enum AccessTypeEnum {
  """Public"""
  PUBLIC

  """Private"""
  PRIVATE
}

input AlertDurationCreateInput {
  """Title of the email template."""
  title: String!
}

type AlertDurationCreateOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input AlertDurationDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AlertDurationDeleteInputWhere!]
}

input AlertDurationDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type AlertDurationDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type AlertDurationEntity {
  """Unique ID of the email template, auto generated."""
  id: Int
  fr_user_save_search: [UserSavedSearchEntity!]

  """Title of the email template."""
  title: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input AlertDurationFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AlertDurationFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: AlertDurationFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: AlertDurationFindInputSortOrder
}

input AlertDurationFindInputGroupBy {
  title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input AlertDurationFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input AlertDurationFindInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

input AlertDurationFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type AlertDurationFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [AlertDurationEntity!]!
}

input AlertDurationRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AlertDurationRecoverInputWhere!]
}

input AlertDurationRecoverInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type AlertDurationRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AlertDurationEntity!]!
}

input AlertDurationRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AlertDurationRemoveInputWhere!]
}

input AlertDurationRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type AlertDurationRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AlertDurationEntity!]!
}

input AlertDurationRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AlertDurationRestoreInputWhere!]
}

input AlertDurationRestoreInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type AlertDurationRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input AlertDurationSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AlertDurationSoftDeleteInputWhere!]
}

input AlertDurationSoftDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type AlertDurationSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input AlertDurationSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AlertDurationSoftRemoveInputWhere!]
}

input AlertDurationSoftRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type AlertDurationSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AlertDurationEntity!]!
}

input AlertDurationUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AlertDurationUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: AlertDurationUpdateInputSets!
}

input AlertDurationUpdateInputSets {
  """Title of the email template."""
  title: String
}

input AlertDurationUpdateInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type AlertDurationUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [AlertDurationEntity!]!
}

input AlertDurationUpsertInput {
  """Title of the email template."""
  title: String!

  """Unique ID of the email template, auto generated. undefined"""
  id: Int
}

type AlertDurationUpsertOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input ApiEndpointAuthCreateInput {
  """Required to gain access to API endpoint."""
  username: String!

  """Email is required for varification and communication."""
  email: String!

  """Required to gain access to API endpoint using JWT token."""
  identify: String!

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum! = APIUSER
}

type ApiEndpointAuthCreateOutput {
  """Unique ID of the user, auto generated."""
  id: Int

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum

  """Required to gain access to API endpoint."""
  username: String

  """Email is required for varification and communication."""
  email: EmailAddress

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: JWT

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: JWT

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ApiEndpointAuthDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ApiEndpointAuthDeleteInputWhere!]
}

input ApiEndpointAuthDeleteInputWhere {
  """Unique ID of the user, auto generated."""
  id: FindOperatorDto

  """Required to gain access to API endpoint."""
  username: FindOperatorDto

  """Email is required for varification and communication."""
  email: FindOperatorDto

  """Required to gain access permission to restricted data."""
  role_id: FindOperatorDto

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: FindOperatorDto

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: FindOperatorDto

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ApiEndpointAuthDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ApiEndpointAuthFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ApiEndpointAuthFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ApiEndpointAuthFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ApiEndpointAuthFindInputSortOrder
}

input ApiEndpointAuthFindInputGroupBy {
  role_id: Boolean
  suspended: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ApiEndpointAuthFindInputSortOrder {
  id: RecordSortDirectionEnum
  username: RecordSortDirectionEnum
  suspended: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ApiEndpointAuthFindInputWhere {
  """Unique ID of the user, auto generated."""
  id: FindOperatorDto

  """Required to gain access to API endpoint."""
  username: FindOperatorDto

  """Email is required for varification and communication."""
  email: FindOperatorDto

  """Required to gain access permission to restricted data."""
  role_id: FindOperatorDto

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: FindOperatorDto

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: FindOperatorDto

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

input ApiEndpointAuthFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!
}

type ApiEndpointAuthFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ApiEndpointAuthFindOutputRows!]!
}

type ApiEndpointAuthFindOutputRows {
  """Unique ID of the user, auto generated."""
  id: Int

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum

  """Required to gain access to API endpoint."""
  username: String

  """Email is required for varification and communication."""
  email: EmailAddress

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: JWT

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: JWT

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ApiEndpointAuthRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ApiEndpointAuthRecoverInputWhere!]
}

input ApiEndpointAuthRecoverInputWhere {
  """Unique ID of the user, auto generated."""
  id: FindOperatorDto

  """Required to gain access to API endpoint."""
  username: FindOperatorDto

  """Email is required for varification and communication."""
  email: FindOperatorDto

  """Required to gain access permission to restricted data."""
  role_id: FindOperatorDto

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: FindOperatorDto

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: FindOperatorDto

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ApiEndpointAuthRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ApiEndpointAuthRecoverOutputAffectedRows!]!
}

type ApiEndpointAuthRecoverOutputAffectedRows {
  """Unique ID of the user, auto generated."""
  id: Int

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum

  """Required to gain access to API endpoint."""
  username: String

  """Email is required for varification and communication."""
  email: EmailAddress

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: JWT

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: JWT

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ApiEndpointAuthRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ApiEndpointAuthRemoveInputWhere!]
}

input ApiEndpointAuthRemoveInputWhere {
  """Unique ID of the user, auto generated."""
  id: FindOperatorDto

  """Required to gain access to API endpoint."""
  username: FindOperatorDto

  """Email is required for varification and communication."""
  email: FindOperatorDto

  """Required to gain access permission to restricted data."""
  role_id: FindOperatorDto

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: FindOperatorDto

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: FindOperatorDto

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ApiEndpointAuthRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ApiEndpointAuthRemoveOutputAffectedRows!]!
}

type ApiEndpointAuthRemoveOutputAffectedRows {
  """Unique ID of the user, auto generated."""
  id: Int

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum

  """Required to gain access to API endpoint."""
  username: String

  """Email is required for varification and communication."""
  email: EmailAddress

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: JWT

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: JWT

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ApiEndpointAuthRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ApiEndpointAuthRestoreInputWhere!]
}

input ApiEndpointAuthRestoreInputWhere {
  """Unique ID of the user, auto generated."""
  id: FindOperatorDto

  """Required to gain access to API endpoint."""
  username: FindOperatorDto

  """Email is required for varification and communication."""
  email: FindOperatorDto

  """Required to gain access permission to restricted data."""
  role_id: FindOperatorDto

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: FindOperatorDto

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: FindOperatorDto

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ApiEndpointAuthRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ApiEndpointAuthSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ApiEndpointAuthSoftDeleteInputWhere!]
}

input ApiEndpointAuthSoftDeleteInputWhere {
  """Unique ID of the user, auto generated."""
  id: FindOperatorDto

  """Required to gain access to API endpoint."""
  username: FindOperatorDto

  """Email is required for varification and communication."""
  email: FindOperatorDto

  """Required to gain access permission to restricted data."""
  role_id: FindOperatorDto

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: FindOperatorDto

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: FindOperatorDto

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ApiEndpointAuthSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ApiEndpointAuthSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ApiEndpointAuthSoftRemoveInputWhere!]
}

input ApiEndpointAuthSoftRemoveInputWhere {
  """Unique ID of the user, auto generated."""
  id: FindOperatorDto

  """Required to gain access to API endpoint."""
  username: FindOperatorDto

  """Email is required for varification and communication."""
  email: FindOperatorDto

  """Required to gain access permission to restricted data."""
  role_id: FindOperatorDto

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: FindOperatorDto

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: FindOperatorDto

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ApiEndpointAuthSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ApiEndpointAuthSoftRemoveOutputAffectedRows!]!
}

type ApiEndpointAuthSoftRemoveOutputAffectedRows {
  """Unique ID of the user, auto generated."""
  id: Int

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum

  """Required to gain access to API endpoint."""
  username: String

  """Email is required for varification and communication."""
  email: EmailAddress

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: JWT

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: JWT

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ApiEndpointAuthUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ApiEndpointAuthUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ApiEndpointAuthUpdateInputSets!
}

input ApiEndpointAuthUpdateInputSets {
  """Required to gain access to API endpoint."""
  username: String

  """Email is required for varification and communication."""
  email: String

  """Required to gain access to API endpoint using JWT token."""
  identify: String

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum = APIUSER
}

input ApiEndpointAuthUpdateInputWhere {
  """Unique ID of the user, auto generated."""
  id: FindOperatorDto

  """Required to gain access to API endpoint."""
  username: FindOperatorDto

  """Email is required for varification and communication."""
  email: FindOperatorDto

  """Required to gain access permission to restricted data."""
  role_id: FindOperatorDto

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: FindOperatorDto

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: FindOperatorDto

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ApiEndpointAuthUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ApiEndpointAuthUpdateOutputAffectedRows!]!
}

type ApiEndpointAuthUpdateOutputAffectedRows {
  """Unique ID of the user, auto generated."""
  id: Int

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum

  """Required to gain access to API endpoint."""
  username: String

  """Email is required for varification and communication."""
  email: EmailAddress

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: JWT

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: JWT

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ApiEndpointAuthUpsertInput {
  """Required to gain access to API endpoint."""
  username: String!

  """Email is required for varification and communication."""
  email: String!

  """Required to gain access to API endpoint using JWT token."""
  identify: String!

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum! = APIUSER

  """
  Unique ID of the user, auto generated. Can be empty or provide id to update existing record.
  """
  id: Int
}

type ApiEndpointAuthUpsertOutput {
  """Unique ID of the user, auto generated."""
  id: Int

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum

  """Required to gain access to API endpoint."""
  username: String

  """Email is required for varification and communication."""
  email: EmailAddress

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: JWT

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: JWT

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""User role enum, and there are only 2 types at this moment"""
enum ApiUserRoleEnum {
  """
  Consumer user, who access the API with JWT access token and these users are from client application.
  """
  APIUSER

  """
  Administrator user, who has all access to manage application use for API access. This is not application business users, just API access users.
  """
  APIADMIN
}

input AppForgotPasswordInput {
  """Enter your username or primary email or primary mobile to sign in."""
  un_pe_pm: String!

  """Password recover url."""
  pass_recover_url: String!
}

type AppForgotPasswordOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Password recover token."""
  pass_recover_token: String
}

input AppGrantSignupInput {
  """Enter your username or primary email or primary mobile to sign in."""
  un_pe_pm: String!

  """
  Identify string for the user. Password should be combination of digit, uppercase, lowercase, special charector and no more than 3 consecutive identical characters.
  """
  identify: String

  """Authorisation role id of the user."""
  ar_id: Int!

  """Enter your password again."""
  identify_confirm: String

  """user id for grant signup"""
  u_id: Int!
}

type AppGrantSignupOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: String

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: String

  """Connection source ID."""
  connsrc_id: Int

  """First name of the user."""
  fname: String

  """Last name of the user."""
  lname: String

  """Middle name of the user."""
  mname: String

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: String

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: String

  """Primary mobile country code of the user."""
  primary_mobile_cc: String

  """Used to reset password."""
  recovery_email: EmailAddress

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: String

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: String

  """Provide whatsapp of the user."""
  whatsapp: String

  """Whatsapp country code of the user."""
  whatsapp_cc: String

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: YesNoEnum

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: DateTime

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: DateTime

  """
  Flag to indicate if user is verified. When record is verified, date-time will be saved otherwise null to indicate not verified.
  """
  verified: DateTime

  """
  Flag to indicate if user is suspended. When record is suspended, date-time will be saved otherwise null to indicate record is active.
  """
  suspended: DateTime

  """Date time when user is created."""
  created: DateTime

  """Date time when user is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User profile photo."""
  file_profile_photo: String

  """User profile photo url."""
  file_profile_photo_url: UploadFileAccessUrlDto

  """User profile banner."""
  file_profile_banner: String

  """User profile banner url."""
  file_profile_banner_url: UploadFileAccessUrlDto

  """User auth info of the user."""
  fr_user_auth: UserAuthenticationEntity

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceEntity!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """User personal info of the user."""
  fr_user_personal_info: UserPersonalInfoEntity

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """User address of the user."""
  fr_user_addresses: [UserAddressEntity!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyEntity!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User files."""
  fr_user_files: [UserFileEntity!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsEntity!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsEntity!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappEntity!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappEntity!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailEntity!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailEntity!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailEntity!]

  """Lead users."""
  fr_lead_from_users: [LeadEntity!]

  """Lead users."""
  fr_lead_to_users: [LeadEntity!]

  """News letter of this userr."""
  fr_newsletter_users: NewsLetterEntity

  """News letter schedule for this User."""
  fr_newsletter_schedule_users: NewsLetterScheduleEntity

  """Lead followup for this user."""
  fr_lead_followup_user: LeadFollowupEntity

  """Newsletter user for this user."""
  fr_news_letter_user_user: NewsLetterUserEntity

  """Newsletter subscription user for this user."""
  fr_user_newsletters_subscription: UserNewsLetterSubscriptionEntity

  """User favourites for this user."""
  fr_user_favourites: UserFavEntity

  """Buissness user."""
  fr_business_user: BusinessEntity

  """connection source for this user."""
  fr_connection_source: ConnectionSourceEntity

  """Important snapshots of technical process."""
  snapshot: SnapshotListDto
}

input AppOtpSigninInput {
  """Enter your username or primary email or primary mobile to sign in."""
  un_pe_pm: String!
}

type AppOtpSigninOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime
}

input AppRecoverForgotPasswordInput {
  """Enter your username or primary email or primary mobile to sign in."""
  un_pe_pm: String!

  """
  Identify string for the user. Password should be combination of digit, uppercase, lowercase, special charector and no more than 3 consecutive identical characters.
  """
  identify: String

  """Enter your password again."""
  identify_confirm: String

  """Password recover token."""
  pass_recover_token: String!
}

type AppRecoverForgotPasswordOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input AppResetPasswordInput {
  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: String

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: String

  """Primary mobile country code of the user."""
  primary_mobile_cc: String

  """Used to reset password."""
  recovery_email: String!

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: String!

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: String!

  """
  Identify string for the user. Password should be combination of digit, uppercase, lowercase, special charector and no more than 3 consecutive identical characters.
  """
  identify: String

  """Authorisation role id of the user."""
  ar_id: Int!

  """Enter your password again."""
  identify_confirm: String
}

type AppResetPasswordOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input AppSigninInput {
  """Authorisation role id of the user."""
  ar_id: Int!

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum! = NO

  """Device Token of the entity."""
  device_token: String!

  """
  Identify string for the user. Password should be combination of digit, uppercase, lowercase, special charector and no more than 3 consecutive identical characters.
  """
  identify: String

  """One time password for the user signin."""
  otp: String

  """Enter your username or primary email or primary mobile to sign in."""
  un_pe_pm: String!
}

type AppSigninOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: String

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: String

  """Connection source ID."""
  connsrc_id: Int

  """First name of the user."""
  fname: String

  """Last name of the user."""
  lname: String

  """Middle name of the user."""
  mname: String

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: String

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: String

  """Primary mobile country code of the user."""
  primary_mobile_cc: String

  """Used to reset password."""
  recovery_email: EmailAddress

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: String

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: String

  """Provide whatsapp of the user."""
  whatsapp: String

  """Whatsapp country code of the user."""
  whatsapp_cc: String

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: YesNoEnum

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: DateTime

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: DateTime

  """
  Flag to indicate if user is verified. When record is verified, date-time will be saved otherwise null to indicate not verified.
  """
  verified: DateTime

  """
  Flag to indicate if user is suspended. When record is suspended, date-time will be saved otherwise null to indicate record is active.
  """
  suspended: DateTime

  """Date time when user is created."""
  created: DateTime

  """Date time when user is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User profile photo."""
  file_profile_photo: String

  """User profile photo url."""
  file_profile_photo_url: UploadFileAccessUrlDto

  """User profile banner."""
  file_profile_banner: String

  """User profile banner url."""
  file_profile_banner_url: UploadFileAccessUrlDto

  """User auth info of the user."""
  fr_user_auth: UserAuthenticationEntity

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceEntity!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """User personal info of the user."""
  fr_user_personal_info: UserPersonalInfoEntity

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """User address of the user."""
  fr_user_addresses: [UserAddressEntity!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyEntity!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User files."""
  fr_user_files: [UserFileEntity!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsEntity!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsEntity!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappEntity!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappEntity!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailEntity!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailEntity!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailEntity!]

  """Lead users."""
  fr_lead_from_users: [LeadEntity!]

  """Lead users."""
  fr_lead_to_users: [LeadEntity!]

  """News letter of this userr."""
  fr_newsletter_users: NewsLetterEntity

  """News letter schedule for this User."""
  fr_newsletter_schedule_users: NewsLetterScheduleEntity

  """Lead followup for this user."""
  fr_lead_followup_user: LeadFollowupEntity

  """Newsletter user for this user."""
  fr_news_letter_user_user: NewsLetterUserEntity

  """Newsletter subscription user for this user."""
  fr_user_newsletters_subscription: UserNewsLetterSubscriptionEntity

  """User favourites for this user."""
  fr_user_favourites: UserFavEntity

  """Buissness user."""
  fr_business_user: BusinessEntity

  """connection source for this user."""
  fr_connection_source: ConnectionSourceEntity

  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """When user is authenticated (signin), basic user auth info of the user."""
  authenticated: AuthenticatedSigninOutput
}

input AppSignupInput {
  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: String

  """Connection source ID."""
  connsrc_id: Int

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: String

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: String

  """Primary mobile country code of the user."""
  primary_mobile_cc: String

  """
  Identify string for the user. Password should be combination of digit, uppercase, lowercase, special charector and no more than 3 consecutive identical characters.
  """
  identify: String

  """Authorisation role id of the user."""
  ar_id: Int!

  """Enter your password again."""
  identify_confirm: String
}

type AppSignupOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: String

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: String

  """Connection source ID."""
  connsrc_id: Int

  """First name of the user."""
  fname: String

  """Last name of the user."""
  lname: String

  """Middle name of the user."""
  mname: String

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: String

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: String

  """Primary mobile country code of the user."""
  primary_mobile_cc: String

  """Used to reset password."""
  recovery_email: EmailAddress

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: String

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: String

  """Provide whatsapp of the user."""
  whatsapp: String

  """Whatsapp country code of the user."""
  whatsapp_cc: String

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: YesNoEnum

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: DateTime

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: DateTime

  """
  Flag to indicate if user is verified. When record is verified, date-time will be saved otherwise null to indicate not verified.
  """
  verified: DateTime

  """
  Flag to indicate if user is suspended. When record is suspended, date-time will be saved otherwise null to indicate record is active.
  """
  suspended: DateTime

  """Date time when user is created."""
  created: DateTime

  """Date time when user is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User profile photo."""
  file_profile_photo: String

  """User profile photo url."""
  file_profile_photo_url: UploadFileAccessUrlDto

  """User profile banner."""
  file_profile_banner: String

  """User profile banner url."""
  file_profile_banner_url: UploadFileAccessUrlDto

  """User auth info of the user."""
  fr_user_auth: UserAuthenticationEntity

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceEntity!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """User personal info of the user."""
  fr_user_personal_info: UserPersonalInfoEntity

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """User address of the user."""
  fr_user_addresses: [UserAddressEntity!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyEntity!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User files."""
  fr_user_files: [UserFileEntity!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsEntity!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsEntity!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappEntity!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappEntity!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailEntity!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailEntity!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailEntity!]

  """Lead users."""
  fr_lead_from_users: [LeadEntity!]

  """Lead users."""
  fr_lead_to_users: [LeadEntity!]

  """News letter of this userr."""
  fr_newsletter_users: NewsLetterEntity

  """News letter schedule for this User."""
  fr_newsletter_schedule_users: NewsLetterScheduleEntity

  """Lead followup for this user."""
  fr_lead_followup_user: LeadFollowupEntity

  """Newsletter user for this user."""
  fr_news_letter_user_user: NewsLetterUserEntity

  """Newsletter subscription user for this user."""
  fr_user_newsletters_subscription: UserNewsLetterSubscriptionEntity

  """User favourites for this user."""
  fr_user_favourites: UserFavEntity

  """Buissness user."""
  fr_business_user: BusinessEntity

  """connection source for this user."""
  fr_connection_source: ConnectionSourceEntity
}

type AuthenticatedSigninOutput {
  """Authenticated user currect session."""
  session: SessionEntity

  """Authenticated user registered device."""
  udevice: UserDeviceEntity

  """Authenticated user currect device."""
  device: DeviceEntity

  """Authorisations (roles) of the authenticated user."""
  uauthorisation: UserAuthorisationEntity

  """Authenticated user currect authorisation (roles)."""
  authorisation: AuthorisationEntity
}

input AuthorisationCreateInput {
  """Title of the authorisation."""
  role_title: String!

  """Privileges of the authorisation, encrypted string."""
  privileges: String
}

type AuthorisationCreateOutput {
  """Unique ID of the authorisation, auto generated."""
  id: Int

  """Title of the authorisation."""
  role_title: String

  """Privileges of the authorisation, encrypted string."""
  privileges: String

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyEntity!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterEntity!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleEntity!]

  """User auth roles for user favourite."""
  fr_user_favouries: UserFavEntity
}

input AuthorisationDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AuthorisationDeleteInputWhere!]
}

input AuthorisationDeleteInputWhere {
  """Unique ID of the authorisation, auto generated."""
  id: FindOperatorDto

  """Title of the authorisation."""
  role_title: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]
}

type AuthorisationDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type AuthorisationEntity {
  """Unique ID of the authorisation, auto generated."""
  id: Int
  fr_user_auth_save_search: [UserSavedSearchEntity!]

  """Title of the authorisation."""
  role_title: String

  """Privileges of the authorisation, encrypted string."""
  privileges: String

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyEntity!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterEntity!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleEntity!]

  """User auth roles for user favourite."""
  fr_user_favouries: UserFavEntity
}

input AuthorisationFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AuthorisationFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: AuthorisationFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: AuthorisationFindInputSortOrder
}

input AuthorisationFindInputGroupBy {
  role_title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input AuthorisationFindInputSortOrder {
  id: RecordSortDirectionEnum
  role_title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input AuthorisationFindInputWhere {
  """Unique ID of the authorisation, auto generated."""
  id: FindOperatorDto

  """Title of the authorisation."""
  role_title: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]
}

input AuthorisationFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type AuthorisationFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [AuthorisationFindOutputRows!]!
}

type AuthorisationFindOutputRows {
  """Unique ID of the authorisation, auto generated."""
  id: Int

  """Title of the authorisation."""
  role_title: String

  """Privileges of the authorisation, encrypted string."""
  privileges: String

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyEntity!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterEntity!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleEntity!]

  """User auth roles for user favourite."""
  fr_user_favouries: UserFavEntity
}

input AuthorisationRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AuthorisationRecoverInputWhere!]
}

input AuthorisationRecoverInputWhere {
  """Unique ID of the authorisation, auto generated."""
  id: FindOperatorDto

  """Title of the authorisation."""
  role_title: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]
}

type AuthorisationRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AuthorisationRecoverOutputAffectedRows!]!
}

type AuthorisationRecoverOutputAffectedRows {
  """Unique ID of the authorisation, auto generated."""
  id: Int

  """Title of the authorisation."""
  role_title: String

  """Privileges of the authorisation, encrypted string."""
  privileges: String

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyEntity!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterEntity!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleEntity!]

  """User auth roles for user favourite."""
  fr_user_favouries: UserFavEntity
}

input AuthorisationRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AuthorisationRemoveInputWhere!]
}

input AuthorisationRemoveInputWhere {
  """Unique ID of the authorisation, auto generated."""
  id: FindOperatorDto

  """Title of the authorisation."""
  role_title: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]
}

type AuthorisationRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AuthorisationRemoveOutputAffectedRows!]!
}

type AuthorisationRemoveOutputAffectedRows {
  """Unique ID of the authorisation, auto generated."""
  id: Int

  """Title of the authorisation."""
  role_title: String

  """Privileges of the authorisation, encrypted string."""
  privileges: String

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyEntity!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterEntity!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleEntity!]

  """User auth roles for user favourite."""
  fr_user_favouries: UserFavEntity
}

input AuthorisationRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AuthorisationRestoreInputWhere!]
}

input AuthorisationRestoreInputWhere {
  """Unique ID of the authorisation, auto generated."""
  id: FindOperatorDto

  """Title of the authorisation."""
  role_title: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]
}

type AuthorisationRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input AuthorisationSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AuthorisationSoftDeleteInputWhere!]
}

input AuthorisationSoftDeleteInputWhere {
  """Unique ID of the authorisation, auto generated."""
  id: FindOperatorDto

  """Title of the authorisation."""
  role_title: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]
}

type AuthorisationSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input AuthorisationSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AuthorisationSoftRemoveInputWhere!]
}

input AuthorisationSoftRemoveInputWhere {
  """Unique ID of the authorisation, auto generated."""
  id: FindOperatorDto

  """Title of the authorisation."""
  role_title: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]
}

type AuthorisationSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [AuthorisationSoftRemoveOutputAffectedRows!]!
}

type AuthorisationSoftRemoveOutputAffectedRows {
  """Unique ID of the authorisation, auto generated."""
  id: Int

  """Title of the authorisation."""
  role_title: String

  """Privileges of the authorisation, encrypted string."""
  privileges: String

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyEntity!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterEntity!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleEntity!]

  """User auth roles for user favourite."""
  fr_user_favouries: UserFavEntity
}

input AuthorisationUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [AuthorisationUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: AuthorisationUpdateInputSets!
}

input AuthorisationUpdateInputSets {
  """Title of the authorisation."""
  role_title: String

  """Privileges of the authorisation, encrypted string."""
  privileges: String
}

input AuthorisationUpdateInputWhere {
  """Unique ID of the authorisation, auto generated."""
  id: FindOperatorDto

  """Title of the authorisation."""
  role_title: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyFindInputWhere!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]
}

type AuthorisationUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [AuthorisationUpdateOutputAffectedRows!]!
}

type AuthorisationUpdateOutputAffectedRows {
  """Unique ID of the authorisation, auto generated."""
  id: Int

  """Title of the authorisation."""
  role_title: String

  """Privileges of the authorisation, encrypted string."""
  privileges: String

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyEntity!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterEntity!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleEntity!]

  """User auth roles for user favourite."""
  fr_user_favouries: UserFavEntity
}

input AuthorisationUpsertInput {
  """Title of the authorisation."""
  role_title: String!

  """Privileges of the authorisation, encrypted string."""
  privileges: String

  """Unique ID of the authorisation, auto generated. undefined"""
  id: Int
}

type AuthorisationUpsertOutput {
  """Unique ID of the authorisation, auto generated."""
  id: Int

  """Title of the authorisation."""
  role_title: String

  """Privileges of the authorisation, encrypted string."""
  privileges: String

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of user authorisations for given role."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """List of parent user hierarchies for given role."""
  fr_parent_user_hirarchies: [UserHierarchyEntity!]

  """List of parent user hierarchies for given role."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User auth roles for this newsletter."""
  fr_newsletters: [NewsLetterEntity!]

  """User auth roles for this newsletter schedule."""
  fr_newsletter_schedules: [NewsLetterScheduleEntity!]

  """User auth roles for user favourite."""
  fr_user_favouries: UserFavEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""Used to define setting send by available for end user or internal use."""
enum BounceTypeEnum {
  """Soft"""
  SOFT

  """Hard"""
  HARD
}

input BusinessCreateInput {
  """User owner Id of the business."""
  owner_u_id: Int

  """Brand logo of the business."""
  file_brand_logo: String

  """Id of the business primary category."""
  buspricat_id: Int!

  """Id of the business secondary category 1."""
  busseccat_id_1: Int

  """ID of the business secondary category 2."""
  busseccat_id_2: Int

  """ID of the business secondary category 3."""
  busseccat_id_3: Int

  """ID of the business secondary category 4."""
  busseccat_id_4: Int

  """ID of the business secondary category 5."""
  busseccat_id_5: Int

  """ID of the business secondary category 6."""
  busseccat_id_6: Int

  """ID of the business secondary category 7."""
  busseccat_id_7: Int

  """ID of the business secondary category 8."""
  busseccat_id_8: Int

  """ID of the business secondary category 9."""
  busseccat_id_9: Int

  """Name of the business."""
  name: String

  """About section of the business."""
  about: String

  """Address of the business."""
  address: String

  """ID of the country where the business is located."""
  country_id: Int

  """ID of the state where the business is located."""
  state_id: Int

  """ID of the city where the business is located."""
  city_id: Int

  """ZIP or postal code of the business location."""
  zipcode: String

  """Geographic latitude of the business location."""
  location_latitude: Float

  """Geographic longitude of the business location."""
  location_longitude: Float

  """Toll-free contact number for the business."""
  toll_free_number: String

  """Mobile contact number for the business."""
  mobile: String

  """Country code for the mobile number."""
  mobile_cc: String

  """WhatsApp number for the business."""
  whatsapp: String

  """Country code for WhatsApp number."""
  whatsapp_cc: String

  """Email address of the business."""
  email: String

  """Fax number of the business."""
  fax: String

  """Website URL of the business."""
  website_url: String

  """Facebook profile URL."""
  facebook_profile: String

  """Instagram profile URL."""
  instagram_profile: String

  """YouTube channel or profile URL."""
  youtube_profile: String

  """X profile URL."""
  x_profile: String

  """LinkedIn profile URL."""
  linkedin_profile: String

  """TikTok profile URL."""
  tiktok_profile: String

  """Pinterest profile URL."""
  pinterest_profile: String

  """Google My Business profile URL."""
  google_my_business_url: String

  """Google Maps URL for the business location."""
  google_map_url: String

  """URL to Google Reviews of the business."""
  google_review_url: String

  """Flag indicating whether the business is officially registered."""
  registered: DateTime

  """Initial assessment or notes about the business."""
  initial_findings: String

  """Competitor assessment or notes about the business."""
  competitor_findings: String
}

type BusinessCreateOutput {
  """Unique ID of the business, auto generated."""
  id: Int

  """User owner Id of the business."""
  owner_u_id: Int

  """Brand logo of the business."""
  file_brand_logo: String

  """Id of the business primary category."""
  buspricat_id: Int

  """Id of the business secondary category 1."""
  busseccat_id_1: Int

  """ID of the business secondary category 2."""
  busseccat_id_2: Int

  """ID of the business secondary category 3."""
  busseccat_id_3: Int

  """ID of the business secondary category 4."""
  busseccat_id_4: Int

  """ID of the business secondary category 5."""
  busseccat_id_5: Int

  """ID of the business secondary category 6."""
  busseccat_id_6: Int

  """ID of the business secondary category 7."""
  busseccat_id_7: Int

  """ID of the business secondary category 8."""
  busseccat_id_8: Int

  """ID of the business secondary category 9."""
  busseccat_id_9: Int

  """Name of the business."""
  name: String

  """About section of the business."""
  about: String

  """Address of the business."""
  address: String

  """ID of the country where the business is located."""
  country_id: Int

  """ID of the state where the business is located."""
  state_id: Int

  """ID of the city where the business is located."""
  city_id: Int

  """ZIP or postal code of the business location."""
  zipcode: String

  """Geographic latitude of the business location."""
  location_latitude: Float

  """Geographic longitude of the business location."""
  location_longitude: Float

  """Toll-free contact number for the business."""
  toll_free_number: String

  """Mobile contact number for the business."""
  mobile: String

  """Country code for the mobile number."""
  mobile_cc: String

  """WhatsApp number for the business."""
  whatsapp: String

  """Country code for WhatsApp number."""
  whatsapp_cc: String

  """Email address of the business."""
  email: String

  """Fax number of the business."""
  fax: String

  """Website URL of the business."""
  website_url: String

  """Facebook profile URL."""
  facebook_profile: String

  """Instagram profile URL."""
  instagram_profile: String

  """YouTube channel or profile URL."""
  youtube_profile: String

  """X profile URL."""
  x_profile: String

  """LinkedIn profile URL."""
  linkedin_profile: String

  """TikTok profile URL."""
  tiktok_profile: String

  """Pinterest profile URL."""
  pinterest_profile: String

  """Google My Business profile URL."""
  google_my_business_url: String

  """Google Maps URL for the business location."""
  google_map_url: String

  """URL to Google Reviews of the business."""
  google_review_url: String

  """Flag indicating whether the business is officially registered."""
  registered: DateTime

  """Initial assessment or notes about the business."""
  initial_findings: String

  """Competitor assessment or notes about the business."""
  competitor_findings: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """business primary categories."""
  fr_owner_user: UserEntity

  """business primary categories."""
  fr_primary_categories: BusinessPrimaryCategoryEntity

  """business secondary categories level 1."""
  fr_secondary_categories1: BusinessSecondaryCategoryEntity

  """business secondary categories level 2."""
  fr_secondary_categories2: BusinessSecondaryCategoryEntity

  """business secondary categories level 3."""
  fr_secondary_categories3: BusinessSecondaryCategoryEntity

  """business secondary categories level 4."""
  fr_secondary_categories4: BusinessSecondaryCategoryEntity

  """business secondary categories level 5."""
  fr_secondary_categories5: BusinessSecondaryCategoryEntity

  """business secondary categories level 6."""
  fr_secondary_categories6: BusinessSecondaryCategoryEntity

  """business secondary categories level 7."""
  fr_secondary_categories7: BusinessSecondaryCategoryEntity

  """business secondary categories level 8."""
  fr_secondary_categories8: BusinessSecondaryCategoryEntity

  """business secondary categories level 9."""
  fr_secondary_categories9: BusinessSecondaryCategoryEntity

  """business countries."""
  fr_countries: CountryEntity

  """business states."""
  fr_state: StateEntity

  """business cities."""
  fr_city: CityEntity
}

input BusinessDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessDeleteInputWhere!]
}

input BusinessDeleteInputWhere {
  """Unique ID of the business, auto generated."""
  id: FindOperatorDto

  """User owner Id of the business."""
  owner_u_id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Id of the business secondary category 1."""
  busseccat_id_1: FindOperatorDto

  """ID of the business secondary category 2."""
  busseccat_id_2: FindOperatorDto

  """ID of the business secondary category 3."""
  busseccat_id_3: FindOperatorDto

  """ID of the business secondary category 4."""
  busseccat_id_4: FindOperatorDto

  """ID of the business secondary category 5."""
  busseccat_id_5: FindOperatorDto

  """ID of the business secondary category 6."""
  busseccat_id_6: FindOperatorDto

  """ID of the business secondary category 7."""
  busseccat_id_7: FindOperatorDto

  """ID of the business secondary category 8."""
  busseccat_id_8: FindOperatorDto

  """ID of the business secondary category 9."""
  busseccat_id_9: FindOperatorDto

  """Name of the business."""
  name: FindOperatorDto

  """Address of the business."""
  address: FindOperatorDto

  """ID of the country where the business is located."""
  country_id: FindOperatorDto

  """ID of the state where the business is located."""
  state_id: FindOperatorDto

  """ID of the city where the business is located."""
  city_id: FindOperatorDto

  """Email address of the business."""
  email: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_owner_user: [UserFindInputWhere!]

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]

  """business secondary categories level 1."""
  fr_secondary_categories1: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 2."""
  fr_secondary_categories2: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 3."""
  fr_secondary_categories3: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 4."""
  fr_secondary_categories4: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 5."""
  fr_secondary_categories5: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 6."""
  fr_secondary_categories6: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 7."""
  fr_secondary_categories7: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 8."""
  fr_secondary_categories8: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 9."""
  fr_secondary_categories9: [BusinessSecondaryCategoryFindInputWhere!]

  """business countries."""
  fr_countries: [CountryFindInputWhere!]

  """business states."""
  fr_state: [StateFindInputWhere!]

  """business cities."""
  fr_city: [CityFindInputWhere!]
}

type BusinessDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type BusinessEntity {
  """Unique ID of the business, auto generated."""
  id: Int

  """User owner Id of the business."""
  owner_u_id: Int

  """Brand logo of the business."""
  file_brand_logo: String

  """Id of the business primary category."""
  buspricat_id: Int

  """Id of the business secondary category 1."""
  busseccat_id_1: Int

  """ID of the business secondary category 2."""
  busseccat_id_2: Int

  """ID of the business secondary category 3."""
  busseccat_id_3: Int

  """ID of the business secondary category 4."""
  busseccat_id_4: Int

  """ID of the business secondary category 5."""
  busseccat_id_5: Int

  """ID of the business secondary category 6."""
  busseccat_id_6: Int

  """ID of the business secondary category 7."""
  busseccat_id_7: Int

  """ID of the business secondary category 8."""
  busseccat_id_8: Int

  """ID of the business secondary category 9."""
  busseccat_id_9: Int

  """Name of the business."""
  name: String

  """About section of the business."""
  about: String

  """Address of the business."""
  address: String

  """ID of the country where the business is located."""
  country_id: Int

  """ID of the state where the business is located."""
  state_id: Int

  """ID of the city where the business is located."""
  city_id: Int

  """ZIP or postal code of the business location."""
  zipcode: String

  """Geographic latitude of the business location."""
  location_latitude: Float

  """Geographic longitude of the business location."""
  location_longitude: Float

  """Toll-free contact number for the business."""
  toll_free_number: String

  """Mobile contact number for the business."""
  mobile: String

  """Country code for the mobile number."""
  mobile_cc: String

  """WhatsApp number for the business."""
  whatsapp: String

  """Country code for WhatsApp number."""
  whatsapp_cc: String

  """Email address of the business."""
  email: String

  """Fax number of the business."""
  fax: String

  """Website URL of the business."""
  website_url: String

  """Facebook profile URL."""
  facebook_profile: String

  """Instagram profile URL."""
  instagram_profile: String

  """YouTube channel or profile URL."""
  youtube_profile: String

  """X profile URL."""
  x_profile: String

  """LinkedIn profile URL."""
  linkedin_profile: String

  """TikTok profile URL."""
  tiktok_profile: String

  """Pinterest profile URL."""
  pinterest_profile: String

  """Google My Business profile URL."""
  google_my_business_url: String

  """Google Maps URL for the business location."""
  google_map_url: String

  """URL to Google Reviews of the business."""
  google_review_url: String

  """Flag indicating whether the business is officially registered."""
  registered: DateTime

  """Initial assessment or notes about the business."""
  initial_findings: String

  """Competitor assessment or notes about the business."""
  competitor_findings: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """business primary categories."""
  fr_owner_user: UserEntity

  """business primary categories."""
  fr_primary_categories: BusinessPrimaryCategoryEntity

  """business secondary categories level 1."""
  fr_secondary_categories1: BusinessSecondaryCategoryEntity

  """business secondary categories level 2."""
  fr_secondary_categories2: BusinessSecondaryCategoryEntity

  """business secondary categories level 3."""
  fr_secondary_categories3: BusinessSecondaryCategoryEntity

  """business secondary categories level 4."""
  fr_secondary_categories4: BusinessSecondaryCategoryEntity

  """business secondary categories level 5."""
  fr_secondary_categories5: BusinessSecondaryCategoryEntity

  """business secondary categories level 6."""
  fr_secondary_categories6: BusinessSecondaryCategoryEntity

  """business secondary categories level 7."""
  fr_secondary_categories7: BusinessSecondaryCategoryEntity

  """business secondary categories level 8."""
  fr_secondary_categories8: BusinessSecondaryCategoryEntity

  """business secondary categories level 9."""
  fr_secondary_categories9: BusinessSecondaryCategoryEntity

  """business countries."""
  fr_countries: CountryEntity

  """business states."""
  fr_state: StateEntity

  """business cities."""
  fr_city: CityEntity
}

input BusinessFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: BusinessFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: BusinessFindInputSortOrder
}

input BusinessFindInputGroupBy {
  owner_u_id: Boolean
  buspricat_id: Boolean
  name: Boolean
  country_id: Boolean
  state_id: Boolean
  city_id: Boolean
  zipcode: Boolean
  email: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input BusinessFindInputSortOrder {
  id: RecordSortDirectionEnum
  owner_u_id: RecordSortDirectionEnum
  buspricat_id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  country_id: RecordSortDirectionEnum
  state_id: RecordSortDirectionEnum
  city_id: RecordSortDirectionEnum
  zipcode: RecordSortDirectionEnum
  email: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input BusinessFindInputWhere {
  """Unique ID of the business, auto generated."""
  id: FindOperatorDto

  """User owner Id of the business."""
  owner_u_id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Id of the business secondary category 1."""
  busseccat_id_1: FindOperatorDto

  """ID of the business secondary category 2."""
  busseccat_id_2: FindOperatorDto

  """ID of the business secondary category 3."""
  busseccat_id_3: FindOperatorDto

  """ID of the business secondary category 4."""
  busseccat_id_4: FindOperatorDto

  """ID of the business secondary category 5."""
  busseccat_id_5: FindOperatorDto

  """ID of the business secondary category 6."""
  busseccat_id_6: FindOperatorDto

  """ID of the business secondary category 7."""
  busseccat_id_7: FindOperatorDto

  """ID of the business secondary category 8."""
  busseccat_id_8: FindOperatorDto

  """ID of the business secondary category 9."""
  busseccat_id_9: FindOperatorDto

  """Name of the business."""
  name: FindOperatorDto

  """Address of the business."""
  address: FindOperatorDto

  """ID of the country where the business is located."""
  country_id: FindOperatorDto

  """ID of the state where the business is located."""
  state_id: FindOperatorDto

  """ID of the city where the business is located."""
  city_id: FindOperatorDto

  """Email address of the business."""
  email: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_owner_user: [UserFindInputWhere!]

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]

  """business secondary categories level 1."""
  fr_secondary_categories1: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 2."""
  fr_secondary_categories2: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 3."""
  fr_secondary_categories3: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 4."""
  fr_secondary_categories4: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 5."""
  fr_secondary_categories5: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 6."""
  fr_secondary_categories6: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 7."""
  fr_secondary_categories7: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 8."""
  fr_secondary_categories8: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 9."""
  fr_secondary_categories9: [BusinessSecondaryCategoryFindInputWhere!]

  """business countries."""
  fr_countries: [CountryFindInputWhere!]

  """business states."""
  fr_state: [StateFindInputWhere!]

  """business cities."""
  fr_city: [CityFindInputWhere!]
}

input BusinessFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type BusinessFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [BusinessEntity!]!
}

input BusinessPrimaryCategoryCreateInput {
  """Title of the business primary category."""
  title: String!

  """Description of the business primary category."""
  desc: String

  """Active of the business primary category."""
  active: DateTime
}

type BusinessPrimaryCategoryCreateOutput {
  """Unique ID of the business primary category, auto generated."""
  id: Int

  """Title of the business primary category."""
  title: String

  """Description of the business primary category."""
  desc: String

  """Active of the business primary category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Business secondary category."""
  fr_secondary_categories: [BusinessSecondaryCategoryEntity!]

  """Business primary category."""
  fr_business_categories: [BusinessEntity!]
}

input BusinessPrimaryCategoryDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessPrimaryCategoryDeleteInputWhere!]
}

input BusinessPrimaryCategoryDeleteInputWhere {
  """Unique ID of the business primary category, auto generated."""
  id: FindOperatorDto

  """Title of the business primary category."""
  title: FindOperatorDto

  """Active of the business primary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type BusinessPrimaryCategoryDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type BusinessPrimaryCategoryEntity {
  """Unique ID of the business primary category, auto generated."""
  id: Int

  """Title of the business primary category."""
  title: String

  """Description of the business primary category."""
  desc: String

  """Active of the business primary category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Business secondary category."""
  fr_secondary_categories: [BusinessSecondaryCategoryEntity!]

  """Business primary category."""
  fr_business_categories: [BusinessEntity!]
}

input BusinessPrimaryCategoryFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessPrimaryCategoryFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: BusinessPrimaryCategoryFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: BusinessPrimaryCategoryFindInputSortOrder
}

input BusinessPrimaryCategoryFindInputGroupBy {
  title: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input BusinessPrimaryCategoryFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input BusinessPrimaryCategoryFindInputWhere {
  """Unique ID of the business primary category, auto generated."""
  id: FindOperatorDto

  """Title of the business primary category."""
  title: FindOperatorDto

  """Active of the business primary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

input BusinessPrimaryCategoryFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type BusinessPrimaryCategoryFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [BusinessPrimaryCategoryEntity!]!
}

input BusinessPrimaryCategoryRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessPrimaryCategoryRecoverInputWhere!]
}

input BusinessPrimaryCategoryRecoverInputWhere {
  """Unique ID of the business primary category, auto generated."""
  id: FindOperatorDto

  """Title of the business primary category."""
  title: FindOperatorDto

  """Active of the business primary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type BusinessPrimaryCategoryRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [BusinessPrimaryCategoryEntity!]!
}

input BusinessPrimaryCategoryRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessPrimaryCategoryRemoveInputWhere!]
}

input BusinessPrimaryCategoryRemoveInputWhere {
  """Unique ID of the business primary category, auto generated."""
  id: FindOperatorDto

  """Title of the business primary category."""
  title: FindOperatorDto

  """Active of the business primary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type BusinessPrimaryCategoryRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [BusinessPrimaryCategoryEntity!]!
}

input BusinessPrimaryCategoryRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessPrimaryCategoryRestoreInputWhere!]
}

input BusinessPrimaryCategoryRestoreInputWhere {
  """Unique ID of the business primary category, auto generated."""
  id: FindOperatorDto

  """Title of the business primary category."""
  title: FindOperatorDto

  """Active of the business primary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type BusinessPrimaryCategoryRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input BusinessPrimaryCategorySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessPrimaryCategorySoftDeleteInputWhere!]
}

input BusinessPrimaryCategorySoftDeleteInputWhere {
  """Unique ID of the business primary category, auto generated."""
  id: FindOperatorDto

  """Title of the business primary category."""
  title: FindOperatorDto

  """Active of the business primary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type BusinessPrimaryCategorySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input BusinessPrimaryCategorySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessPrimaryCategorySoftRemoveInputWhere!]
}

input BusinessPrimaryCategorySoftRemoveInputWhere {
  """Unique ID of the business primary category, auto generated."""
  id: FindOperatorDto

  """Title of the business primary category."""
  title: FindOperatorDto

  """Active of the business primary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type BusinessPrimaryCategorySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [BusinessPrimaryCategoryEntity!]!
}

input BusinessPrimaryCategoryUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessPrimaryCategoryUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: BusinessPrimaryCategoryUpdateInputSets!
}

input BusinessPrimaryCategoryUpdateInputSets {
  """Title of the business primary category."""
  title: String

  """Description of the business primary category."""
  desc: String

  """Active of the business primary category."""
  active: DateTime
}

input BusinessPrimaryCategoryUpdateInputWhere {
  """Unique ID of the business primary category, auto generated."""
  id: FindOperatorDto

  """Title of the business primary category."""
  title: FindOperatorDto

  """Active of the business primary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type BusinessPrimaryCategoryUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [BusinessPrimaryCategoryEntity!]!
}

input BusinessPrimaryCategoryUpsertInput {
  """Title of the business primary category."""
  title: String!

  """Description of the business primary category."""
  desc: String

  """Active of the business primary category."""
  active: DateTime

  """Unique ID of the business primary category, auto generated. undefined"""
  id: Int
}

type BusinessPrimaryCategoryUpsertOutput {
  """Unique ID of the business primary category, auto generated."""
  id: Int

  """Title of the business primary category."""
  title: String

  """Description of the business primary category."""
  desc: String

  """Active of the business primary category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Business secondary category."""
  fr_secondary_categories: [BusinessSecondaryCategoryEntity!]

  """Business primary category."""
  fr_business_categories: [BusinessEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input BusinessRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessRecoverInputWhere!]
}

input BusinessRecoverInputWhere {
  """Unique ID of the business, auto generated."""
  id: FindOperatorDto

  """User owner Id of the business."""
  owner_u_id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Id of the business secondary category 1."""
  busseccat_id_1: FindOperatorDto

  """ID of the business secondary category 2."""
  busseccat_id_2: FindOperatorDto

  """ID of the business secondary category 3."""
  busseccat_id_3: FindOperatorDto

  """ID of the business secondary category 4."""
  busseccat_id_4: FindOperatorDto

  """ID of the business secondary category 5."""
  busseccat_id_5: FindOperatorDto

  """ID of the business secondary category 6."""
  busseccat_id_6: FindOperatorDto

  """ID of the business secondary category 7."""
  busseccat_id_7: FindOperatorDto

  """ID of the business secondary category 8."""
  busseccat_id_8: FindOperatorDto

  """ID of the business secondary category 9."""
  busseccat_id_9: FindOperatorDto

  """Name of the business."""
  name: FindOperatorDto

  """Address of the business."""
  address: FindOperatorDto

  """ID of the country where the business is located."""
  country_id: FindOperatorDto

  """ID of the state where the business is located."""
  state_id: FindOperatorDto

  """ID of the city where the business is located."""
  city_id: FindOperatorDto

  """Email address of the business."""
  email: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_owner_user: [UserFindInputWhere!]

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]

  """business secondary categories level 1."""
  fr_secondary_categories1: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 2."""
  fr_secondary_categories2: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 3."""
  fr_secondary_categories3: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 4."""
  fr_secondary_categories4: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 5."""
  fr_secondary_categories5: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 6."""
  fr_secondary_categories6: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 7."""
  fr_secondary_categories7: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 8."""
  fr_secondary_categories8: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 9."""
  fr_secondary_categories9: [BusinessSecondaryCategoryFindInputWhere!]

  """business countries."""
  fr_countries: [CountryFindInputWhere!]

  """business states."""
  fr_state: [StateFindInputWhere!]

  """business cities."""
  fr_city: [CityFindInputWhere!]
}

type BusinessRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [BusinessEntity!]!
}

input BusinessRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessRemoveInputWhere!]
}

input BusinessRemoveInputWhere {
  """Unique ID of the business, auto generated."""
  id: FindOperatorDto

  """User owner Id of the business."""
  owner_u_id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Id of the business secondary category 1."""
  busseccat_id_1: FindOperatorDto

  """ID of the business secondary category 2."""
  busseccat_id_2: FindOperatorDto

  """ID of the business secondary category 3."""
  busseccat_id_3: FindOperatorDto

  """ID of the business secondary category 4."""
  busseccat_id_4: FindOperatorDto

  """ID of the business secondary category 5."""
  busseccat_id_5: FindOperatorDto

  """ID of the business secondary category 6."""
  busseccat_id_6: FindOperatorDto

  """ID of the business secondary category 7."""
  busseccat_id_7: FindOperatorDto

  """ID of the business secondary category 8."""
  busseccat_id_8: FindOperatorDto

  """ID of the business secondary category 9."""
  busseccat_id_9: FindOperatorDto

  """Name of the business."""
  name: FindOperatorDto

  """Address of the business."""
  address: FindOperatorDto

  """ID of the country where the business is located."""
  country_id: FindOperatorDto

  """ID of the state where the business is located."""
  state_id: FindOperatorDto

  """ID of the city where the business is located."""
  city_id: FindOperatorDto

  """Email address of the business."""
  email: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_owner_user: [UserFindInputWhere!]

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]

  """business secondary categories level 1."""
  fr_secondary_categories1: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 2."""
  fr_secondary_categories2: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 3."""
  fr_secondary_categories3: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 4."""
  fr_secondary_categories4: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 5."""
  fr_secondary_categories5: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 6."""
  fr_secondary_categories6: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 7."""
  fr_secondary_categories7: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 8."""
  fr_secondary_categories8: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 9."""
  fr_secondary_categories9: [BusinessSecondaryCategoryFindInputWhere!]

  """business countries."""
  fr_countries: [CountryFindInputWhere!]

  """business states."""
  fr_state: [StateFindInputWhere!]

  """business cities."""
  fr_city: [CityFindInputWhere!]
}

type BusinessRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [BusinessEntity!]!
}

input BusinessRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessRestoreInputWhere!]
}

input BusinessRestoreInputWhere {
  """Unique ID of the business, auto generated."""
  id: FindOperatorDto

  """User owner Id of the business."""
  owner_u_id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Id of the business secondary category 1."""
  busseccat_id_1: FindOperatorDto

  """ID of the business secondary category 2."""
  busseccat_id_2: FindOperatorDto

  """ID of the business secondary category 3."""
  busseccat_id_3: FindOperatorDto

  """ID of the business secondary category 4."""
  busseccat_id_4: FindOperatorDto

  """ID of the business secondary category 5."""
  busseccat_id_5: FindOperatorDto

  """ID of the business secondary category 6."""
  busseccat_id_6: FindOperatorDto

  """ID of the business secondary category 7."""
  busseccat_id_7: FindOperatorDto

  """ID of the business secondary category 8."""
  busseccat_id_8: FindOperatorDto

  """ID of the business secondary category 9."""
  busseccat_id_9: FindOperatorDto

  """Name of the business."""
  name: FindOperatorDto

  """Address of the business."""
  address: FindOperatorDto

  """ID of the country where the business is located."""
  country_id: FindOperatorDto

  """ID of the state where the business is located."""
  state_id: FindOperatorDto

  """ID of the city where the business is located."""
  city_id: FindOperatorDto

  """Email address of the business."""
  email: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_owner_user: [UserFindInputWhere!]

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]

  """business secondary categories level 1."""
  fr_secondary_categories1: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 2."""
  fr_secondary_categories2: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 3."""
  fr_secondary_categories3: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 4."""
  fr_secondary_categories4: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 5."""
  fr_secondary_categories5: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 6."""
  fr_secondary_categories6: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 7."""
  fr_secondary_categories7: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 8."""
  fr_secondary_categories8: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 9."""
  fr_secondary_categories9: [BusinessSecondaryCategoryFindInputWhere!]

  """business countries."""
  fr_countries: [CountryFindInputWhere!]

  """business states."""
  fr_state: [StateFindInputWhere!]

  """business cities."""
  fr_city: [CityFindInputWhere!]
}

type BusinessRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input BusinessSecondaryCategoryCreateInput {
  """Id of the business primary category."""
  buspricat_id: Int!

  """Title of the business secondary category."""
  title: String!

  """Description of the business secondary category."""
  desc: String

  """Active of the business secondary category."""
  active: DateTime
}

type BusinessSecondaryCategoryCreateOutput {
  """Unique ID of the business secondary category, auto generated."""
  id: Int

  """Id of the business primary category."""
  buspricat_id: Int

  """Title of the business secondary category."""
  title: String

  """Description of the business secondary category."""
  desc: String

  """Active of the business secondary category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """business primary categories."""
  fr_primary_categories: BusinessPrimaryCategoryEntity

  """Businesses related to secondary category 1."""
  fr_buiss_sec_categories1: [BusinessEntity!]

  """Businesses related to secondary category 2."""
  fr_buiss_sec_categories2: [BusinessEntity!]

  """Businesses related to secondary category 3."""
  fr_buiss_sec_categories3: [BusinessEntity!]

  """Businesses related to secondary category 4."""
  fr_buiss_sec_categories4: [BusinessEntity!]

  """Businesses related to secondary category 5."""
  fr_buiss_sec_categories5: [BusinessEntity!]

  """Businesses related to secondary category 6."""
  fr_buiss_sec_categories6: [BusinessEntity!]

  """Businesses related to secondary category 7."""
  fr_buiss_sec_categories7: [BusinessEntity!]

  """Businesses related to secondary category 8."""
  fr_buiss_sec_categories8: [BusinessEntity!]

  """Businesses related to secondary category 9."""
  fr_buiss_sec_categories9: [BusinessEntity!]
}

input BusinessSecondaryCategoryDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessSecondaryCategoryDeleteInputWhere!]
}

input BusinessSecondaryCategoryDeleteInputWhere {
  """Unique ID of the business secondary category, auto generated."""
  id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Title of the business secondary category."""
  title: FindOperatorDto

  """Active of the business secondary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]
}

type BusinessSecondaryCategoryDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type BusinessSecondaryCategoryEntity {
  """Unique ID of the business secondary category, auto generated."""
  id: Int

  """Id of the business primary category."""
  buspricat_id: Int

  """Title of the business secondary category."""
  title: String

  """Description of the business secondary category."""
  desc: String

  """Active of the business secondary category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """business primary categories."""
  fr_primary_categories: BusinessPrimaryCategoryEntity

  """Businesses related to secondary category 1."""
  fr_buiss_sec_categories1: [BusinessEntity!]

  """Businesses related to secondary category 2."""
  fr_buiss_sec_categories2: [BusinessEntity!]

  """Businesses related to secondary category 3."""
  fr_buiss_sec_categories3: [BusinessEntity!]

  """Businesses related to secondary category 4."""
  fr_buiss_sec_categories4: [BusinessEntity!]

  """Businesses related to secondary category 5."""
  fr_buiss_sec_categories5: [BusinessEntity!]

  """Businesses related to secondary category 6."""
  fr_buiss_sec_categories6: [BusinessEntity!]

  """Businesses related to secondary category 7."""
  fr_buiss_sec_categories7: [BusinessEntity!]

  """Businesses related to secondary category 8."""
  fr_buiss_sec_categories8: [BusinessEntity!]

  """Businesses related to secondary category 9."""
  fr_buiss_sec_categories9: [BusinessEntity!]
}

input BusinessSecondaryCategoryFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessSecondaryCategoryFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: BusinessSecondaryCategoryFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: BusinessSecondaryCategoryFindInputSortOrder
}

input BusinessSecondaryCategoryFindInputGroupBy {
  title: Boolean
  buspricat_id: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input BusinessSecondaryCategoryFindInputSortOrder {
  id: RecordSortDirectionEnum
  buspricat_id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input BusinessSecondaryCategoryFindInputWhere {
  """Unique ID of the business secondary category, auto generated."""
  id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Title of the business secondary category."""
  title: FindOperatorDto

  """Active of the business secondary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]
}

input BusinessSecondaryCategoryFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type BusinessSecondaryCategoryFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [BusinessSecondaryCategoryEntity!]!
}

input BusinessSecondaryCategoryRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessSecondaryCategoryRecoverInputWhere!]
}

input BusinessSecondaryCategoryRecoverInputWhere {
  """Unique ID of the business secondary category, auto generated."""
  id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Title of the business secondary category."""
  title: FindOperatorDto

  """Active of the business secondary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]
}

type BusinessSecondaryCategoryRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [BusinessSecondaryCategoryEntity!]!
}

input BusinessSecondaryCategoryRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessSecondaryCategoryRemoveInputWhere!]
}

input BusinessSecondaryCategoryRemoveInputWhere {
  """Unique ID of the business secondary category, auto generated."""
  id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Title of the business secondary category."""
  title: FindOperatorDto

  """Active of the business secondary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]
}

type BusinessSecondaryCategoryRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [BusinessSecondaryCategoryEntity!]!
}

input BusinessSecondaryCategoryRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessSecondaryCategoryRestoreInputWhere!]
}

input BusinessSecondaryCategoryRestoreInputWhere {
  """Unique ID of the business secondary category, auto generated."""
  id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Title of the business secondary category."""
  title: FindOperatorDto

  """Active of the business secondary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]
}

type BusinessSecondaryCategoryRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input BusinessSecondaryCategorySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessSecondaryCategorySoftDeleteInputWhere!]
}

input BusinessSecondaryCategorySoftDeleteInputWhere {
  """Unique ID of the business secondary category, auto generated."""
  id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Title of the business secondary category."""
  title: FindOperatorDto

  """Active of the business secondary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]
}

type BusinessSecondaryCategorySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input BusinessSecondaryCategorySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessSecondaryCategorySoftRemoveInputWhere!]
}

input BusinessSecondaryCategorySoftRemoveInputWhere {
  """Unique ID of the business secondary category, auto generated."""
  id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Title of the business secondary category."""
  title: FindOperatorDto

  """Active of the business secondary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]
}

type BusinessSecondaryCategorySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [BusinessSecondaryCategoryEntity!]!
}

input BusinessSecondaryCategoryUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessSecondaryCategoryUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: BusinessSecondaryCategoryUpdateInputSets!
}

input BusinessSecondaryCategoryUpdateInputSets {
  """Id of the business primary category."""
  buspricat_id: Int

  """Title of the business secondary category."""
  title: String

  """Description of the business secondary category."""
  desc: String

  """Active of the business secondary category."""
  active: DateTime
}

input BusinessSecondaryCategoryUpdateInputWhere {
  """Unique ID of the business secondary category, auto generated."""
  id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Title of the business secondary category."""
  title: FindOperatorDto

  """Active of the business secondary category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]
}

type BusinessSecondaryCategoryUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [BusinessSecondaryCategoryEntity!]!
}

input BusinessSecondaryCategoryUpsertInput {
  """Id of the business primary category."""
  buspricat_id: Int!

  """Title of the business secondary category."""
  title: String!

  """Description of the business secondary category."""
  desc: String

  """Active of the business secondary category."""
  active: DateTime

  """
  Unique ID of the business secondary category, auto generated. undefined
  """
  id: Int
}

type BusinessSecondaryCategoryUpsertOutput {
  """Unique ID of the business secondary category, auto generated."""
  id: Int

  """Id of the business primary category."""
  buspricat_id: Int

  """Title of the business secondary category."""
  title: String

  """Description of the business secondary category."""
  desc: String

  """Active of the business secondary category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """business primary categories."""
  fr_primary_categories: BusinessPrimaryCategoryEntity

  """Businesses related to secondary category 1."""
  fr_buiss_sec_categories1: [BusinessEntity!]

  """Businesses related to secondary category 2."""
  fr_buiss_sec_categories2: [BusinessEntity!]

  """Businesses related to secondary category 3."""
  fr_buiss_sec_categories3: [BusinessEntity!]

  """Businesses related to secondary category 4."""
  fr_buiss_sec_categories4: [BusinessEntity!]

  """Businesses related to secondary category 5."""
  fr_buiss_sec_categories5: [BusinessEntity!]

  """Businesses related to secondary category 6."""
  fr_buiss_sec_categories6: [BusinessEntity!]

  """Businesses related to secondary category 7."""
  fr_buiss_sec_categories7: [BusinessEntity!]

  """Businesses related to secondary category 8."""
  fr_buiss_sec_categories8: [BusinessEntity!]

  """Businesses related to secondary category 9."""
  fr_buiss_sec_categories9: [BusinessEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input BusinessSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessSoftDeleteInputWhere!]
}

input BusinessSoftDeleteInputWhere {
  """Unique ID of the business, auto generated."""
  id: FindOperatorDto

  """User owner Id of the business."""
  owner_u_id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Id of the business secondary category 1."""
  busseccat_id_1: FindOperatorDto

  """ID of the business secondary category 2."""
  busseccat_id_2: FindOperatorDto

  """ID of the business secondary category 3."""
  busseccat_id_3: FindOperatorDto

  """ID of the business secondary category 4."""
  busseccat_id_4: FindOperatorDto

  """ID of the business secondary category 5."""
  busseccat_id_5: FindOperatorDto

  """ID of the business secondary category 6."""
  busseccat_id_6: FindOperatorDto

  """ID of the business secondary category 7."""
  busseccat_id_7: FindOperatorDto

  """ID of the business secondary category 8."""
  busseccat_id_8: FindOperatorDto

  """ID of the business secondary category 9."""
  busseccat_id_9: FindOperatorDto

  """Name of the business."""
  name: FindOperatorDto

  """Address of the business."""
  address: FindOperatorDto

  """ID of the country where the business is located."""
  country_id: FindOperatorDto

  """ID of the state where the business is located."""
  state_id: FindOperatorDto

  """ID of the city where the business is located."""
  city_id: FindOperatorDto

  """Email address of the business."""
  email: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_owner_user: [UserFindInputWhere!]

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]

  """business secondary categories level 1."""
  fr_secondary_categories1: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 2."""
  fr_secondary_categories2: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 3."""
  fr_secondary_categories3: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 4."""
  fr_secondary_categories4: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 5."""
  fr_secondary_categories5: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 6."""
  fr_secondary_categories6: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 7."""
  fr_secondary_categories7: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 8."""
  fr_secondary_categories8: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 9."""
  fr_secondary_categories9: [BusinessSecondaryCategoryFindInputWhere!]

  """business countries."""
  fr_countries: [CountryFindInputWhere!]

  """business states."""
  fr_state: [StateFindInputWhere!]

  """business cities."""
  fr_city: [CityFindInputWhere!]
}

type BusinessSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input BusinessSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessSoftRemoveInputWhere!]
}

input BusinessSoftRemoveInputWhere {
  """Unique ID of the business, auto generated."""
  id: FindOperatorDto

  """User owner Id of the business."""
  owner_u_id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Id of the business secondary category 1."""
  busseccat_id_1: FindOperatorDto

  """ID of the business secondary category 2."""
  busseccat_id_2: FindOperatorDto

  """ID of the business secondary category 3."""
  busseccat_id_3: FindOperatorDto

  """ID of the business secondary category 4."""
  busseccat_id_4: FindOperatorDto

  """ID of the business secondary category 5."""
  busseccat_id_5: FindOperatorDto

  """ID of the business secondary category 6."""
  busseccat_id_6: FindOperatorDto

  """ID of the business secondary category 7."""
  busseccat_id_7: FindOperatorDto

  """ID of the business secondary category 8."""
  busseccat_id_8: FindOperatorDto

  """ID of the business secondary category 9."""
  busseccat_id_9: FindOperatorDto

  """Name of the business."""
  name: FindOperatorDto

  """Address of the business."""
  address: FindOperatorDto

  """ID of the country where the business is located."""
  country_id: FindOperatorDto

  """ID of the state where the business is located."""
  state_id: FindOperatorDto

  """ID of the city where the business is located."""
  city_id: FindOperatorDto

  """Email address of the business."""
  email: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_owner_user: [UserFindInputWhere!]

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]

  """business secondary categories level 1."""
  fr_secondary_categories1: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 2."""
  fr_secondary_categories2: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 3."""
  fr_secondary_categories3: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 4."""
  fr_secondary_categories4: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 5."""
  fr_secondary_categories5: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 6."""
  fr_secondary_categories6: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 7."""
  fr_secondary_categories7: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 8."""
  fr_secondary_categories8: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 9."""
  fr_secondary_categories9: [BusinessSecondaryCategoryFindInputWhere!]

  """business countries."""
  fr_countries: [CountryFindInputWhere!]

  """business states."""
  fr_state: [StateFindInputWhere!]

  """business cities."""
  fr_city: [CityFindInputWhere!]
}

type BusinessSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [BusinessEntity!]!
}

input BusinessUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [BusinessUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: BusinessUpdateInputSets!
}

input BusinessUpdateInputSets {
  """User owner Id of the business."""
  owner_u_id: Int

  """Brand logo of the business."""
  file_brand_logo: String

  """Id of the business primary category."""
  buspricat_id: Int

  """Id of the business secondary category 1."""
  busseccat_id_1: Int

  """ID of the business secondary category 2."""
  busseccat_id_2: Int

  """ID of the business secondary category 3."""
  busseccat_id_3: Int

  """ID of the business secondary category 4."""
  busseccat_id_4: Int

  """ID of the business secondary category 5."""
  busseccat_id_5: Int

  """ID of the business secondary category 6."""
  busseccat_id_6: Int

  """ID of the business secondary category 7."""
  busseccat_id_7: Int

  """ID of the business secondary category 8."""
  busseccat_id_8: Int

  """ID of the business secondary category 9."""
  busseccat_id_9: Int

  """Name of the business."""
  name: String

  """About section of the business."""
  about: String

  """Address of the business."""
  address: String

  """ID of the country where the business is located."""
  country_id: Int

  """ID of the state where the business is located."""
  state_id: Int

  """ID of the city where the business is located."""
  city_id: Int

  """ZIP or postal code of the business location."""
  zipcode: String

  """Geographic latitude of the business location."""
  location_latitude: Float

  """Geographic longitude of the business location."""
  location_longitude: Float

  """Toll-free contact number for the business."""
  toll_free_number: String

  """Mobile contact number for the business."""
  mobile: String

  """Country code for the mobile number."""
  mobile_cc: String

  """WhatsApp number for the business."""
  whatsapp: String

  """Country code for WhatsApp number."""
  whatsapp_cc: String

  """Email address of the business."""
  email: String

  """Fax number of the business."""
  fax: String

  """Website URL of the business."""
  website_url: String

  """Facebook profile URL."""
  facebook_profile: String

  """Instagram profile URL."""
  instagram_profile: String

  """YouTube channel or profile URL."""
  youtube_profile: String

  """X profile URL."""
  x_profile: String

  """LinkedIn profile URL."""
  linkedin_profile: String

  """TikTok profile URL."""
  tiktok_profile: String

  """Pinterest profile URL."""
  pinterest_profile: String

  """Google My Business profile URL."""
  google_my_business_url: String

  """Google Maps URL for the business location."""
  google_map_url: String

  """URL to Google Reviews of the business."""
  google_review_url: String

  """Flag indicating whether the business is officially registered."""
  registered: DateTime

  """Initial assessment or notes about the business."""
  initial_findings: String

  """Competitor assessment or notes about the business."""
  competitor_findings: String
}

input BusinessUpdateInputWhere {
  """Unique ID of the business, auto generated."""
  id: FindOperatorDto

  """User owner Id of the business."""
  owner_u_id: FindOperatorDto

  """Id of the business primary category."""
  buspricat_id: FindOperatorDto

  """Id of the business secondary category 1."""
  busseccat_id_1: FindOperatorDto

  """ID of the business secondary category 2."""
  busseccat_id_2: FindOperatorDto

  """ID of the business secondary category 3."""
  busseccat_id_3: FindOperatorDto

  """ID of the business secondary category 4."""
  busseccat_id_4: FindOperatorDto

  """ID of the business secondary category 5."""
  busseccat_id_5: FindOperatorDto

  """ID of the business secondary category 6."""
  busseccat_id_6: FindOperatorDto

  """ID of the business secondary category 7."""
  busseccat_id_7: FindOperatorDto

  """ID of the business secondary category 8."""
  busseccat_id_8: FindOperatorDto

  """ID of the business secondary category 9."""
  busseccat_id_9: FindOperatorDto

  """Name of the business."""
  name: FindOperatorDto

  """Address of the business."""
  address: FindOperatorDto

  """ID of the country where the business is located."""
  country_id: FindOperatorDto

  """ID of the state where the business is located."""
  state_id: FindOperatorDto

  """ID of the city where the business is located."""
  city_id: FindOperatorDto

  """Email address of the business."""
  email: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """business primary categories."""
  fr_owner_user: [UserFindInputWhere!]

  """business primary categories."""
  fr_primary_categories: [BusinessPrimaryCategoryFindInputWhere!]

  """business secondary categories level 1."""
  fr_secondary_categories1: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 2."""
  fr_secondary_categories2: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 3."""
  fr_secondary_categories3: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 4."""
  fr_secondary_categories4: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 5."""
  fr_secondary_categories5: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 6."""
  fr_secondary_categories6: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 7."""
  fr_secondary_categories7: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 8."""
  fr_secondary_categories8: [BusinessSecondaryCategoryFindInputWhere!]

  """business secondary categories level 9."""
  fr_secondary_categories9: [BusinessSecondaryCategoryFindInputWhere!]

  """business countries."""
  fr_countries: [CountryFindInputWhere!]

  """business states."""
  fr_state: [StateFindInputWhere!]

  """business cities."""
  fr_city: [CityFindInputWhere!]
}

type BusinessUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [BusinessEntity!]!
}

input BusinessUpsertInput {
  """User owner Id of the business."""
  owner_u_id: Int

  """Brand logo of the business."""
  file_brand_logo: String

  """Id of the business primary category."""
  buspricat_id: Int!

  """Id of the business secondary category 1."""
  busseccat_id_1: Int

  """ID of the business secondary category 2."""
  busseccat_id_2: Int

  """ID of the business secondary category 3."""
  busseccat_id_3: Int

  """ID of the business secondary category 4."""
  busseccat_id_4: Int

  """ID of the business secondary category 5."""
  busseccat_id_5: Int

  """ID of the business secondary category 6."""
  busseccat_id_6: Int

  """ID of the business secondary category 7."""
  busseccat_id_7: Int

  """ID of the business secondary category 8."""
  busseccat_id_8: Int

  """ID of the business secondary category 9."""
  busseccat_id_9: Int

  """Name of the business."""
  name: String

  """About section of the business."""
  about: String

  """Address of the business."""
  address: String

  """ID of the country where the business is located."""
  country_id: Int

  """ID of the state where the business is located."""
  state_id: Int

  """ID of the city where the business is located."""
  city_id: Int

  """ZIP or postal code of the business location."""
  zipcode: String

  """Geographic latitude of the business location."""
  location_latitude: Float

  """Geographic longitude of the business location."""
  location_longitude: Float

  """Toll-free contact number for the business."""
  toll_free_number: String

  """Mobile contact number for the business."""
  mobile: String

  """Country code for the mobile number."""
  mobile_cc: String

  """WhatsApp number for the business."""
  whatsapp: String

  """Country code for WhatsApp number."""
  whatsapp_cc: String

  """Email address of the business."""
  email: String

  """Fax number of the business."""
  fax: String

  """Website URL of the business."""
  website_url: String

  """Facebook profile URL."""
  facebook_profile: String

  """Instagram profile URL."""
  instagram_profile: String

  """YouTube channel or profile URL."""
  youtube_profile: String

  """X profile URL."""
  x_profile: String

  """LinkedIn profile URL."""
  linkedin_profile: String

  """TikTok profile URL."""
  tiktok_profile: String

  """Pinterest profile URL."""
  pinterest_profile: String

  """Google My Business profile URL."""
  google_my_business_url: String

  """Google Maps URL for the business location."""
  google_map_url: String

  """URL to Google Reviews of the business."""
  google_review_url: String

  """Flag indicating whether the business is officially registered."""
  registered: DateTime

  """Initial assessment or notes about the business."""
  initial_findings: String

  """Competitor assessment or notes about the business."""
  competitor_findings: String

  """Unique ID of the business, auto generated. undefined"""
  id: Int
}

type BusinessUpsertOutput {
  """Unique ID of the business, auto generated."""
  id: Int

  """User owner Id of the business."""
  owner_u_id: Int

  """Brand logo of the business."""
  file_brand_logo: String

  """Id of the business primary category."""
  buspricat_id: Int

  """Id of the business secondary category 1."""
  busseccat_id_1: Int

  """ID of the business secondary category 2."""
  busseccat_id_2: Int

  """ID of the business secondary category 3."""
  busseccat_id_3: Int

  """ID of the business secondary category 4."""
  busseccat_id_4: Int

  """ID of the business secondary category 5."""
  busseccat_id_5: Int

  """ID of the business secondary category 6."""
  busseccat_id_6: Int

  """ID of the business secondary category 7."""
  busseccat_id_7: Int

  """ID of the business secondary category 8."""
  busseccat_id_8: Int

  """ID of the business secondary category 9."""
  busseccat_id_9: Int

  """Name of the business."""
  name: String

  """About section of the business."""
  about: String

  """Address of the business."""
  address: String

  """ID of the country where the business is located."""
  country_id: Int

  """ID of the state where the business is located."""
  state_id: Int

  """ID of the city where the business is located."""
  city_id: Int

  """ZIP or postal code of the business location."""
  zipcode: String

  """Geographic latitude of the business location."""
  location_latitude: Float

  """Geographic longitude of the business location."""
  location_longitude: Float

  """Toll-free contact number for the business."""
  toll_free_number: String

  """Mobile contact number for the business."""
  mobile: String

  """Country code for the mobile number."""
  mobile_cc: String

  """WhatsApp number for the business."""
  whatsapp: String

  """Country code for WhatsApp number."""
  whatsapp_cc: String

  """Email address of the business."""
  email: String

  """Fax number of the business."""
  fax: String

  """Website URL of the business."""
  website_url: String

  """Facebook profile URL."""
  facebook_profile: String

  """Instagram profile URL."""
  instagram_profile: String

  """YouTube channel or profile URL."""
  youtube_profile: String

  """X profile URL."""
  x_profile: String

  """LinkedIn profile URL."""
  linkedin_profile: String

  """TikTok profile URL."""
  tiktok_profile: String

  """Pinterest profile URL."""
  pinterest_profile: String

  """Google My Business profile URL."""
  google_my_business_url: String

  """Google Maps URL for the business location."""
  google_map_url: String

  """URL to Google Reviews of the business."""
  google_review_url: String

  """Flag indicating whether the business is officially registered."""
  registered: DateTime

  """Initial assessment or notes about the business."""
  initial_findings: String

  """Competitor assessment or notes about the business."""
  competitor_findings: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """business primary categories."""
  fr_owner_user: UserEntity

  """business primary categories."""
  fr_primary_categories: BusinessPrimaryCategoryEntity

  """business secondary categories level 1."""
  fr_secondary_categories1: BusinessSecondaryCategoryEntity

  """business secondary categories level 2."""
  fr_secondary_categories2: BusinessSecondaryCategoryEntity

  """business secondary categories level 3."""
  fr_secondary_categories3: BusinessSecondaryCategoryEntity

  """business secondary categories level 4."""
  fr_secondary_categories4: BusinessSecondaryCategoryEntity

  """business secondary categories level 5."""
  fr_secondary_categories5: BusinessSecondaryCategoryEntity

  """business secondary categories level 6."""
  fr_secondary_categories6: BusinessSecondaryCategoryEntity

  """business secondary categories level 7."""
  fr_secondary_categories7: BusinessSecondaryCategoryEntity

  """business secondary categories level 8."""
  fr_secondary_categories8: BusinessSecondaryCategoryEntity

  """business secondary categories level 9."""
  fr_secondary_categories9: BusinessSecondaryCategoryEntity

  """business countries."""
  fr_countries: CountryEntity

  """business states."""
  fr_state: StateEntity

  """business cities."""
  fr_city: CityEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input CityCreateInput {
  """State of the city."""
  state_id: Int!

  """Timezone of the city."""
  tz_id: Int!

  """Name of the city."""
  name: String!

  """Latitude of the city."""
  latitude: Float!

  """Longitude of the city."""
  longitude: Float!
}

type CityCreateOutput {
  """Unique ID of the state, auto generated."""
  id: Int

  """State of the city."""
  state_id: Int

  """Timezone of the city."""
  tz_id: Int

  """Name of the city."""
  name: String

  """Latitude of the city."""
  latitude: Float

  """Longitude of the city."""
  longitude: Float

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """State info of the city."""
  fr_state: StateEntity

  """Timezone info of the city."""
  fr_timezone: TimezoneEntity

  """List of user address in this city."""
  fr_user_addresses: [UserAddressEntity!]

  """List of user identity cards for this city."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """List of user corporate infos for this city."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """List of newsletter tracking log for this city."""
  fr_newsletter_tracking_log_infos: [NewsLetterTrackLogEntity!]

  """List of business infos for this city."""
  fr_business: [BusinessEntity!]
}

input CityDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CityDeleteInputWhere!]
}

input CityDeleteInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """State of the city."""
  state_id: FindOperatorDto

  """Timezone of the city."""
  tz_id: FindOperatorDto

  """Name of the city."""
  name: FindOperatorDto

  """Latitude of the city."""
  latitude: FindOperatorDto

  """Longitude of the city."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """State info of the city."""
  fr_state: [StateFindInputWhere!]

  """Timezone info of the city."""
  fr_timezone: [TimezoneFindInputWhere!]

  """List of user address in this city."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this city."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this city."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of newsletter tracking log for this city."""
  fr_newsletter_tracking_log_infos: [NewsLetterTrackLogFindInputWhere!]
}

type CityDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type CityEntity {
  """Unique ID of the state, auto generated."""
  id: Int

  """State of the city."""
  state_id: Int

  """Timezone of the city."""
  tz_id: Int

  """Name of the city."""
  name: String

  """Latitude of the city."""
  latitude: Float

  """Longitude of the city."""
  longitude: Float

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """State info of the city."""
  fr_state: StateEntity

  """Timezone info of the city."""
  fr_timezone: TimezoneEntity

  """List of user address in this city."""
  fr_user_addresses: [UserAddressEntity!]

  """List of user identity cards for this city."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """List of user corporate infos for this city."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """List of newsletter tracking log for this city."""
  fr_newsletter_tracking_log_infos: [NewsLetterTrackLogEntity!]

  """List of business infos for this city."""
  fr_business: [BusinessEntity!]
}

input CityFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CityFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: CityFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: CityFindInputSortOrder
}

input CityFindInputGroupBy {
  state_id: Boolean
  tz_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input CityFindInputSortOrder {
  id: RecordSortDirectionEnum

  """State of the city."""
  state_id: RecordSortDirectionEnum

  """Timezone of the city."""
  tz_id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input CityFindInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """State of the city."""
  state_id: FindOperatorDto

  """Timezone of the city."""
  tz_id: FindOperatorDto

  """Name of the city."""
  name: FindOperatorDto

  """Latitude of the city."""
  latitude: FindOperatorDto

  """Longitude of the city."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """State info of the city."""
  fr_state: [StateFindInputWhere!]

  """Timezone info of the city."""
  fr_timezone: [TimezoneFindInputWhere!]

  """List of user address in this city."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this city."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this city."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of newsletter tracking log for this city."""
  fr_newsletter_tracking_log_infos: [NewsLetterTrackLogFindInputWhere!]
}

input CityFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type CityFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [CityEntity!]!
}

input CityRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CityRecoverInputWhere!]
}

input CityRecoverInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """State of the city."""
  state_id: FindOperatorDto

  """Timezone of the city."""
  tz_id: FindOperatorDto

  """Name of the city."""
  name: FindOperatorDto

  """Latitude of the city."""
  latitude: FindOperatorDto

  """Longitude of the city."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """State info of the city."""
  fr_state: [StateFindInputWhere!]

  """Timezone info of the city."""
  fr_timezone: [TimezoneFindInputWhere!]

  """List of user address in this city."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this city."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this city."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of newsletter tracking log for this city."""
  fr_newsletter_tracking_log_infos: [NewsLetterTrackLogFindInputWhere!]
}

type CityRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CityEntity!]!
}

input CityRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CityRemoveInputWhere!]
}

input CityRemoveInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """State of the city."""
  state_id: FindOperatorDto

  """Timezone of the city."""
  tz_id: FindOperatorDto

  """Name of the city."""
  name: FindOperatorDto

  """Latitude of the city."""
  latitude: FindOperatorDto

  """Longitude of the city."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """State info of the city."""
  fr_state: [StateFindInputWhere!]

  """Timezone info of the city."""
  fr_timezone: [TimezoneFindInputWhere!]

  """List of user address in this city."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this city."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this city."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of newsletter tracking log for this city."""
  fr_newsletter_tracking_log_infos: [NewsLetterTrackLogFindInputWhere!]
}

type CityRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CityEntity!]!
}

input CityRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CityRestoreInputWhere!]
}

input CityRestoreInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """State of the city."""
  state_id: FindOperatorDto

  """Timezone of the city."""
  tz_id: FindOperatorDto

  """Name of the city."""
  name: FindOperatorDto

  """Latitude of the city."""
  latitude: FindOperatorDto

  """Longitude of the city."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """State info of the city."""
  fr_state: [StateFindInputWhere!]

  """Timezone info of the city."""
  fr_timezone: [TimezoneFindInputWhere!]

  """List of user address in this city."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this city."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this city."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of newsletter tracking log for this city."""
  fr_newsletter_tracking_log_infos: [NewsLetterTrackLogFindInputWhere!]
}

type CityRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input CitySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CitySoftDeleteInputWhere!]
}

input CitySoftDeleteInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """State of the city."""
  state_id: FindOperatorDto

  """Timezone of the city."""
  tz_id: FindOperatorDto

  """Name of the city."""
  name: FindOperatorDto

  """Latitude of the city."""
  latitude: FindOperatorDto

  """Longitude of the city."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """State info of the city."""
  fr_state: [StateFindInputWhere!]

  """Timezone info of the city."""
  fr_timezone: [TimezoneFindInputWhere!]

  """List of user address in this city."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this city."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this city."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of newsletter tracking log for this city."""
  fr_newsletter_tracking_log_infos: [NewsLetterTrackLogFindInputWhere!]
}

type CitySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input CitySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CitySoftRemoveInputWhere!]
}

input CitySoftRemoveInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """State of the city."""
  state_id: FindOperatorDto

  """Timezone of the city."""
  tz_id: FindOperatorDto

  """Name of the city."""
  name: FindOperatorDto

  """Latitude of the city."""
  latitude: FindOperatorDto

  """Longitude of the city."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """State info of the city."""
  fr_state: [StateFindInputWhere!]

  """Timezone info of the city."""
  fr_timezone: [TimezoneFindInputWhere!]

  """List of user address in this city."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this city."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this city."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of newsletter tracking log for this city."""
  fr_newsletter_tracking_log_infos: [NewsLetterTrackLogFindInputWhere!]
}

type CitySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CityEntity!]!
}

input CityUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CityUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: CityUpdateInputSets!
}

input CityUpdateInputSets {
  """State of the city."""
  state_id: Int

  """Timezone of the city."""
  tz_id: Int

  """Name of the city."""
  name: String

  """Latitude of the city."""
  latitude: Float

  """Longitude of the city."""
  longitude: Float
}

input CityUpdateInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """State of the city."""
  state_id: FindOperatorDto

  """Timezone of the city."""
  tz_id: FindOperatorDto

  """Name of the city."""
  name: FindOperatorDto

  """Latitude of the city."""
  latitude: FindOperatorDto

  """Longitude of the city."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """State info of the city."""
  fr_state: [StateFindInputWhere!]

  """Timezone info of the city."""
  fr_timezone: [TimezoneFindInputWhere!]

  """List of user address in this city."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this city."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this city."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of newsletter tracking log for this city."""
  fr_newsletter_tracking_log_infos: [NewsLetterTrackLogFindInputWhere!]
}

type CityUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [CityEntity!]!
}

input CityUpsertInput {
  """State of the city."""
  state_id: Int!

  """Timezone of the city."""
  tz_id: Int!

  """Name of the city."""
  name: String!

  """Latitude of the city."""
  latitude: Float!

  """Longitude of the city."""
  longitude: Float!

  """Unique ID of the state, auto generated. undefined"""
  id: Int
}

type CityUpsertOutput {
  """Unique ID of the state, auto generated."""
  id: Int

  """State of the city."""
  state_id: Int

  """Timezone of the city."""
  tz_id: Int

  """Name of the city."""
  name: String

  """Latitude of the city."""
  latitude: Float

  """Longitude of the city."""
  longitude: Float

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """State info of the city."""
  fr_state: StateEntity

  """Timezone info of the city."""
  fr_timezone: TimezoneEntity

  """List of user address in this city."""
  fr_user_addresses: [UserAddressEntity!]

  """List of user identity cards for this city."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """List of user corporate infos for this city."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """List of newsletter tracking log for this city."""
  fr_newsletter_tracking_log_infos: [NewsLetterTrackLogEntity!]

  """List of business infos for this city."""
  fr_business: [BusinessEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input ConnectionSourceCategoriesCreateInput {
  """Title of the connection source categories."""
  title: String!

  """Description of the connection source categories."""
  desc: String

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: DateTime
}

type ConnectionSourceCategoriesCreateOutput {
  """Unique ID of the connection source categories, auto generated."""
  id: Int

  """Title of the connection source categories."""
  title: String

  """Description of the connection source categories."""
  desc: String

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Categories of the connection source."""
  fr_connection_sources_info: [ConnectionSourceEntity!]
}

input ConnectionSourceCategoriesDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceCategoriesDeleteInputWhere!]
}

input ConnectionSourceCategoriesDeleteInputWhere {
  """Unique ID of the connection source categories, auto generated."""
  id: FindOperatorDto

  """Title of the connection source categories."""
  title: FindOperatorDto

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the connection source."""
  fr_connection_sources_info: [ConnectionSourceFindInputWhere!]
}

type ConnectionSourceCategoriesDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type ConnectionSourceCategoriesEntity {
  """Unique ID of the connection source categories, auto generated."""
  id: Int

  """Title of the connection source categories."""
  title: String

  """Description of the connection source categories."""
  desc: String

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Categories of the connection source."""
  fr_connection_sources_info: [ConnectionSourceEntity!]
}

input ConnectionSourceCategoriesFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceCategoriesFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ConnectionSourceCategoriesFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ConnectionSourceCategoriesFindInputSortOrder
}

input ConnectionSourceCategoriesFindInputGroupBy {
  title: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ConnectionSourceCategoriesFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ConnectionSourceCategoriesFindInputWhere {
  """Unique ID of the connection source categories, auto generated."""
  id: FindOperatorDto

  """Title of the connection source categories."""
  title: FindOperatorDto

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the connection source."""
  fr_connection_sources_info: [ConnectionSourceFindInputWhere!]
}

input ConnectionSourceCategoriesFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type ConnectionSourceCategoriesFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ConnectionSourceCategoriesEntity!]!
}

input ConnectionSourceCategoriesRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceCategoriesRecoverInputWhere!]
}

input ConnectionSourceCategoriesRecoverInputWhere {
  """Unique ID of the connection source categories, auto generated."""
  id: FindOperatorDto

  """Title of the connection source categories."""
  title: FindOperatorDto

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the connection source."""
  fr_connection_sources_info: [ConnectionSourceFindInputWhere!]
}

type ConnectionSourceCategoriesRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ConnectionSourceCategoriesEntity!]!
}

input ConnectionSourceCategoriesRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceCategoriesRemoveInputWhere!]
}

input ConnectionSourceCategoriesRemoveInputWhere {
  """Unique ID of the connection source categories, auto generated."""
  id: FindOperatorDto

  """Title of the connection source categories."""
  title: FindOperatorDto

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the connection source."""
  fr_connection_sources_info: [ConnectionSourceFindInputWhere!]
}

type ConnectionSourceCategoriesRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ConnectionSourceCategoriesEntity!]!
}

input ConnectionSourceCategoriesRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceCategoriesRestoreInputWhere!]
}

input ConnectionSourceCategoriesRestoreInputWhere {
  """Unique ID of the connection source categories, auto generated."""
  id: FindOperatorDto

  """Title of the connection source categories."""
  title: FindOperatorDto

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the connection source."""
  fr_connection_sources_info: [ConnectionSourceFindInputWhere!]
}

type ConnectionSourceCategoriesRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ConnectionSourceCategoriesSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceCategoriesSoftDeleteInputWhere!]
}

input ConnectionSourceCategoriesSoftDeleteInputWhere {
  """Unique ID of the connection source categories, auto generated."""
  id: FindOperatorDto

  """Title of the connection source categories."""
  title: FindOperatorDto

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the connection source."""
  fr_connection_sources_info: [ConnectionSourceFindInputWhere!]
}

type ConnectionSourceCategoriesSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ConnectionSourceCategoriesSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceCategoriesSoftRemoveInputWhere!]
}

input ConnectionSourceCategoriesSoftRemoveInputWhere {
  """Unique ID of the connection source categories, auto generated."""
  id: FindOperatorDto

  """Title of the connection source categories."""
  title: FindOperatorDto

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the connection source."""
  fr_connection_sources_info: [ConnectionSourceFindInputWhere!]
}

type ConnectionSourceCategoriesSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ConnectionSourceCategoriesEntity!]!
}

input ConnectionSourceCategoriesUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceCategoriesUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ConnectionSourceCategoriesUpdateInputSets!
}

input ConnectionSourceCategoriesUpdateInputSets {
  """Title of the connection source categories."""
  title: String

  """Description of the connection source categories."""
  desc: String

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: DateTime
}

input ConnectionSourceCategoriesUpdateInputWhere {
  """Unique ID of the connection source categories, auto generated."""
  id: FindOperatorDto

  """Title of the connection source categories."""
  title: FindOperatorDto

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the connection source."""
  fr_connection_sources_info: [ConnectionSourceFindInputWhere!]
}

type ConnectionSourceCategoriesUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ConnectionSourceCategoriesEntity!]!
}

input ConnectionSourceCategoriesUpsertInput {
  """Title of the connection source categories."""
  title: String!

  """Description of the connection source categories."""
  desc: String

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: DateTime

  """
  Unique ID of the connection source categories, auto generated. undefined
  """
  id: Int
}

type ConnectionSourceCategoriesUpsertOutput {
  """Unique ID of the connection source categories, auto generated."""
  id: Int

  """Title of the connection source categories."""
  title: String

  """Description of the connection source categories."""
  desc: String

  """
  Indicates whether the connection source is currently active or inactive.
  """
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Categories of the connection source."""
  fr_connection_sources_info: [ConnectionSourceEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input ConnectionSourceCreateInput {
  """Connection source category of the connection source."""
  connsrccat_id: Int!

  """Title of the connection source."""
  title: String!

  """Description of the connection source."""
  desc: String
}

type ConnectionSourceCreateOutput {
  """Unique ID of the connection source, auto generated."""
  id: Int

  """Connection source category of the connection source."""
  connsrccat_id: Int

  """Title of the connection source."""
  title: String

  """Description of the connection source."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Connection source of the connection source category."""
  fr_connection_source_categories_info: ConnectionSourceCategoriesEntity

  """User of the connection source category."""
  fr_user: [UserEntity!]
}

input ConnectionSourceDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceDeleteInputWhere!]
}

input ConnectionSourceDeleteInputWhere {
  """Unique ID of the connection source, auto generated."""
  id: FindOperatorDto

  """Connection source category of the connection source."""
  connsrccat_id: FindOperatorDto

  """Title of the connection source."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Connection source of the connection source category."""
  fr_connection_source_categories_info: [ConnectionSourceCategoriesFindInputWhere!]

  """User of the connection source category."""
  fr_user: [UserFindInputWhere!]
}

type ConnectionSourceDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type ConnectionSourceEntity {
  """Unique ID of the connection source, auto generated."""
  id: Int

  """Connection source category of the connection source."""
  connsrccat_id: Int

  """Title of the connection source."""
  title: String

  """Description of the connection source."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Connection source of the connection source category."""
  fr_connection_source_categories_info: ConnectionSourceCategoriesEntity

  """User of the connection source category."""
  fr_user: [UserEntity!]
}

input ConnectionSourceFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ConnectionSourceFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ConnectionSourceFindInputSortOrder
}

input ConnectionSourceFindInputGroupBy {
  connsrccat_id: Boolean
  title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ConnectionSourceFindInputSortOrder {
  id: RecordSortDirectionEnum
  connsrccat_id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ConnectionSourceFindInputWhere {
  """Unique ID of the connection source, auto generated."""
  id: FindOperatorDto

  """Connection source category of the connection source."""
  connsrccat_id: FindOperatorDto

  """Title of the connection source."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Connection source of the connection source category."""
  fr_connection_source_categories_info: [ConnectionSourceCategoriesFindInputWhere!]

  """User of the connection source category."""
  fr_user: [UserFindInputWhere!]
}

input ConnectionSourceFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type ConnectionSourceFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ConnectionSourceEntity!]!
}

input ConnectionSourceRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceRecoverInputWhere!]
}

input ConnectionSourceRecoverInputWhere {
  """Unique ID of the connection source, auto generated."""
  id: FindOperatorDto

  """Connection source category of the connection source."""
  connsrccat_id: FindOperatorDto

  """Title of the connection source."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Connection source of the connection source category."""
  fr_connection_source_categories_info: [ConnectionSourceCategoriesFindInputWhere!]

  """User of the connection source category."""
  fr_user: [UserFindInputWhere!]
}

type ConnectionSourceRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ConnectionSourceEntity!]!
}

input ConnectionSourceRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceRemoveInputWhere!]
}

input ConnectionSourceRemoveInputWhere {
  """Unique ID of the connection source, auto generated."""
  id: FindOperatorDto

  """Connection source category of the connection source."""
  connsrccat_id: FindOperatorDto

  """Title of the connection source."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Connection source of the connection source category."""
  fr_connection_source_categories_info: [ConnectionSourceCategoriesFindInputWhere!]

  """User of the connection source category."""
  fr_user: [UserFindInputWhere!]
}

type ConnectionSourceRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ConnectionSourceEntity!]!
}

input ConnectionSourceRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceRestoreInputWhere!]
}

input ConnectionSourceRestoreInputWhere {
  """Unique ID of the connection source, auto generated."""
  id: FindOperatorDto

  """Connection source category of the connection source."""
  connsrccat_id: FindOperatorDto

  """Title of the connection source."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Connection source of the connection source category."""
  fr_connection_source_categories_info: [ConnectionSourceCategoriesFindInputWhere!]

  """User of the connection source category."""
  fr_user: [UserFindInputWhere!]
}

type ConnectionSourceRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ConnectionSourceSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceSoftDeleteInputWhere!]
}

input ConnectionSourceSoftDeleteInputWhere {
  """Unique ID of the connection source, auto generated."""
  id: FindOperatorDto

  """Connection source category of the connection source."""
  connsrccat_id: FindOperatorDto

  """Title of the connection source."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Connection source of the connection source category."""
  fr_connection_source_categories_info: [ConnectionSourceCategoriesFindInputWhere!]

  """User of the connection source category."""
  fr_user: [UserFindInputWhere!]
}

type ConnectionSourceSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ConnectionSourceSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceSoftRemoveInputWhere!]
}

input ConnectionSourceSoftRemoveInputWhere {
  """Unique ID of the connection source, auto generated."""
  id: FindOperatorDto

  """Connection source category of the connection source."""
  connsrccat_id: FindOperatorDto

  """Title of the connection source."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Connection source of the connection source category."""
  fr_connection_source_categories_info: [ConnectionSourceCategoriesFindInputWhere!]

  """User of the connection source category."""
  fr_user: [UserFindInputWhere!]
}

type ConnectionSourceSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ConnectionSourceEntity!]!
}

input ConnectionSourceUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ConnectionSourceUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ConnectionSourceUpdateInputSets!
}

input ConnectionSourceUpdateInputSets {
  """Connection source category of the connection source."""
  connsrccat_id: Int

  """Title of the connection source."""
  title: String

  """Description of the connection source."""
  desc: String
}

input ConnectionSourceUpdateInputWhere {
  """Unique ID of the connection source, auto generated."""
  id: FindOperatorDto

  """Connection source category of the connection source."""
  connsrccat_id: FindOperatorDto

  """Title of the connection source."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Connection source of the connection source category."""
  fr_connection_source_categories_info: [ConnectionSourceCategoriesFindInputWhere!]

  """User of the connection source category."""
  fr_user: [UserFindInputWhere!]
}

type ConnectionSourceUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ConnectionSourceEntity!]!
}

input ConnectionSourceUpsertInput {
  """Connection source category of the connection source."""
  connsrccat_id: Int!

  """Title of the connection source."""
  title: String!

  """Description of the connection source."""
  desc: String

  """Unique ID of the connection source, auto generated. undefined"""
  id: Int
}

type ConnectionSourceUpsertOutput {
  """Unique ID of the connection source, auto generated."""
  id: Int

  """Connection source category of the connection source."""
  connsrccat_id: Int

  """Title of the connection source."""
  title: String

  """Description of the connection source."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Connection source of the connection source category."""
  fr_connection_source_categories_info: ConnectionSourceCategoriesEntity

  """User of the connection source category."""
  fr_user: [UserEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input CountryCreateInput {
  """Region ID of the country."""
  region_id: Int

  """Subregion ID of the country."""
  subregion_id: Int

  """Name of the country."""
  name: String!

  """Numeric code of the country."""
  numeric_code: String

  """ISO III code of the country."""
  iso_iii: String

  """ISO II code of the country."""
  iso_ii: String

  """FIPS code of the country."""
  fips: String

  """Phone code of the country."""
  phone_code: String

  """Subdivision title of the country."""
  subdivision_title: String!

  """Capital of the country."""
  capital: String

  """Currency code of the country."""
  currency: String

  """Currency name of the country."""
  currency_name: String

  """Currency symbol of the country."""
  currency_symbol: String

  """TLD of the country."""
  tld: String

  """Native name of the country."""
  native: String

  """Nationality of the country."""
  nationality: String

  """List of timezones in the country."""
  timezones: String

  """Translations of the country name in different languages."""
  translations: String

  """Latitude of the country."""
  latitude: Float

  """Longitude of the country."""
  longitude: Float

  """Emoji of the country."""
  emoji: String

  """Emoji U of the country."""
  emoji_u: String
}

type CountryCreateOutput {
  """Unique ID of the country, auto generated."""
  id: Int

  """Region ID of the country."""
  region_id: Int

  """Subregion ID of the country."""
  subregion_id: Int

  """Name of the country."""
  name: String

  """Numeric code of the country."""
  numeric_code: String

  """ISO III code of the country."""
  iso_iii: String

  """ISO II code of the country."""
  iso_ii: String

  """FIPS code of the country."""
  fips: String

  """Phone code of the country."""
  phone_code: String

  """Subdivision title of the country."""
  subdivision_title: String

  """Capital of the country."""
  capital: String

  """Currency code of the country."""
  currency: String

  """Currency name of the country."""
  currency_name: String

  """Currency symbol of the country."""
  currency_symbol: String

  """TLD of the country."""
  tld: String

  """Native name of the country."""
  native: String

  """Nationality of the country."""
  nationality: String

  """List of timezones in the country."""
  timezones: String

  """Translations of the country name in different languages."""
  translations: String

  """Latitude of the country."""
  latitude: Float

  """Longitude of the country."""
  longitude: Float

  """Emoji of the country."""
  emoji: String

  """Emoji U of the country."""
  emoji_u: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of states for this country."""
  fr_states: [StateEntity!]

  """Region info of the country."""
  fr_region: RegionEntity

  """Region info of the country."""
  fr_subregion: SubregionEntity

  """List of user address for this country."""
  fr_user_addresses: [UserAddressEntity!]

  """List of user identity cards for this country."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """List of user corporate infos for this country."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """List of languages for this country"""
  fr_country_languagies: [CountryLanguageEntity!]

  """List of timezone for this country"""
  fr_country_timezone: [CountryTimezoneEntity!]

  """List of business for this country"""
  fr_business: [BusinessEntity!]
}

input CountryDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryDeleteInputWhere!]
}

input CountryDeleteInputWhere {
  """Unique ID of the country, auto generated."""
  id: FindOperatorDto

  """Region ID of the country."""
  region_id: FindOperatorDto

  """Subregion ID of the country."""
  subregion_id: FindOperatorDto

  """Name of the country."""
  name: FindOperatorDto

  """Numeric code of the country."""
  numeric_code: FindOperatorDto

  """ISO III code of the country."""
  iso_iii: FindOperatorDto

  """ISO II code of the country."""
  iso_ii: FindOperatorDto

  """Phone code of the country."""
  phone_code: FindOperatorDto

  """Capital of the country."""
  capital: FindOperatorDto

  """Latitude of the country."""
  latitude: FindOperatorDto

  """Longitude of the country."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of states for this country."""
  fr_states: [StateFindInputWhere!]

  """Region info of the country."""
  fr_region: [RegionFindInputWhere!]

  """List of subregions for this country."""
  fr_subregion: [SubregionFindInputWhere!]

  """List of user address for this country."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this country."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this country."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of languages for this country"""
  fr_country_languagies: [CountryLanguageFindInputWhere!]

  """List of timezone for this country"""
  fr_country_timezone: [CountryTimezoneFindInputWhere!]
}

type CountryDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type CountryEntity {
  """Unique ID of the country, auto generated."""
  id: Int

  """Region ID of the country."""
  region_id: Int

  """Subregion ID of the country."""
  subregion_id: Int

  """Name of the country."""
  name: String

  """Numeric code of the country."""
  numeric_code: String

  """ISO III code of the country."""
  iso_iii: String

  """ISO II code of the country."""
  iso_ii: String

  """FIPS code of the country."""
  fips: String

  """Phone code of the country."""
  phone_code: String

  """Subdivision title of the country."""
  subdivision_title: String

  """Capital of the country."""
  capital: String

  """Currency code of the country."""
  currency: String

  """Currency name of the country."""
  currency_name: String

  """Currency symbol of the country."""
  currency_symbol: String

  """TLD of the country."""
  tld: String

  """Native name of the country."""
  native: String

  """Nationality of the country."""
  nationality: String

  """List of timezones in the country."""
  timezones: String

  """Translations of the country name in different languages."""
  translations: String

  """Latitude of the country."""
  latitude: Float

  """Longitude of the country."""
  longitude: Float

  """Emoji of the country."""
  emoji: String

  """Emoji U of the country."""
  emoji_u: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of states for this country."""
  fr_states: [StateEntity!]

  """Region info of the country."""
  fr_region: RegionEntity

  """Region info of the country."""
  fr_subregion: SubregionEntity

  """List of user address for this country."""
  fr_user_addresses: [UserAddressEntity!]

  """List of user identity cards for this country."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """List of user corporate infos for this country."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """List of languages for this country"""
  fr_country_languagies: [CountryLanguageEntity!]

  """List of timezone for this country"""
  fr_country_timezone: [CountryTimezoneEntity!]

  """List of business for this country"""
  fr_business: [BusinessEntity!]
}

input CountryFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: CountryFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: CountryFindInputSortOrder
}

input CountryFindInputGroupBy {
  iso_iii: Boolean
  phone_code: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input CountryFindInputSortOrder {
  id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  iso_iii: RecordSortDirectionEnum
  phone_code: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input CountryFindInputWhere {
  """Unique ID of the country, auto generated."""
  id: FindOperatorDto

  """Region ID of the country."""
  region_id: FindOperatorDto

  """Subregion ID of the country."""
  subregion_id: FindOperatorDto

  """Name of the country."""
  name: FindOperatorDto

  """Numeric code of the country."""
  numeric_code: FindOperatorDto

  """ISO III code of the country."""
  iso_iii: FindOperatorDto

  """ISO II code of the country."""
  iso_ii: FindOperatorDto

  """Phone code of the country."""
  phone_code: FindOperatorDto

  """Capital of the country."""
  capital: FindOperatorDto

  """Latitude of the country."""
  latitude: FindOperatorDto

  """Longitude of the country."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of states for this country."""
  fr_states: [StateFindInputWhere!]

  """Region info of the country."""
  fr_region: [RegionFindInputWhere!]

  """List of subregions for this country."""
  fr_subregion: [SubregionFindInputWhere!]

  """List of user address for this country."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this country."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this country."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of languages for this country"""
  fr_country_languagies: [CountryLanguageFindInputWhere!]

  """List of timezone for this country"""
  fr_country_timezone: [CountryTimezoneFindInputWhere!]
}

input CountryFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type CountryFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [CountryEntity!]!
}

input CountryLanguageCreateInput {
  """Country of the language."""
  country_id: Int!

  """Language of the country."""
  lang_id: Int!
}

type CountryLanguageCreateOutput {
  """Unique ID of the country language, auto generated."""
  id: Int

  """Country of the language."""
  country_id: Int

  """Language of the country."""
  lang_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Country info for language."""
  fr_country: CountryEntity

  """Language info for country."""
  fr_language: LanguageEntity
}

input CountryLanguageDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryLanguageDeleteInputWhere!]
}

input CountryLanguageDeleteInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  lang_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_language: [LanguageFindInputWhere!]
}

type CountryLanguageDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type CountryLanguageEntity {
  """Unique ID of the country language, auto generated."""
  id: Int

  """Country of the language."""
  country_id: Int

  """Language of the country."""
  lang_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Country info for language."""
  fr_country: CountryEntity

  """Language info for country."""
  fr_language: LanguageEntity
}

input CountryLanguageFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryLanguageFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: CountryLanguageFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: CountryLanguageFindInputSortOrder
}

input CountryLanguageFindInputGroupBy {
  country_id: Boolean
  lang_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input CountryLanguageFindInputSortOrder {
  id: RecordSortDirectionEnum

  """Country of the language."""
  country_id: RecordSortDirectionEnum

  """Language of the country."""
  lang_id: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input CountryLanguageFindInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  lang_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_language: [LanguageFindInputWhere!]
}

input CountryLanguageFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type CountryLanguageFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [CountryLanguageEntity!]!
}

input CountryLanguageRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryLanguageRecoverInputWhere!]
}

input CountryLanguageRecoverInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  lang_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_language: [LanguageFindInputWhere!]
}

type CountryLanguageRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CountryLanguageEntity!]!
}

input CountryLanguageRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryLanguageRemoveInputWhere!]
}

input CountryLanguageRemoveInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  lang_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_language: [LanguageFindInputWhere!]
}

type CountryLanguageRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CountryLanguageEntity!]!
}

input CountryLanguageRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryLanguageRestoreInputWhere!]
}

input CountryLanguageRestoreInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  lang_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_language: [LanguageFindInputWhere!]
}

type CountryLanguageRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input CountryLanguageSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryLanguageSoftDeleteInputWhere!]
}

input CountryLanguageSoftDeleteInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  lang_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_language: [LanguageFindInputWhere!]
}

type CountryLanguageSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input CountryLanguageSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryLanguageSoftRemoveInputWhere!]
}

input CountryLanguageSoftRemoveInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  lang_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_language: [LanguageFindInputWhere!]
}

type CountryLanguageSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CountryLanguageEntity!]!
}

input CountryLanguageUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryLanguageUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: CountryLanguageUpdateInputSets!
}

input CountryLanguageUpdateInputSets {
  """Country of the language."""
  country_id: Int

  """Language of the country."""
  lang_id: Int
}

input CountryLanguageUpdateInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  lang_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_language: [LanguageFindInputWhere!]
}

type CountryLanguageUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [CountryLanguageEntity!]!
}

input CountryLanguageUpsertInput {
  """Country of the language."""
  country_id: Int!

  """Language of the country."""
  lang_id: Int!

  """Unique ID of the country language, auto generated. undefined"""
  id: Int
}

type CountryLanguageUpsertOutput {
  """Unique ID of the country language, auto generated."""
  id: Int

  """Country of the language."""
  country_id: Int

  """Language of the country."""
  lang_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Country info for language."""
  fr_country: CountryEntity

  """Language info for country."""
  fr_language: LanguageEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input CountryRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryRecoverInputWhere!]
}

input CountryRecoverInputWhere {
  """Unique ID of the country, auto generated."""
  id: FindOperatorDto

  """Region ID of the country."""
  region_id: FindOperatorDto

  """Subregion ID of the country."""
  subregion_id: FindOperatorDto

  """Name of the country."""
  name: FindOperatorDto

  """Numeric code of the country."""
  numeric_code: FindOperatorDto

  """ISO III code of the country."""
  iso_iii: FindOperatorDto

  """ISO II code of the country."""
  iso_ii: FindOperatorDto

  """Phone code of the country."""
  phone_code: FindOperatorDto

  """Capital of the country."""
  capital: FindOperatorDto

  """Latitude of the country."""
  latitude: FindOperatorDto

  """Longitude of the country."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of states for this country."""
  fr_states: [StateFindInputWhere!]

  """Region info of the country."""
  fr_region: [RegionFindInputWhere!]

  """List of subregions for this country."""
  fr_subregion: [SubregionFindInputWhere!]

  """List of user address for this country."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this country."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this country."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of languages for this country"""
  fr_country_languagies: [CountryLanguageFindInputWhere!]

  """List of timezone for this country"""
  fr_country_timezone: [CountryTimezoneFindInputWhere!]
}

type CountryRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CountryEntity!]!
}

input CountryRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryRemoveInputWhere!]
}

input CountryRemoveInputWhere {
  """Unique ID of the country, auto generated."""
  id: FindOperatorDto

  """Region ID of the country."""
  region_id: FindOperatorDto

  """Subregion ID of the country."""
  subregion_id: FindOperatorDto

  """Name of the country."""
  name: FindOperatorDto

  """Numeric code of the country."""
  numeric_code: FindOperatorDto

  """ISO III code of the country."""
  iso_iii: FindOperatorDto

  """ISO II code of the country."""
  iso_ii: FindOperatorDto

  """Phone code of the country."""
  phone_code: FindOperatorDto

  """Capital of the country."""
  capital: FindOperatorDto

  """Latitude of the country."""
  latitude: FindOperatorDto

  """Longitude of the country."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of states for this country."""
  fr_states: [StateFindInputWhere!]

  """Region info of the country."""
  fr_region: [RegionFindInputWhere!]

  """List of subregions for this country."""
  fr_subregion: [SubregionFindInputWhere!]

  """List of user address for this country."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this country."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this country."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of languages for this country"""
  fr_country_languagies: [CountryLanguageFindInputWhere!]

  """List of timezone for this country"""
  fr_country_timezone: [CountryTimezoneFindInputWhere!]
}

type CountryRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CountryEntity!]!
}

input CountryRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryRestoreInputWhere!]
}

input CountryRestoreInputWhere {
  """Unique ID of the country, auto generated."""
  id: FindOperatorDto

  """Region ID of the country."""
  region_id: FindOperatorDto

  """Subregion ID of the country."""
  subregion_id: FindOperatorDto

  """Name of the country."""
  name: FindOperatorDto

  """Numeric code of the country."""
  numeric_code: FindOperatorDto

  """ISO III code of the country."""
  iso_iii: FindOperatorDto

  """ISO II code of the country."""
  iso_ii: FindOperatorDto

  """Phone code of the country."""
  phone_code: FindOperatorDto

  """Capital of the country."""
  capital: FindOperatorDto

  """Latitude of the country."""
  latitude: FindOperatorDto

  """Longitude of the country."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of states for this country."""
  fr_states: [StateFindInputWhere!]

  """Region info of the country."""
  fr_region: [RegionFindInputWhere!]

  """List of subregions for this country."""
  fr_subregion: [SubregionFindInputWhere!]

  """List of user address for this country."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this country."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this country."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of languages for this country"""
  fr_country_languagies: [CountryLanguageFindInputWhere!]

  """List of timezone for this country"""
  fr_country_timezone: [CountryTimezoneFindInputWhere!]
}

type CountryRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input CountrySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountrySoftDeleteInputWhere!]
}

input CountrySoftDeleteInputWhere {
  """Unique ID of the country, auto generated."""
  id: FindOperatorDto

  """Region ID of the country."""
  region_id: FindOperatorDto

  """Subregion ID of the country."""
  subregion_id: FindOperatorDto

  """Name of the country."""
  name: FindOperatorDto

  """Numeric code of the country."""
  numeric_code: FindOperatorDto

  """ISO III code of the country."""
  iso_iii: FindOperatorDto

  """ISO II code of the country."""
  iso_ii: FindOperatorDto

  """Phone code of the country."""
  phone_code: FindOperatorDto

  """Capital of the country."""
  capital: FindOperatorDto

  """Latitude of the country."""
  latitude: FindOperatorDto

  """Longitude of the country."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of states for this country."""
  fr_states: [StateFindInputWhere!]

  """Region info of the country."""
  fr_region: [RegionFindInputWhere!]

  """List of subregions for this country."""
  fr_subregion: [SubregionFindInputWhere!]

  """List of user address for this country."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this country."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this country."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of languages for this country"""
  fr_country_languagies: [CountryLanguageFindInputWhere!]

  """List of timezone for this country"""
  fr_country_timezone: [CountryTimezoneFindInputWhere!]
}

type CountrySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input CountrySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountrySoftRemoveInputWhere!]
}

input CountrySoftRemoveInputWhere {
  """Unique ID of the country, auto generated."""
  id: FindOperatorDto

  """Region ID of the country."""
  region_id: FindOperatorDto

  """Subregion ID of the country."""
  subregion_id: FindOperatorDto

  """Name of the country."""
  name: FindOperatorDto

  """Numeric code of the country."""
  numeric_code: FindOperatorDto

  """ISO III code of the country."""
  iso_iii: FindOperatorDto

  """ISO II code of the country."""
  iso_ii: FindOperatorDto

  """Phone code of the country."""
  phone_code: FindOperatorDto

  """Capital of the country."""
  capital: FindOperatorDto

  """Latitude of the country."""
  latitude: FindOperatorDto

  """Longitude of the country."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of states for this country."""
  fr_states: [StateFindInputWhere!]

  """Region info of the country."""
  fr_region: [RegionFindInputWhere!]

  """List of subregions for this country."""
  fr_subregion: [SubregionFindInputWhere!]

  """List of user address for this country."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this country."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this country."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of languages for this country"""
  fr_country_languagies: [CountryLanguageFindInputWhere!]

  """List of timezone for this country"""
  fr_country_timezone: [CountryTimezoneFindInputWhere!]
}

type CountrySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CountryEntity!]!
}

input CountryTimezoneCreateInput {
  """Country of the language."""
  country_id: Int!

  """Language of the country."""
  tz_id: Int!
}

type CountryTimezoneCreateOutput {
  """Unique ID of the country language, auto generated."""
  id: Int

  """Country of the language."""
  country_id: Int

  """Language of the country."""
  tz_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Country info for language."""
  fr_country: CountryEntity

  """Language info for country."""
  fr_timezone: TimezoneEntity
}

input CountryTimezoneDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryTimezoneDeleteInputWhere!]
}

input CountryTimezoneDeleteInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  tz_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_timezone: [TimezoneFindInputWhere!]
}

type CountryTimezoneDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type CountryTimezoneEntity {
  """Unique ID of the country language, auto generated."""
  id: Int

  """Country of the language."""
  country_id: Int

  """Language of the country."""
  tz_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Country info for language."""
  fr_country: CountryEntity

  """Language info for country."""
  fr_timezone: TimezoneEntity
}

input CountryTimezoneFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryTimezoneFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: CountryTimezoneFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: CountryTimezoneFindInputSortOrder
}

input CountryTimezoneFindInputGroupBy {
  country_id: Boolean
  tz_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input CountryTimezoneFindInputSortOrder {
  id: RecordSortDirectionEnum

  """Country of the language."""
  country_id: RecordSortDirectionEnum

  """Language of the country."""
  tz_id: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input CountryTimezoneFindInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  tz_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_timezone: [TimezoneFindInputWhere!]
}

input CountryTimezoneFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type CountryTimezoneFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [CountryTimezoneEntity!]!
}

input CountryTimezoneRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryTimezoneRecoverInputWhere!]
}

input CountryTimezoneRecoverInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  tz_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_timezone: [TimezoneFindInputWhere!]
}

type CountryTimezoneRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CountryTimezoneEntity!]!
}

input CountryTimezoneRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryTimezoneRemoveInputWhere!]
}

input CountryTimezoneRemoveInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  tz_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_timezone: [TimezoneFindInputWhere!]
}

type CountryTimezoneRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CountryTimezoneEntity!]!
}

input CountryTimezoneRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryTimezoneRestoreInputWhere!]
}

input CountryTimezoneRestoreInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  tz_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_timezone: [TimezoneFindInputWhere!]
}

type CountryTimezoneRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input CountryTimezoneSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryTimezoneSoftDeleteInputWhere!]
}

input CountryTimezoneSoftDeleteInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  tz_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_timezone: [TimezoneFindInputWhere!]
}

type CountryTimezoneSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input CountryTimezoneSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryTimezoneSoftRemoveInputWhere!]
}

input CountryTimezoneSoftRemoveInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  tz_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_timezone: [TimezoneFindInputWhere!]
}

type CountryTimezoneSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CountryTimezoneEntity!]!
}

input CountryTimezoneUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryTimezoneUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: CountryTimezoneUpdateInputSets!
}

input CountryTimezoneUpdateInputSets {
  """Country of the language."""
  country_id: Int

  """Language of the country."""
  tz_id: Int
}

input CountryTimezoneUpdateInputWhere {
  """Unique ID of the country language, auto generated."""
  id: FindOperatorDto

  """Country of the language."""
  country_id: FindOperatorDto

  """Language of the country."""
  tz_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info for language."""
  fr_country: [CountryFindInputWhere!]

  """Language info for country."""
  fr_timezone: [TimezoneFindInputWhere!]
}

type CountryTimezoneUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [CountryTimezoneEntity!]!
}

input CountryTimezoneUpsertInput {
  """Country of the language."""
  country_id: Int!

  """Language of the country."""
  tz_id: Int!

  """Unique ID of the country language, auto generated. undefined"""
  id: Int
}

type CountryTimezoneUpsertOutput {
  """Unique ID of the country language, auto generated."""
  id: Int

  """Country of the language."""
  country_id: Int

  """Language of the country."""
  tz_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Country info for language."""
  fr_country: CountryEntity

  """Language info for country."""
  fr_timezone: TimezoneEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input CountryUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CountryUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: CountryUpdateInputSets!
}

input CountryUpdateInputSets {
  """Region ID of the country."""
  region_id: Int

  """Subregion ID of the country."""
  subregion_id: Int

  """Name of the country."""
  name: String

  """Numeric code of the country."""
  numeric_code: String

  """ISO III code of the country."""
  iso_iii: String

  """ISO II code of the country."""
  iso_ii: String

  """FIPS code of the country."""
  fips: String

  """Phone code of the country."""
  phone_code: String

  """Subdivision title of the country."""
  subdivision_title: String

  """Capital of the country."""
  capital: String

  """Currency code of the country."""
  currency: String

  """Currency name of the country."""
  currency_name: String

  """Currency symbol of the country."""
  currency_symbol: String

  """TLD of the country."""
  tld: String

  """Native name of the country."""
  native: String

  """Nationality of the country."""
  nationality: String

  """List of timezones in the country."""
  timezones: String

  """Translations of the country name in different languages."""
  translations: String

  """Latitude of the country."""
  latitude: Float

  """Longitude of the country."""
  longitude: Float

  """Emoji of the country."""
  emoji: String

  """Emoji U of the country."""
  emoji_u: String
}

input CountryUpdateInputWhere {
  """Unique ID of the country, auto generated."""
  id: FindOperatorDto

  """Region ID of the country."""
  region_id: FindOperatorDto

  """Subregion ID of the country."""
  subregion_id: FindOperatorDto

  """Name of the country."""
  name: FindOperatorDto

  """Numeric code of the country."""
  numeric_code: FindOperatorDto

  """ISO III code of the country."""
  iso_iii: FindOperatorDto

  """ISO II code of the country."""
  iso_ii: FindOperatorDto

  """Phone code of the country."""
  phone_code: FindOperatorDto

  """Capital of the country."""
  capital: FindOperatorDto

  """Latitude of the country."""
  latitude: FindOperatorDto

  """Longitude of the country."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of states for this country."""
  fr_states: [StateFindInputWhere!]

  """Region info of the country."""
  fr_region: [RegionFindInputWhere!]

  """List of subregions for this country."""
  fr_subregion: [SubregionFindInputWhere!]

  """List of user address for this country."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this country."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this country."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """List of languages for this country"""
  fr_country_languagies: [CountryLanguageFindInputWhere!]

  """List of timezone for this country"""
  fr_country_timezone: [CountryTimezoneFindInputWhere!]
}

type CountryUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [CountryEntity!]!
}

input CountryUpsertInput {
  """Region ID of the country."""
  region_id: Int

  """Subregion ID of the country."""
  subregion_id: Int

  """Name of the country."""
  name: String!

  """Numeric code of the country."""
  numeric_code: String

  """ISO III code of the country."""
  iso_iii: String

  """ISO II code of the country."""
  iso_ii: String

  """FIPS code of the country."""
  fips: String

  """Phone code of the country."""
  phone_code: String

  """Subdivision title of the country."""
  subdivision_title: String!

  """Capital of the country."""
  capital: String

  """Currency code of the country."""
  currency: String

  """Currency name of the country."""
  currency_name: String

  """Currency symbol of the country."""
  currency_symbol: String

  """TLD of the country."""
  tld: String

  """Native name of the country."""
  native: String

  """Nationality of the country."""
  nationality: String

  """List of timezones in the country."""
  timezones: String

  """Translations of the country name in different languages."""
  translations: String

  """Latitude of the country."""
  latitude: Float

  """Longitude of the country."""
  longitude: Float

  """Emoji of the country."""
  emoji: String

  """Emoji U of the country."""
  emoji_u: String

  """Unique ID of the country, auto generated. undefined"""
  id: Int
}

type CountryUpsertOutput {
  """Unique ID of the country, auto generated."""
  id: Int

  """Region ID of the country."""
  region_id: Int

  """Subregion ID of the country."""
  subregion_id: Int

  """Name of the country."""
  name: String

  """Numeric code of the country."""
  numeric_code: String

  """ISO III code of the country."""
  iso_iii: String

  """ISO II code of the country."""
  iso_ii: String

  """FIPS code of the country."""
  fips: String

  """Phone code of the country."""
  phone_code: String

  """Subdivision title of the country."""
  subdivision_title: String

  """Capital of the country."""
  capital: String

  """Currency code of the country."""
  currency: String

  """Currency name of the country."""
  currency_name: String

  """Currency symbol of the country."""
  currency_symbol: String

  """TLD of the country."""
  tld: String

  """Native name of the country."""
  native: String

  """Nationality of the country."""
  nationality: String

  """List of timezones in the country."""
  timezones: String

  """Translations of the country name in different languages."""
  translations: String

  """Latitude of the country."""
  latitude: Float

  """Longitude of the country."""
  longitude: Float

  """Emoji of the country."""
  emoji: String

  """Emoji U of the country."""
  emoji_u: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of states for this country."""
  fr_states: [StateEntity!]

  """Region info of the country."""
  fr_region: RegionEntity

  """Region info of the country."""
  fr_subregion: SubregionEntity

  """List of user address for this country."""
  fr_user_addresses: [UserAddressEntity!]

  """List of user identity cards for this country."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """List of user corporate infos for this country."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """List of languages for this country"""
  fr_country_languagies: [CountryLanguageEntity!]

  """List of timezone for this country"""
  fr_country_timezone: [CountryTimezoneEntity!]

  """List of business for this country"""
  fr_business: [BusinessEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input CrawlerLeadCreateInput {
  """User ID related to the lead."""
  u_id: Int

  """Business ID related to the lead."""
  busns_id: Int

  """User's first name."""
  u_fname: String

  """User's last name."""
  u_lname: String

  """User's middle name."""
  u_mname: String

  """Connection source ID."""
  u_connsrc_id: String

  """User's primary email."""
  u_primary_email: String

  """User's primary mobile number."""
  u_primary_mobile: String

  """User's primary mobile country code."""
  u_primary_mobile_cc: String

  """User's WhatsApp number."""
  u_whatsapp: String

  """User's WhatsApp country code."""
  u_whatsapp_cc: String

  """Primary email verification status."""
  u_pemail_verified: Int

  """Primary mobile verification status."""
  u_pmobile_verified: Int

  """Overall verification status."""
  u_verified: Int

  """User suspension status."""
  u_suspended: Int

  """User gender info."""
  upinfo_gender: String

  """User website URL."""
  upinfo_website_url: String

  """User Facebook profile URL."""
  upinfo_facebook_profile: String

  """User Instagram profile URL."""
  upinfo_instagram_profile: String

  """User LinkedIn profile URL."""
  upinfo_linkedin_profile: String

  """User YouTube profile URL."""
  upinfo_youtube_profile: String

  """User X (Twitter) profile URL."""
  upinfo_x_profile: String

  """User TikTok profile URL."""
  upinfo_tiktok_profile: String

  """User Pinterest profile URL."""
  upinfo_pinterest_profile: String

  """Address title."""
  uaddr_title: String

  """User address."""
  uaddr_address: String

  """User country."""
  uaddr_country: String

  """User state."""
  uaddr_state: String

  """User city."""
  uaddr_city: String

  """Postal or ZIP code."""
  uaddr_postal_zip_code: String

  """User's company name."""
  ucorp_company_name: String

  """User company email."""
  ucorp_email: String

  """User company mobile number."""
  ucorp_mobile: String

  """User company mobile country code."""
  ucorp_mobile_cc: String

  """User company website."""
  ucorp_website: String

  """Business pricing category ID."""
  busns_buspricat_id: String

  """Business sector category ID 1."""
  busns_busseccat_id_1: String

  """Business sector category ID 2."""
  busns_busseccat_id_2: String

  """Business sector category ID 3."""
  busns_busseccat_id_3: String

  """Business sector category ID 4."""
  busns_busseccat_id_4: String

  """Business sector category ID 5."""
  busns_busseccat_id_5: String

  """Business sector category ID 6."""
  busns_busseccat_id_6: String

  """Business sector category ID 7."""
  busns_busseccat_id_7: String

  """Business sector category ID 8."""
  busns_busseccat_id_8: String

  """Business sector category ID 9."""
  busns_busseccat_id_9: String

  """Business name."""
  busns_name: String

  """Business address."""
  busns_address: String

  """Business country."""
  busns_country: String

  """Business state."""
  busns_state: String

  """Business city."""
  busns_city: String

  """Business ZIP code."""
  busns_zipcode: String

  """Business toll-free number."""
  busns_toll_free_number: String

  """Business mobile number."""
  busns_mobile: String

  """Business mobile country code."""
  busns_mobile_cc: String

  """Business WhatsApp number."""
  busns_whatsapp: String

  """Business WhatsApp country code."""
  busns_whatsapp_cc: String

  """Business email address."""
  busns_email: String

  """Google My Business URL."""
  busns_google_my_business_url: String

  """Google Map URL."""
  busns_google_map_url: String

  """Google Review URL."""
  busns_google_review_url: String

  """Business location latitude."""
  busns_location_latitude: String

  """Business location longitude."""
  busns_location_longitude: String

  """Business website URL."""
  busns_website_url: String

  """Business LinkedIn profile."""
  busns_linkedin_profile: String

  """Business Facebook profile."""
  busns_facebook_profile: String

  """Business Instagram profile."""
  busns_instagram_profile: String

  """Business YouTube profile."""
  busns_youtube_profile: String

  """Business X profile."""
  busns_x_profile: String

  """Business TikTok profile."""
  busns_tiktok_profile: String

  """Business Pinterest profile."""
  busns_pinterest_profile: String

  """Business registration datetime."""
  busns_registered: DateTime

  """Initial business findings."""
  busns_initial_findings: String

  """Business competitor findings."""
  busns_competitor_findings: String

  """Reference type for the lead."""
  lead_ref_type: String

  """Reference ID for the lead."""
  lead_ref_id: Int

  """Preferred contact method."""
  lead_preferred_contact_method: String

  """Concern or issue of the lead."""
  lead_concern_issue: String

  """Subject of the lead."""
  lead_subject: String

  """Comment on the lead."""
  lead_comment: String

  """Initial findings of the lead."""
  lead_initial_findings: String

  """First incoming message date."""
  lead_first_incoming_message_dt: DateTime

  """Lead creation datetime."""
  lead_created: DateTime

  """Lead update datetime."""
  lead_updated: DateTime

  """Crawler update datetime."""
  crawler_updated: DateTime

  """Stage of the crawler lead."""
  crawler_stage: String!
}

type CrawlerLeadCreateOutput {
  """Unique ID of the lead, auto generated."""
  lead_id: Int

  """User ID related to the lead."""
  u_id: Int

  """Business ID related to the lead."""
  busns_id: Int

  """User's first name."""
  u_fname: String

  """User's last name."""
  u_lname: String

  """User's middle name."""
  u_mname: String

  """Connection source ID."""
  u_connsrc_id: String

  """User's primary email."""
  u_primary_email: String

  """User's primary mobile number."""
  u_primary_mobile: String

  """User's primary mobile country code."""
  u_primary_mobile_cc: String

  """User's WhatsApp number."""
  u_whatsapp: String

  """User's WhatsApp country code."""
  u_whatsapp_cc: String

  """Primary email verification status."""
  u_pemail_verified: Int

  """Primary mobile verification status."""
  u_pmobile_verified: Int

  """Overall verification status."""
  u_verified: Int

  """User suspension status."""
  u_suspended: Int

  """User gender info."""
  upinfo_gender: String

  """User website URL."""
  upinfo_website_url: String

  """User Facebook profile URL."""
  upinfo_facebook_profile: String

  """User Instagram profile URL."""
  upinfo_instagram_profile: String

  """User LinkedIn profile URL."""
  upinfo_linkedin_profile: String

  """User YouTube profile URL."""
  upinfo_youtube_profile: String

  """User X (Twitter) profile URL."""
  upinfo_x_profile: String

  """User TikTok profile URL."""
  upinfo_tiktok_profile: String

  """User Pinterest profile URL."""
  upinfo_pinterest_profile: String

  """Address title."""
  uaddr_title: String

  """User address."""
  uaddr_address: String

  """User country."""
  uaddr_country: String

  """User state."""
  uaddr_state: String

  """User city."""
  uaddr_city: String

  """Postal or ZIP code."""
  uaddr_postal_zip_code: String

  """User's company name."""
  ucorp_company_name: String

  """User company email."""
  ucorp_email: String

  """User company mobile number."""
  ucorp_mobile: String

  """User company mobile country code."""
  ucorp_mobile_cc: String

  """User company website."""
  ucorp_website: String

  """Business pricing category ID."""
  busns_buspricat_id: String

  """Business sector category ID 1."""
  busns_busseccat_id_1: String

  """Business sector category ID 2."""
  busns_busseccat_id_2: String

  """Business sector category ID 3."""
  busns_busseccat_id_3: String

  """Business sector category ID 4."""
  busns_busseccat_id_4: String

  """Business sector category ID 5."""
  busns_busseccat_id_5: String

  """Business sector category ID 6."""
  busns_busseccat_id_6: String

  """Business sector category ID 7."""
  busns_busseccat_id_7: String

  """Business sector category ID 8."""
  busns_busseccat_id_8: String

  """Business sector category ID 9."""
  busns_busseccat_id_9: String

  """Business name."""
  busns_name: String

  """Business address."""
  busns_address: String

  """Business country."""
  busns_country: String

  """Business state."""
  busns_state: String

  """Business city."""
  busns_city: String

  """Business ZIP code."""
  busns_zipcode: String

  """Business toll-free number."""
  busns_toll_free_number: String

  """Business mobile number."""
  busns_mobile: String

  """Business mobile country code."""
  busns_mobile_cc: String

  """Business WhatsApp number."""
  busns_whatsapp: String

  """Business WhatsApp country code."""
  busns_whatsapp_cc: String

  """Business email address."""
  busns_email: String

  """Google My Business URL."""
  busns_google_my_business_url: String

  """Google Map URL."""
  busns_google_map_url: String

  """Google Review URL."""
  busns_google_review_url: String

  """Business location latitude."""
  busns_location_latitude: String

  """Business location longitude."""
  busns_location_longitude: String

  """Business website URL."""
  busns_website_url: String

  """Business LinkedIn profile."""
  busns_linkedin_profile: String

  """Business Facebook profile."""
  busns_facebook_profile: String

  """Business Instagram profile."""
  busns_instagram_profile: String

  """Business YouTube profile."""
  busns_youtube_profile: String

  """Business X profile."""
  busns_x_profile: String

  """Business TikTok profile."""
  busns_tiktok_profile: String

  """Business Pinterest profile."""
  busns_pinterest_profile: String

  """Business registration datetime."""
  busns_registered: DateTime

  """Initial business findings."""
  busns_initial_findings: String

  """Business competitor findings."""
  busns_competitor_findings: String

  """Reference type for the lead."""
  lead_ref_type: String

  """Reference ID for the lead."""
  lead_ref_id: Int

  """Preferred contact method."""
  lead_preferred_contact_method: String

  """Concern or issue of the lead."""
  lead_concern_issue: String

  """Subject of the lead."""
  lead_subject: String

  """Comment on the lead."""
  lead_comment: String

  """Initial findings of the lead."""
  lead_initial_findings: String
  lead_first_incoming_message_dt: DateTime

  """Lead creation datetime."""
  lead_created: DateTime

  """Lead update datetime."""
  lead_updated: DateTime

  """Crawler update datetime."""
  crawler_updated: DateTime

  """Stage of the crawler lead."""
  crawler_stage: String!
}

input CrawlerLeadDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CrawlerLeadDeleteInputWhere!]
}

input CrawlerLeadDeleteInputWhere {
  """Unique ID of the lead, auto generated."""
  lead_id: FindOperatorDto

  """Stage of the crawler lead."""
  crawler_stage: FindOperatorDto
}

type CrawlerLeadDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type CrawlerLeadEntity {
  """Unique ID of the lead, auto generated."""
  lead_id: Int

  """User ID related to the lead."""
  u_id: Int

  """Business ID related to the lead."""
  busns_id: Int

  """User's first name."""
  u_fname: String

  """User's last name."""
  u_lname: String

  """User's middle name."""
  u_mname: String

  """Connection source ID."""
  u_connsrc_id: String

  """User's primary email."""
  u_primary_email: String

  """User's primary mobile number."""
  u_primary_mobile: String

  """User's primary mobile country code."""
  u_primary_mobile_cc: String

  """User's WhatsApp number."""
  u_whatsapp: String

  """User's WhatsApp country code."""
  u_whatsapp_cc: String

  """Primary email verification status."""
  u_pemail_verified: Int

  """Primary mobile verification status."""
  u_pmobile_verified: Int

  """Overall verification status."""
  u_verified: Int

  """User suspension status."""
  u_suspended: Int

  """User gender info."""
  upinfo_gender: String

  """User website URL."""
  upinfo_website_url: String

  """User Facebook profile URL."""
  upinfo_facebook_profile: String

  """User Instagram profile URL."""
  upinfo_instagram_profile: String

  """User LinkedIn profile URL."""
  upinfo_linkedin_profile: String

  """User YouTube profile URL."""
  upinfo_youtube_profile: String

  """User X (Twitter) profile URL."""
  upinfo_x_profile: String

  """User TikTok profile URL."""
  upinfo_tiktok_profile: String

  """User Pinterest profile URL."""
  upinfo_pinterest_profile: String

  """Address title."""
  uaddr_title: String

  """User address."""
  uaddr_address: String

  """User country."""
  uaddr_country: String

  """User state."""
  uaddr_state: String

  """User city."""
  uaddr_city: String

  """Postal or ZIP code."""
  uaddr_postal_zip_code: String

  """User's company name."""
  ucorp_company_name: String

  """User company email."""
  ucorp_email: String

  """User company mobile number."""
  ucorp_mobile: String

  """User company mobile country code."""
  ucorp_mobile_cc: String

  """User company website."""
  ucorp_website: String

  """Business pricing category ID."""
  busns_buspricat_id: String

  """Business sector category ID 1."""
  busns_busseccat_id_1: String

  """Business sector category ID 2."""
  busns_busseccat_id_2: String

  """Business sector category ID 3."""
  busns_busseccat_id_3: String

  """Business sector category ID 4."""
  busns_busseccat_id_4: String

  """Business sector category ID 5."""
  busns_busseccat_id_5: String

  """Business sector category ID 6."""
  busns_busseccat_id_6: String

  """Business sector category ID 7."""
  busns_busseccat_id_7: String

  """Business sector category ID 8."""
  busns_busseccat_id_8: String

  """Business sector category ID 9."""
  busns_busseccat_id_9: String

  """Business name."""
  busns_name: String

  """Business address."""
  busns_address: String

  """Business country."""
  busns_country: String

  """Business state."""
  busns_state: String

  """Business city."""
  busns_city: String

  """Business ZIP code."""
  busns_zipcode: String

  """Business toll-free number."""
  busns_toll_free_number: String

  """Business mobile number."""
  busns_mobile: String

  """Business mobile country code."""
  busns_mobile_cc: String

  """Business WhatsApp number."""
  busns_whatsapp: String

  """Business WhatsApp country code."""
  busns_whatsapp_cc: String

  """Business email address."""
  busns_email: String

  """Google My Business URL."""
  busns_google_my_business_url: String

  """Google Map URL."""
  busns_google_map_url: String

  """Google Review URL."""
  busns_google_review_url: String

  """Business location latitude."""
  busns_location_latitude: String

  """Business location longitude."""
  busns_location_longitude: String

  """Business website URL."""
  busns_website_url: String

  """Business LinkedIn profile."""
  busns_linkedin_profile: String

  """Business Facebook profile."""
  busns_facebook_profile: String

  """Business Instagram profile."""
  busns_instagram_profile: String

  """Business YouTube profile."""
  busns_youtube_profile: String

  """Business X profile."""
  busns_x_profile: String

  """Business TikTok profile."""
  busns_tiktok_profile: String

  """Business Pinterest profile."""
  busns_pinterest_profile: String

  """Business registration datetime."""
  busns_registered: DateTime

  """Initial business findings."""
  busns_initial_findings: String

  """Business competitor findings."""
  busns_competitor_findings: String

  """Reference type for the lead."""
  lead_ref_type: String

  """Reference ID for the lead."""
  lead_ref_id: Int

  """Preferred contact method."""
  lead_preferred_contact_method: String

  """Concern or issue of the lead."""
  lead_concern_issue: String

  """Subject of the lead."""
  lead_subject: String

  """Comment on the lead."""
  lead_comment: String

  """Initial findings of the lead."""
  lead_initial_findings: String
  lead_first_incoming_message_dt: DateTime

  """Lead creation datetime."""
  lead_created: DateTime

  """Lead update datetime."""
  lead_updated: DateTime

  """Crawler update datetime."""
  crawler_updated: DateTime

  """Stage of the crawler lead."""
  crawler_stage: String!
}

input CrawlerLeadFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CrawlerLeadFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: CrawlerLeadFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: CrawlerLeadFindInputSortOrder
}

input CrawlerLeadFindInputGroupBy {
  crawler_stage: Boolean
}

input CrawlerLeadFindInputSortOrder {
  lead_id: RecordSortDirectionEnum
  crawler_stage: RecordSortDirectionEnum
}

input CrawlerLeadFindInputWhere {
  """Unique ID of the lead, auto generated."""
  lead_id: FindOperatorDto

  """Stage of the crawler lead."""
  crawler_stage: FindOperatorDto
}

input CrawlerLeadFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type CrawlerLeadFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [CrawlerLeadEntity!]!
}

input CrawlerLeadRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CrawlerLeadRecoverInputWhere!]
}

input CrawlerLeadRecoverInputWhere {
  """Unique ID of the lead, auto generated."""
  lead_id: FindOperatorDto

  """Stage of the crawler lead."""
  crawler_stage: FindOperatorDto
}

type CrawlerLeadRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CrawlerLeadEntity!]!
}

input CrawlerLeadRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CrawlerLeadRemoveInputWhere!]
}

input CrawlerLeadRemoveInputWhere {
  """Unique ID of the lead, auto generated."""
  lead_id: FindOperatorDto

  """Stage of the crawler lead."""
  crawler_stage: FindOperatorDto
}

type CrawlerLeadRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CrawlerLeadEntity!]!
}

input CrawlerLeadRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CrawlerLeadRestoreInputWhere!]
}

input CrawlerLeadRestoreInputWhere {
  """Unique ID of the lead, auto generated."""
  lead_id: FindOperatorDto

  """Stage of the crawler lead."""
  crawler_stage: FindOperatorDto
}

type CrawlerLeadRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input CrawlerLeadSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CrawlerLeadSoftDeleteInputWhere!]
}

input CrawlerLeadSoftDeleteInputWhere {
  """Unique ID of the lead, auto generated."""
  lead_id: FindOperatorDto

  """Stage of the crawler lead."""
  crawler_stage: FindOperatorDto
}

type CrawlerLeadSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input CrawlerLeadSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CrawlerLeadSoftRemoveInputWhere!]
}

input CrawlerLeadSoftRemoveInputWhere {
  """Unique ID of the lead, auto generated."""
  lead_id: FindOperatorDto

  """Stage of the crawler lead."""
  crawler_stage: FindOperatorDto
}

type CrawlerLeadSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [CrawlerLeadEntity!]!
}

input CrawlerLeadUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [CrawlerLeadUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: CrawlerLeadUpdateInputSets!
}

input CrawlerLeadUpdateInputSets {
  """User ID related to the lead."""
  u_id: Int

  """Business ID related to the lead."""
  busns_id: Int

  """User's first name."""
  u_fname: String

  """User's last name."""
  u_lname: String

  """User's middle name."""
  u_mname: String

  """Connection source ID."""
  u_connsrc_id: String

  """User's primary email."""
  u_primary_email: String

  """User's primary mobile number."""
  u_primary_mobile: String

  """User's primary mobile country code."""
  u_primary_mobile_cc: String

  """User's WhatsApp number."""
  u_whatsapp: String

  """User's WhatsApp country code."""
  u_whatsapp_cc: String

  """Primary email verification status."""
  u_pemail_verified: Int

  """Primary mobile verification status."""
  u_pmobile_verified: Int

  """Overall verification status."""
  u_verified: Int

  """User suspension status."""
  u_suspended: Int

  """User gender info."""
  upinfo_gender: String

  """User website URL."""
  upinfo_website_url: String

  """User Facebook profile URL."""
  upinfo_facebook_profile: String

  """User Instagram profile URL."""
  upinfo_instagram_profile: String

  """User LinkedIn profile URL."""
  upinfo_linkedin_profile: String

  """User YouTube profile URL."""
  upinfo_youtube_profile: String

  """User X (Twitter) profile URL."""
  upinfo_x_profile: String

  """User TikTok profile URL."""
  upinfo_tiktok_profile: String

  """User Pinterest profile URL."""
  upinfo_pinterest_profile: String

  """Address title."""
  uaddr_title: String

  """User address."""
  uaddr_address: String

  """User country."""
  uaddr_country: String

  """User state."""
  uaddr_state: String

  """User city."""
  uaddr_city: String

  """Postal or ZIP code."""
  uaddr_postal_zip_code: String

  """User's company name."""
  ucorp_company_name: String

  """User company email."""
  ucorp_email: String

  """User company mobile number."""
  ucorp_mobile: String

  """User company mobile country code."""
  ucorp_mobile_cc: String

  """User company website."""
  ucorp_website: String

  """Business pricing category ID."""
  busns_buspricat_id: String

  """Business sector category ID 1."""
  busns_busseccat_id_1: String

  """Business sector category ID 2."""
  busns_busseccat_id_2: String

  """Business sector category ID 3."""
  busns_busseccat_id_3: String

  """Business sector category ID 4."""
  busns_busseccat_id_4: String

  """Business sector category ID 5."""
  busns_busseccat_id_5: String

  """Business sector category ID 6."""
  busns_busseccat_id_6: String

  """Business sector category ID 7."""
  busns_busseccat_id_7: String

  """Business sector category ID 8."""
  busns_busseccat_id_8: String

  """Business sector category ID 9."""
  busns_busseccat_id_9: String

  """Business name."""
  busns_name: String

  """Business address."""
  busns_address: String

  """Business country."""
  busns_country: String

  """Business state."""
  busns_state: String

  """Business city."""
  busns_city: String

  """Business ZIP code."""
  busns_zipcode: String

  """Business toll-free number."""
  busns_toll_free_number: String

  """Business mobile number."""
  busns_mobile: String

  """Business mobile country code."""
  busns_mobile_cc: String

  """Business WhatsApp number."""
  busns_whatsapp: String

  """Business WhatsApp country code."""
  busns_whatsapp_cc: String

  """Business email address."""
  busns_email: String

  """Google My Business URL."""
  busns_google_my_business_url: String

  """Google Map URL."""
  busns_google_map_url: String

  """Google Review URL."""
  busns_google_review_url: String

  """Business location latitude."""
  busns_location_latitude: String

  """Business location longitude."""
  busns_location_longitude: String

  """Business website URL."""
  busns_website_url: String

  """Business LinkedIn profile."""
  busns_linkedin_profile: String

  """Business Facebook profile."""
  busns_facebook_profile: String

  """Business Instagram profile."""
  busns_instagram_profile: String

  """Business YouTube profile."""
  busns_youtube_profile: String

  """Business X profile."""
  busns_x_profile: String

  """Business TikTok profile."""
  busns_tiktok_profile: String

  """Business Pinterest profile."""
  busns_pinterest_profile: String

  """Business registration datetime."""
  busns_registered: DateTime

  """Initial business findings."""
  busns_initial_findings: String

  """Business competitor findings."""
  busns_competitor_findings: String

  """Reference type for the lead."""
  lead_ref_type: String

  """Reference ID for the lead."""
  lead_ref_id: Int

  """Preferred contact method."""
  lead_preferred_contact_method: String

  """Concern or issue of the lead."""
  lead_concern_issue: String

  """Subject of the lead."""
  lead_subject: String

  """Comment on the lead."""
  lead_comment: String

  """Initial findings of the lead."""
  lead_initial_findings: String

  """First incoming message date."""
  lead_first_incoming_message_dt: DateTime

  """Lead creation datetime."""
  lead_created: DateTime

  """Lead update datetime."""
  lead_updated: DateTime

  """Crawler update datetime."""
  crawler_updated: DateTime

  """Stage of the crawler lead."""
  crawler_stage: String
}

input CrawlerLeadUpdateInputWhere {
  """Unique ID of the lead, auto generated."""
  lead_id: FindOperatorDto

  """Stage of the crawler lead."""
  crawler_stage: FindOperatorDto
}

type CrawlerLeadUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [CrawlerLeadEntity!]!
}

input CrawlerLeadUpsertInput {
  """User ID related to the lead."""
  u_id: Int

  """Business ID related to the lead."""
  busns_id: Int

  """User's first name."""
  u_fname: String

  """User's last name."""
  u_lname: String

  """User's middle name."""
  u_mname: String

  """Connection source ID."""
  u_connsrc_id: String

  """User's primary email."""
  u_primary_email: String

  """User's primary mobile number."""
  u_primary_mobile: String

  """User's primary mobile country code."""
  u_primary_mobile_cc: String

  """User's WhatsApp number."""
  u_whatsapp: String

  """User's WhatsApp country code."""
  u_whatsapp_cc: String

  """Primary email verification status."""
  u_pemail_verified: Int

  """Primary mobile verification status."""
  u_pmobile_verified: Int

  """Overall verification status."""
  u_verified: Int

  """User suspension status."""
  u_suspended: Int

  """User gender info."""
  upinfo_gender: String

  """User website URL."""
  upinfo_website_url: String

  """User Facebook profile URL."""
  upinfo_facebook_profile: String

  """User Instagram profile URL."""
  upinfo_instagram_profile: String

  """User LinkedIn profile URL."""
  upinfo_linkedin_profile: String

  """User YouTube profile URL."""
  upinfo_youtube_profile: String

  """User X (Twitter) profile URL."""
  upinfo_x_profile: String

  """User TikTok profile URL."""
  upinfo_tiktok_profile: String

  """User Pinterest profile URL."""
  upinfo_pinterest_profile: String

  """Address title."""
  uaddr_title: String

  """User address."""
  uaddr_address: String

  """User country."""
  uaddr_country: String

  """User state."""
  uaddr_state: String

  """User city."""
  uaddr_city: String

  """Postal or ZIP code."""
  uaddr_postal_zip_code: String

  """User's company name."""
  ucorp_company_name: String

  """User company email."""
  ucorp_email: String

  """User company mobile number."""
  ucorp_mobile: String

  """User company mobile country code."""
  ucorp_mobile_cc: String

  """User company website."""
  ucorp_website: String

  """Business pricing category ID."""
  busns_buspricat_id: String

  """Business sector category ID 1."""
  busns_busseccat_id_1: String

  """Business sector category ID 2."""
  busns_busseccat_id_2: String

  """Business sector category ID 3."""
  busns_busseccat_id_3: String

  """Business sector category ID 4."""
  busns_busseccat_id_4: String

  """Business sector category ID 5."""
  busns_busseccat_id_5: String

  """Business sector category ID 6."""
  busns_busseccat_id_6: String

  """Business sector category ID 7."""
  busns_busseccat_id_7: String

  """Business sector category ID 8."""
  busns_busseccat_id_8: String

  """Business sector category ID 9."""
  busns_busseccat_id_9: String

  """Business name."""
  busns_name: String

  """Business address."""
  busns_address: String

  """Business country."""
  busns_country: String

  """Business state."""
  busns_state: String

  """Business city."""
  busns_city: String

  """Business ZIP code."""
  busns_zipcode: String

  """Business toll-free number."""
  busns_toll_free_number: String

  """Business mobile number."""
  busns_mobile: String

  """Business mobile country code."""
  busns_mobile_cc: String

  """Business WhatsApp number."""
  busns_whatsapp: String

  """Business WhatsApp country code."""
  busns_whatsapp_cc: String

  """Business email address."""
  busns_email: String

  """Google My Business URL."""
  busns_google_my_business_url: String

  """Google Map URL."""
  busns_google_map_url: String

  """Google Review URL."""
  busns_google_review_url: String

  """Business location latitude."""
  busns_location_latitude: String

  """Business location longitude."""
  busns_location_longitude: String

  """Business website URL."""
  busns_website_url: String

  """Business LinkedIn profile."""
  busns_linkedin_profile: String

  """Business Facebook profile."""
  busns_facebook_profile: String

  """Business Instagram profile."""
  busns_instagram_profile: String

  """Business YouTube profile."""
  busns_youtube_profile: String

  """Business X profile."""
  busns_x_profile: String

  """Business TikTok profile."""
  busns_tiktok_profile: String

  """Business Pinterest profile."""
  busns_pinterest_profile: String

  """Business registration datetime."""
  busns_registered: DateTime

  """Initial business findings."""
  busns_initial_findings: String

  """Business competitor findings."""
  busns_competitor_findings: String

  """Reference type for the lead."""
  lead_ref_type: String

  """Reference ID for the lead."""
  lead_ref_id: Int

  """Preferred contact method."""
  lead_preferred_contact_method: String

  """Concern or issue of the lead."""
  lead_concern_issue: String

  """Subject of the lead."""
  lead_subject: String

  """Comment on the lead."""
  lead_comment: String

  """Initial findings of the lead."""
  lead_initial_findings: String

  """First incoming message date."""
  lead_first_incoming_message_dt: DateTime

  """Lead creation datetime."""
  lead_created: DateTime

  """Lead update datetime."""
  lead_updated: DateTime

  """Crawler update datetime."""
  crawler_updated: DateTime

  """Stage of the crawler lead."""
  crawler_stage: String!

  """Unique ID of the lead, auto generated. undefined"""
  id: Int
}

type CrawlerLeadUpsertOutput {
  """Unique ID of the lead, auto generated."""
  lead_id: Int

  """User ID related to the lead."""
  u_id: Int

  """Business ID related to the lead."""
  busns_id: Int

  """User's first name."""
  u_fname: String

  """User's last name."""
  u_lname: String

  """User's middle name."""
  u_mname: String

  """Connection source ID."""
  u_connsrc_id: String

  """User's primary email."""
  u_primary_email: String

  """User's primary mobile number."""
  u_primary_mobile: String

  """User's primary mobile country code."""
  u_primary_mobile_cc: String

  """User's WhatsApp number."""
  u_whatsapp: String

  """User's WhatsApp country code."""
  u_whatsapp_cc: String

  """Primary email verification status."""
  u_pemail_verified: Int

  """Primary mobile verification status."""
  u_pmobile_verified: Int

  """Overall verification status."""
  u_verified: Int

  """User suspension status."""
  u_suspended: Int

  """User gender info."""
  upinfo_gender: String

  """User website URL."""
  upinfo_website_url: String

  """User Facebook profile URL."""
  upinfo_facebook_profile: String

  """User Instagram profile URL."""
  upinfo_instagram_profile: String

  """User LinkedIn profile URL."""
  upinfo_linkedin_profile: String

  """User YouTube profile URL."""
  upinfo_youtube_profile: String

  """User X (Twitter) profile URL."""
  upinfo_x_profile: String

  """User TikTok profile URL."""
  upinfo_tiktok_profile: String

  """User Pinterest profile URL."""
  upinfo_pinterest_profile: String

  """Address title."""
  uaddr_title: String

  """User address."""
  uaddr_address: String

  """User country."""
  uaddr_country: String

  """User state."""
  uaddr_state: String

  """User city."""
  uaddr_city: String

  """Postal or ZIP code."""
  uaddr_postal_zip_code: String

  """User's company name."""
  ucorp_company_name: String

  """User company email."""
  ucorp_email: String

  """User company mobile number."""
  ucorp_mobile: String

  """User company mobile country code."""
  ucorp_mobile_cc: String

  """User company website."""
  ucorp_website: String

  """Business pricing category ID."""
  busns_buspricat_id: String

  """Business sector category ID 1."""
  busns_busseccat_id_1: String

  """Business sector category ID 2."""
  busns_busseccat_id_2: String

  """Business sector category ID 3."""
  busns_busseccat_id_3: String

  """Business sector category ID 4."""
  busns_busseccat_id_4: String

  """Business sector category ID 5."""
  busns_busseccat_id_5: String

  """Business sector category ID 6."""
  busns_busseccat_id_6: String

  """Business sector category ID 7."""
  busns_busseccat_id_7: String

  """Business sector category ID 8."""
  busns_busseccat_id_8: String

  """Business sector category ID 9."""
  busns_busseccat_id_9: String

  """Business name."""
  busns_name: String

  """Business address."""
  busns_address: String

  """Business country."""
  busns_country: String

  """Business state."""
  busns_state: String

  """Business city."""
  busns_city: String

  """Business ZIP code."""
  busns_zipcode: String

  """Business toll-free number."""
  busns_toll_free_number: String

  """Business mobile number."""
  busns_mobile: String

  """Business mobile country code."""
  busns_mobile_cc: String

  """Business WhatsApp number."""
  busns_whatsapp: String

  """Business WhatsApp country code."""
  busns_whatsapp_cc: String

  """Business email address."""
  busns_email: String

  """Google My Business URL."""
  busns_google_my_business_url: String

  """Google Map URL."""
  busns_google_map_url: String

  """Google Review URL."""
  busns_google_review_url: String

  """Business location latitude."""
  busns_location_latitude: String

  """Business location longitude."""
  busns_location_longitude: String

  """Business website URL."""
  busns_website_url: String

  """Business LinkedIn profile."""
  busns_linkedin_profile: String

  """Business Facebook profile."""
  busns_facebook_profile: String

  """Business Instagram profile."""
  busns_instagram_profile: String

  """Business YouTube profile."""
  busns_youtube_profile: String

  """Business X profile."""
  busns_x_profile: String

  """Business TikTok profile."""
  busns_tiktok_profile: String

  """Business Pinterest profile."""
  busns_pinterest_profile: String

  """Business registration datetime."""
  busns_registered: DateTime

  """Initial business findings."""
  busns_initial_findings: String

  """Business competitor findings."""
  busns_competitor_findings: String

  """Reference type for the lead."""
  lead_ref_type: String

  """Reference ID for the lead."""
  lead_ref_id: Int

  """Preferred contact method."""
  lead_preferred_contact_method: String

  """Concern or issue of the lead."""
  lead_concern_issue: String

  """Subject of the lead."""
  lead_subject: String

  """Comment on the lead."""
  lead_comment: String

  """Initial findings of the lead."""
  lead_initial_findings: String
  lead_first_incoming_message_dt: DateTime

  """Lead creation datetime."""
  lead_created: DateTime

  """Lead update datetime."""
  lead_updated: DateTime

  """Crawler update datetime."""
  crawler_updated: DateTime

  """Stage of the crawler lead."""
  crawler_stage: String!

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""
A date-time string. Such as `07 Apr 2024 10:10:00 am`, compliant with the date-time format.
"""
scalar DateTime

input DeviceCreateInput {
  """Name of the entity."""
  name: String!

  """Operating system platform."""
  os: String!

  """Interface of the entity."""
  interface: String!

  """Raw agent string of the entity."""
  user_agent: String!
}

type DeviceCreateOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Raw agent string of the entity."""
  user_agent: String

  """Name of the entity."""
  name: String

  """Operating system platform."""
  os: String

  """Interface of the entity."""
  interface: String

  """Approved status of the entity."""
  approved: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceEntity!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionEntity!]

  """Setting of who has access to given device."""
  fr_setting: [SettingEntity!]

  """Newsletter tracking log with a specific device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogEntity!]
}

input DeviceDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [DeviceDeleteInputWhere!]
}

input DeviceDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Name of the entity."""
  name: FindOperatorDto

  """Operating system platform."""
  os: FindOperatorDto

  """Interface of the entity."""
  interface: FindOperatorDto

  """Approved status of the entity."""
  approved: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceFindInputWhere!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionFindInputWhere!]

  """Setting of who has access to given device."""
  fr_setting: [SettingFindInputWhere!]

  """Setting of who has access to given device."""
  fr_leads: [LeadFindInputWhere!]

  """Setting of who has access to given device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogFindInputWhere!]
}

type DeviceDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type DeviceEntity {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Raw agent string of the entity."""
  user_agent: String

  """Name of the entity."""
  name: String

  """Operating system platform."""
  os: String

  """Interface of the entity."""
  interface: String

  """Approved status of the entity."""
  approved: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceEntity!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionEntity!]

  """Setting of who has access to given device."""
  fr_setting: [SettingEntity!]

  """Newsletter tracking log with a specific device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogEntity!]
}

input DeviceFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [DeviceFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: DeviceFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: DeviceFindInputSortOrder
}

input DeviceFindInputGroupBy {
  os: Boolean
  interface: Boolean
  approved: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input DeviceFindInputSortOrder {
  id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  os: RecordSortDirectionEnum
  interface: RecordSortDirectionEnum
  approved: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input DeviceFindInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Name of the entity."""
  name: FindOperatorDto

  """Operating system platform."""
  os: FindOperatorDto

  """Interface of the entity."""
  interface: FindOperatorDto

  """Approved status of the entity."""
  approved: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceFindInputWhere!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionFindInputWhere!]

  """Setting of who has access to given device."""
  fr_setting: [SettingFindInputWhere!]

  """Setting of who has access to given device."""
  fr_leads: [LeadFindInputWhere!]

  """Setting of who has access to given device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogFindInputWhere!]
}

input DeviceFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type DeviceFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [DeviceFindOutputRows!]!
}

type DeviceFindOutputRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Raw agent string of the entity."""
  user_agent: String

  """Name of the entity."""
  name: String

  """Operating system platform."""
  os: String

  """Interface of the entity."""
  interface: String

  """Approved status of the entity."""
  approved: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceEntity!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionEntity!]

  """Setting of who has access to given device."""
  fr_setting: [SettingEntity!]

  """Newsletter tracking log with a specific device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogEntity!]
}

input DeviceRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [DeviceRecoverInputWhere!]
}

input DeviceRecoverInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Name of the entity."""
  name: FindOperatorDto

  """Operating system platform."""
  os: FindOperatorDto

  """Interface of the entity."""
  interface: FindOperatorDto

  """Approved status of the entity."""
  approved: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceFindInputWhere!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionFindInputWhere!]

  """Setting of who has access to given device."""
  fr_setting: [SettingFindInputWhere!]

  """Setting of who has access to given device."""
  fr_leads: [LeadFindInputWhere!]

  """Setting of who has access to given device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogFindInputWhere!]
}

type DeviceRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [DeviceRecoverOutputAffectedRows!]!
}

type DeviceRecoverOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Raw agent string of the entity."""
  user_agent: String

  """Name of the entity."""
  name: String

  """Operating system platform."""
  os: String

  """Interface of the entity."""
  interface: String

  """Approved status of the entity."""
  approved: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceEntity!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionEntity!]

  """Setting of who has access to given device."""
  fr_setting: [SettingEntity!]

  """Newsletter tracking log with a specific device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogEntity!]
}

input DeviceRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [DeviceRemoveInputWhere!]
}

input DeviceRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Name of the entity."""
  name: FindOperatorDto

  """Operating system platform."""
  os: FindOperatorDto

  """Interface of the entity."""
  interface: FindOperatorDto

  """Approved status of the entity."""
  approved: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceFindInputWhere!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionFindInputWhere!]

  """Setting of who has access to given device."""
  fr_setting: [SettingFindInputWhere!]

  """Setting of who has access to given device."""
  fr_leads: [LeadFindInputWhere!]

  """Setting of who has access to given device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogFindInputWhere!]
}

type DeviceRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [DeviceRemoveOutputAffectedRows!]!
}

type DeviceRemoveOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Raw agent string of the entity."""
  user_agent: String

  """Name of the entity."""
  name: String

  """Operating system platform."""
  os: String

  """Interface of the entity."""
  interface: String

  """Approved status of the entity."""
  approved: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceEntity!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionEntity!]

  """Setting of who has access to given device."""
  fr_setting: [SettingEntity!]

  """Newsletter tracking log with a specific device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogEntity!]
}

input DeviceRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [DeviceRestoreInputWhere!]
}

input DeviceRestoreInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Name of the entity."""
  name: FindOperatorDto

  """Operating system platform."""
  os: FindOperatorDto

  """Interface of the entity."""
  interface: FindOperatorDto

  """Approved status of the entity."""
  approved: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceFindInputWhere!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionFindInputWhere!]

  """Setting of who has access to given device."""
  fr_setting: [SettingFindInputWhere!]

  """Setting of who has access to given device."""
  fr_leads: [LeadFindInputWhere!]

  """Setting of who has access to given device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogFindInputWhere!]
}

type DeviceRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input DeviceSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [DeviceSoftDeleteInputWhere!]
}

input DeviceSoftDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Name of the entity."""
  name: FindOperatorDto

  """Operating system platform."""
  os: FindOperatorDto

  """Interface of the entity."""
  interface: FindOperatorDto

  """Approved status of the entity."""
  approved: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceFindInputWhere!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionFindInputWhere!]

  """Setting of who has access to given device."""
  fr_setting: [SettingFindInputWhere!]

  """Setting of who has access to given device."""
  fr_leads: [LeadFindInputWhere!]

  """Setting of who has access to given device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogFindInputWhere!]
}

type DeviceSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input DeviceSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [DeviceSoftRemoveInputWhere!]
}

input DeviceSoftRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Name of the entity."""
  name: FindOperatorDto

  """Operating system platform."""
  os: FindOperatorDto

  """Interface of the entity."""
  interface: FindOperatorDto

  """Approved status of the entity."""
  approved: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceFindInputWhere!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionFindInputWhere!]

  """Setting of who has access to given device."""
  fr_setting: [SettingFindInputWhere!]

  """Setting of who has access to given device."""
  fr_leads: [LeadFindInputWhere!]

  """Setting of who has access to given device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogFindInputWhere!]
}

type DeviceSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [DeviceSoftRemoveOutputAffectedRows!]!
}

type DeviceSoftRemoveOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Raw agent string of the entity."""
  user_agent: String

  """Name of the entity."""
  name: String

  """Operating system platform."""
  os: String

  """Interface of the entity."""
  interface: String

  """Approved status of the entity."""
  approved: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceEntity!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionEntity!]

  """Setting of who has access to given device."""
  fr_setting: [SettingEntity!]

  """Newsletter tracking log with a specific device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogEntity!]
}

input DeviceUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [DeviceUpdateInputWhere!]!

  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  sets: DeviceUpdateInputSets!
}

input DeviceUpdateInputSets {
  """Name of the entity."""
  name: String

  """Operating system platform."""
  os: String

  """Interface of the entity."""
  interface: String

  """Raw agent string of the entity."""
  user_agent: String
}

input DeviceUpdateInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Name of the entity."""
  name: FindOperatorDto

  """Operating system platform."""
  os: FindOperatorDto

  """Interface of the entity."""
  interface: FindOperatorDto

  """Approved status of the entity."""
  approved: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceFindInputWhere!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionFindInputWhere!]

  """Setting of who has access to given device."""
  fr_setting: [SettingFindInputWhere!]

  """Setting of who has access to given device."""
  fr_leads: [LeadFindInputWhere!]

  """Setting of who has access to given device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogFindInputWhere!]
}

type DeviceUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [DeviceUpdateOutputAffectedRows!]!
}

type DeviceUpdateOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Raw agent string of the entity."""
  user_agent: String

  """Name of the entity."""
  name: String

  """Operating system platform."""
  os: String

  """Interface of the entity."""
  interface: String

  """Approved status of the entity."""
  approved: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceEntity!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionEntity!]

  """Setting of who has access to given device."""
  fr_setting: [SettingEntity!]

  """Newsletter tracking log with a specific device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogEntity!]
}

input DeviceUpsertInput {
  """Name of the entity."""
  name: String!

  """Operating system platform."""
  os: String!

  """Interface of the entity."""
  interface: String!

  """Raw agent string of the entity."""
  user_agent: String!

  """Unique ID of the entity, auto generated. undefined"""
  id: Int
}

type DeviceUpsertOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Raw agent string of the entity."""
  user_agent: String

  """Name of the entity."""
  name: String

  """Operating system platform."""
  os: String

  """Interface of the entity."""
  interface: String

  """Approved status of the entity."""
  approved: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of users who has access to given device."""
  fr_device_users: [UserDeviceEntity!]

  """List of sessions who has access to given device."""
  fr_sessions: [SessionEntity!]

  """Setting of who has access to given device."""
  fr_setting: [SettingEntity!]

  """Newsletter tracking log with a specific device."""
  fr_newsletter_tracking_logs_info: [NewsLetterTrackLogEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""
A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address.
"""
scalar EmailAddress

input EmailTemplateCategoryCreateInput {
  """Title of the email template."""
  title: String!

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime
}

type EmailTemplateCategoryCreateOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Email template category for email template."""
  fr_email_templates: [EmailTemplateEntity!]
}

input EmailTemplateCategoryDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateCategoryDeleteInputWhere!]
}

input EmailTemplateCategoryDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email template category for email template."""
  fr_email_templates: [EmailTemplateFindInputWhere!]
}

type EmailTemplateCategoryDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type EmailTemplateCategoryEntity {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Email template category for email template."""
  fr_email_templates: [EmailTemplateEntity!]
}

input EmailTemplateCategoryFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateCategoryFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: EmailTemplateCategoryFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: EmailTemplateCategoryFindInputSortOrder
}

input EmailTemplateCategoryFindInputGroupBy {
  title: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input EmailTemplateCategoryFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input EmailTemplateCategoryFindInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email template category for email template."""
  fr_email_templates: [EmailTemplateFindInputWhere!]
}

input EmailTemplateCategoryFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type EmailTemplateCategoryFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [EmailTemplateCategoryEntity!]!
}

input EmailTemplateCategoryRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateCategoryRecoverInputWhere!]
}

input EmailTemplateCategoryRecoverInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email template category for email template."""
  fr_email_templates: [EmailTemplateFindInputWhere!]
}

type EmailTemplateCategoryRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [EmailTemplateCategoryEntity!]!
}

input EmailTemplateCategoryRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateCategoryRemoveInputWhere!]
}

input EmailTemplateCategoryRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email template category for email template."""
  fr_email_templates: [EmailTemplateFindInputWhere!]
}

type EmailTemplateCategoryRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [EmailTemplateCategoryEntity!]!
}

input EmailTemplateCategoryRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateCategoryRestoreInputWhere!]
}

input EmailTemplateCategoryRestoreInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email template category for email template."""
  fr_email_templates: [EmailTemplateFindInputWhere!]
}

type EmailTemplateCategoryRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input EmailTemplateCategorySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateCategorySoftDeleteInputWhere!]
}

input EmailTemplateCategorySoftDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email template category for email template."""
  fr_email_templates: [EmailTemplateFindInputWhere!]
}

type EmailTemplateCategorySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input EmailTemplateCategorySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateCategorySoftRemoveInputWhere!]
}

input EmailTemplateCategorySoftRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email template category for email template."""
  fr_email_templates: [EmailTemplateFindInputWhere!]
}

type EmailTemplateCategorySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [EmailTemplateCategoryEntity!]!
}

input EmailTemplateCategoryUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateCategoryUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: EmailTemplateCategoryUpdateInputSets!
}

input EmailTemplateCategoryUpdateInputSets {
  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime
}

input EmailTemplateCategoryUpdateInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email template category for email template."""
  fr_email_templates: [EmailTemplateFindInputWhere!]
}

type EmailTemplateCategoryUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [EmailTemplateCategoryEntity!]!
}

input EmailTemplateCategoryUpsertInput {
  """Title of the email template."""
  title: String!

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """Unique ID of the email template, auto generated. undefined"""
  id: Int
}

type EmailTemplateCategoryUpsertOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Email template category for email template."""
  fr_email_templates: [EmailTemplateEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input EmailTemplateCreateInput {
  """Title of the email template."""
  title: String!

  """Type of the email template category id."""
  etmplcat_id: Int!

  """Subject of the email template."""
  subject: String!

  """Content body of the email template."""
  body: String!

  """Indicates if the email template default or not."""
  use_default_header_footer: YesNoEnum!

  """Indicates if email template active or not."""
  active: DateTime
}

type EmailTemplateCreateOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Type of the email template category id."""
  etmplcat_id: Int

  """Subject of the email template."""
  subject: String

  """Content body of the email template."""
  body: String

  """Indicates if the email template default or not."""
  use_default_header_footer: YesNoEnum

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Email template for this news letter."""
  fr_newsletters: [NewsLetterEntity!]

  """email template category for the email template."""
  fr_email_template_category: EmailTemplateCategoryEntity
}

input EmailTemplateDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateDeleteInputWhere!]
}

input EmailTemplateDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Type of the email template category id."""
  etmplcat_id: FindOperatorDto

  """Subject of the email template."""
  subject: FindOperatorDto

  """Indicates if the email template default or not."""
  use_default_header_footer: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """email template category for the email template."""
  fr_email_template_category: [EmailTemplateCategoryFindInputWhere!]

  """Email template for this news letter."""
  fr_newsletters: [NewsLetterFindInputWhere!]
}

type EmailTemplateDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type EmailTemplateEntity {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Type of the email template category id."""
  etmplcat_id: Int

  """Subject of the email template."""
  subject: String

  """Content body of the email template."""
  body: String

  """Indicates if the email template default or not."""
  use_default_header_footer: YesNoEnum

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Email template for this news letter."""
  fr_newsletters: [NewsLetterEntity!]

  """email template category for the email template."""
  fr_email_template_category: EmailTemplateCategoryEntity
}

input EmailTemplateFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: EmailTemplateFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: EmailTemplateFindInputSortOrder
}

input EmailTemplateFindInputGroupBy {
  title: Boolean
  etmplcat_id: Boolean
  subject: Boolean
  use_default_header_footer: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input EmailTemplateFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  etmplcat_id: RecordSortDirectionEnum
  subject: RecordSortDirectionEnum
  use_default_header_footer: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input EmailTemplateFindInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Type of the email template category id."""
  etmplcat_id: FindOperatorDto

  """Subject of the email template."""
  subject: FindOperatorDto

  """Indicates if the email template default or not."""
  use_default_header_footer: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """email template category for the email template."""
  fr_email_template_category: [EmailTemplateCategoryFindInputWhere!]

  """Email template for this news letter."""
  fr_newsletters: [NewsLetterFindInputWhere!]
}

input EmailTemplateFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type EmailTemplateFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [EmailTemplateEntity!]!
}

input EmailTemplateRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateRecoverInputWhere!]
}

input EmailTemplateRecoverInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Type of the email template category id."""
  etmplcat_id: FindOperatorDto

  """Subject of the email template."""
  subject: FindOperatorDto

  """Indicates if the email template default or not."""
  use_default_header_footer: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """email template category for the email template."""
  fr_email_template_category: [EmailTemplateCategoryFindInputWhere!]

  """Email template for this news letter."""
  fr_newsletters: [NewsLetterFindInputWhere!]
}

type EmailTemplateRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [EmailTemplateEntity!]!
}

input EmailTemplateRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateRemoveInputWhere!]
}

input EmailTemplateRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Type of the email template category id."""
  etmplcat_id: FindOperatorDto

  """Subject of the email template."""
  subject: FindOperatorDto

  """Indicates if the email template default or not."""
  use_default_header_footer: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """email template category for the email template."""
  fr_email_template_category: [EmailTemplateCategoryFindInputWhere!]

  """Email template for this news letter."""
  fr_newsletters: [NewsLetterFindInputWhere!]
}

type EmailTemplateRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [EmailTemplateEntity!]!
}

input EmailTemplateRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateRestoreInputWhere!]
}

input EmailTemplateRestoreInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Type of the email template category id."""
  etmplcat_id: FindOperatorDto

  """Subject of the email template."""
  subject: FindOperatorDto

  """Indicates if the email template default or not."""
  use_default_header_footer: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """email template category for the email template."""
  fr_email_template_category: [EmailTemplateCategoryFindInputWhere!]

  """Email template for this news letter."""
  fr_newsletters: [NewsLetterFindInputWhere!]
}

type EmailTemplateRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input EmailTemplateSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateSoftDeleteInputWhere!]
}

input EmailTemplateSoftDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Type of the email template category id."""
  etmplcat_id: FindOperatorDto

  """Subject of the email template."""
  subject: FindOperatorDto

  """Indicates if the email template default or not."""
  use_default_header_footer: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """email template category for the email template."""
  fr_email_template_category: [EmailTemplateCategoryFindInputWhere!]

  """Email template for this news letter."""
  fr_newsletters: [NewsLetterFindInputWhere!]
}

type EmailTemplateSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input EmailTemplateSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateSoftRemoveInputWhere!]
}

input EmailTemplateSoftRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Type of the email template category id."""
  etmplcat_id: FindOperatorDto

  """Subject of the email template."""
  subject: FindOperatorDto

  """Indicates if the email template default or not."""
  use_default_header_footer: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """email template category for the email template."""
  fr_email_template_category: [EmailTemplateCategoryFindInputWhere!]

  """Email template for this news letter."""
  fr_newsletters: [NewsLetterFindInputWhere!]
}

type EmailTemplateSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [EmailTemplateEntity!]!
}

input EmailTemplateUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [EmailTemplateUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: EmailTemplateUpdateInputSets!
}

input EmailTemplateUpdateInputSets {
  """Title of the email template."""
  title: String

  """Type of the email template category id."""
  etmplcat_id: Int

  """Subject of the email template."""
  subject: String

  """Content body of the email template."""
  body: String

  """Indicates if the email template default or not."""
  use_default_header_footer: YesNoEnum

  """Indicates if email template active or not."""
  active: DateTime
}

input EmailTemplateUpdateInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Type of the email template category id."""
  etmplcat_id: FindOperatorDto

  """Subject of the email template."""
  subject: FindOperatorDto

  """Indicates if the email template default or not."""
  use_default_header_footer: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """email template category for the email template."""
  fr_email_template_category: [EmailTemplateCategoryFindInputWhere!]

  """Email template for this news letter."""
  fr_newsletters: [NewsLetterFindInputWhere!]
}

type EmailTemplateUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [EmailTemplateEntity!]!
}

input EmailTemplateUpsertInput {
  """Title of the email template."""
  title: String!

  """Type of the email template category id."""
  etmplcat_id: Int!

  """Subject of the email template."""
  subject: String!

  """Content body of the email template."""
  body: String!

  """Indicates if the email template default or not."""
  use_default_header_footer: YesNoEnum!

  """Indicates if email template active or not."""
  active: DateTime

  """Unique ID of the email template, auto generated. undefined"""
  id: Int
}

type EmailTemplateUpsertOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Type of the email template category id."""
  etmplcat_id: Int

  """Subject of the email template."""
  subject: String

  """Content body of the email template."""
  body: String

  """Indicates if the email template default or not."""
  use_default_header_footer: YesNoEnum

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Email template for this news letter."""
  fr_newsletters: [NewsLetterEntity!]

  """email template category for the email template."""
  fr_email_template_category: EmailTemplateCategoryEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input FaqCategoryCreateInput {
  """Title of the faq category."""
  title: String!

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime
}

type FaqCategoryCreateOutput {
  """Unique ID of the faq category, auto generated."""
  id: Int

  """Title of the faq category."""
  title: String

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Faq category of faq category."""
  fr_faq_category: [FaqEntity!]
}

input FaqCategoryDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqCategoryDeleteInputWhere!]
}

input FaqCategoryDeleteInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq category of faq category."""
  fr_faq_category: [FaqFindInputWhere!]
}

type FaqCategoryDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type FaqCategoryEntity {
  """Unique ID of the faq category, auto generated."""
  id: Int

  """Title of the faq category."""
  title: String

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Faq category of faq category."""
  fr_faq_category: [FaqEntity!]
}

input FaqCategoryFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqCategoryFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: FaqCategoryFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: FaqCategoryFindInputSortOrder
}

input FaqCategoryFindInputGroupBy {
  title: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input FaqCategoryFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input FaqCategoryFindInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq category of faq category."""
  fr_faq_category: [FaqFindInputWhere!]
}

input FaqCategoryFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type FaqCategoryFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [FaqCategoryEntity!]!
}

input FaqCategoryRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqCategoryRecoverInputWhere!]
}

input FaqCategoryRecoverInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq category of faq category."""
  fr_faq_category: [FaqFindInputWhere!]
}

type FaqCategoryRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [FaqCategoryEntity!]!
}

input FaqCategoryRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqCategoryRemoveInputWhere!]
}

input FaqCategoryRemoveInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq category of faq category."""
  fr_faq_category: [FaqFindInputWhere!]
}

type FaqCategoryRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [FaqCategoryEntity!]!
}

input FaqCategoryRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqCategoryRestoreInputWhere!]
}

input FaqCategoryRestoreInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq category of faq category."""
  fr_faq_category: [FaqFindInputWhere!]
}

type FaqCategoryRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input FaqCategorySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqCategorySoftDeleteInputWhere!]
}

input FaqCategorySoftDeleteInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq category of faq category."""
  fr_faq_category: [FaqFindInputWhere!]
}

type FaqCategorySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input FaqCategorySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqCategorySoftRemoveInputWhere!]
}

input FaqCategorySoftRemoveInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq category of faq category."""
  fr_faq_category: [FaqFindInputWhere!]
}

type FaqCategorySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [FaqCategoryEntity!]!
}

input FaqCategoryUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqCategoryUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: FaqCategoryUpdateInputSets!
}

input FaqCategoryUpdateInputSets {
  """Title of the faq category."""
  title: String

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime
}

input FaqCategoryUpdateInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq category of faq category."""
  fr_faq_category: [FaqFindInputWhere!]
}

type FaqCategoryUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [FaqCategoryEntity!]!
}

input FaqCategoryUpsertInput {
  """Title of the faq category."""
  title: String!

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime

  """Unique ID of the faq category, auto generated. undefined"""
  id: Int
}

type FaqCategoryUpsertOutput {
  """Unique ID of the faq category, auto generated."""
  id: Int

  """Title of the faq category."""
  title: String

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Faq category of faq category."""
  fr_faq_category: [FaqEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input FaqCreateInput {
  """Faq category of the faq."""
  faqcat_id: Int!

  """Url slug of the faq."""
  url_slug: String!

  """Question of the faq."""
  question: String!

  """Answer of the faq."""
  answer: String!

  """Active of the faq."""
  active: DateTime
}

type FaqCreateOutput {
  """Unique ID of the pagemaster, auto generated."""
  id: Int

  """Faq category of the faq."""
  faqcat_id: Int

  """Url slug of the faq."""
  url_slug: String

  """Question of the faq."""
  question: String

  """Answer of the faq."""
  answer: String

  """Active of the faq."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Faq categories of the faq."""
  fr_faq_categories: FaqCategoryEntity
}

input FaqDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqDeleteInputWhere!]
}

input FaqDeleteInputWhere {
  """Unique ID of the pagemaster, auto generated."""
  id: FindOperatorDto

  """Faq category of the faq."""
  faqcat_id: FindOperatorDto

  """Url slug of the faq."""
  url_slug: FindOperatorDto

  """Active of the faq."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq categories of the faq."""
  fr_faq_categories: [FaqCategoryFindInputWhere!]
}

type FaqDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type FaqEntity {
  """Unique ID of the pagemaster, auto generated."""
  id: Int

  """Faq category of the faq."""
  faqcat_id: Int

  """Url slug of the faq."""
  url_slug: String

  """Question of the faq."""
  question: String

  """Answer of the faq."""
  answer: String

  """Active of the faq."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Faq categories of the faq."""
  fr_faq_categories: FaqCategoryEntity
}

input FaqFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: FaqFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: FaqFindInputSortOrder
}

input FaqFindInputGroupBy {
  faqcat_id: Boolean
  url_slug: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input FaqFindInputSortOrder {
  id: RecordSortDirectionEnum
  faqcat_id: RecordSortDirectionEnum
  url_slug: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input FaqFindInputWhere {
  """Unique ID of the pagemaster, auto generated."""
  id: FindOperatorDto

  """Faq category of the faq."""
  faqcat_id: FindOperatorDto

  """Url slug of the faq."""
  url_slug: FindOperatorDto

  """Active of the faq."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq categories of the faq."""
  fr_faq_categories: [FaqCategoryFindInputWhere!]
}

input FaqFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type FaqFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [FaqEntity!]!
}

input FaqRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqRecoverInputWhere!]
}

input FaqRecoverInputWhere {
  """Unique ID of the pagemaster, auto generated."""
  id: FindOperatorDto

  """Faq category of the faq."""
  faqcat_id: FindOperatorDto

  """Url slug of the faq."""
  url_slug: FindOperatorDto

  """Active of the faq."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq categories of the faq."""
  fr_faq_categories: [FaqCategoryFindInputWhere!]
}

type FaqRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [FaqEntity!]!
}

input FaqRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqRemoveInputWhere!]
}

input FaqRemoveInputWhere {
  """Unique ID of the pagemaster, auto generated."""
  id: FindOperatorDto

  """Faq category of the faq."""
  faqcat_id: FindOperatorDto

  """Url slug of the faq."""
  url_slug: FindOperatorDto

  """Active of the faq."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq categories of the faq."""
  fr_faq_categories: [FaqCategoryFindInputWhere!]
}

type FaqRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [FaqEntity!]!
}

input FaqRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqRestoreInputWhere!]
}

input FaqRestoreInputWhere {
  """Unique ID of the pagemaster, auto generated."""
  id: FindOperatorDto

  """Faq category of the faq."""
  faqcat_id: FindOperatorDto

  """Url slug of the faq."""
  url_slug: FindOperatorDto

  """Active of the faq."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq categories of the faq."""
  fr_faq_categories: [FaqCategoryFindInputWhere!]
}

type FaqRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input FaqSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqSoftDeleteInputWhere!]
}

input FaqSoftDeleteInputWhere {
  """Unique ID of the pagemaster, auto generated."""
  id: FindOperatorDto

  """Faq category of the faq."""
  faqcat_id: FindOperatorDto

  """Url slug of the faq."""
  url_slug: FindOperatorDto

  """Active of the faq."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq categories of the faq."""
  fr_faq_categories: [FaqCategoryFindInputWhere!]
}

type FaqSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input FaqSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqSoftRemoveInputWhere!]
}

input FaqSoftRemoveInputWhere {
  """Unique ID of the pagemaster, auto generated."""
  id: FindOperatorDto

  """Faq category of the faq."""
  faqcat_id: FindOperatorDto

  """Url slug of the faq."""
  url_slug: FindOperatorDto

  """Active of the faq."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq categories of the faq."""
  fr_faq_categories: [FaqCategoryFindInputWhere!]
}

type FaqSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [FaqEntity!]!
}

input FaqUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FaqUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: FaqUpdateInputSets!
}

input FaqUpdateInputSets {
  """Faq category of the faq."""
  faqcat_id: Int

  """Url slug of the faq."""
  url_slug: String

  """Question of the faq."""
  question: String

  """Answer of the faq."""
  answer: String

  """Active of the faq."""
  active: DateTime
}

input FaqUpdateInputWhere {
  """Unique ID of the pagemaster, auto generated."""
  id: FindOperatorDto

  """Faq category of the faq."""
  faqcat_id: FindOperatorDto

  """Url slug of the faq."""
  url_slug: FindOperatorDto

  """Active of the faq."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Faq categories of the faq."""
  fr_faq_categories: [FaqCategoryFindInputWhere!]
}

type FaqUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [FaqEntity!]!
}

input FaqUpsertInput {
  """Faq category of the faq."""
  faqcat_id: Int!

  """Url slug of the faq."""
  url_slug: String!

  """Question of the faq."""
  question: String!

  """Answer of the faq."""
  answer: String!

  """Active of the faq."""
  active: DateTime

  """Unique ID of the pagemaster, auto generated. undefined"""
  id: Int
}

type FaqUpsertOutput {
  """Unique ID of the pagemaster, auto generated."""
  id: Int

  """Faq category of the faq."""
  faqcat_id: Int

  """Url slug of the faq."""
  url_slug: String

  """Question of the faq."""
  question: String

  """Answer of the faq."""
  answer: String

  """Active of the faq."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Faq categories of the faq."""
  fr_faq_categories: FaqCategoryEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""
Use any ONE operator or any ONE and [ matchFun ] together, apart from that use of multiple operators will result in error.
"""
input FindOperatorDto {
  """Default: Search for data = in field."""
  equal: String

  """Default: Search for data <> in field."""
  notEqual: String

  """Search for data LIKE(%%) in field."""
  like: String

  """Search for data NOT LIKE(%%) in field."""
  notLike: String

  """Search for data IN() in field."""
  into: [String!]

  """Search for data NOT IN() in field."""
  notInto: [String!]

  """Search for data BETWEEN(..,..) in field."""
  between: [String!]

  """Search for data NOT BETWEEN(..,..) in field."""
  notBetween: [String!]

  """Search for data LessThan() in field."""
  lt: String

  """Search for data LessThanOrEqual() in field."""
  lte: String

  """Search for data MoreThan() in field."""
  mt: String

  """Search for data MoreThanOrEqual() in field."""
  mte: String

  """
  true for NULL search and false for NOT NULL search. Search for data NULL() in field.
  """
  nulls: Boolean

  """
  Search for data by applying database function on filed. Such as, DATE(filed) = fieldVal | MAX(filed) > fieldVal etc. This can be passed along with any other operator.
  """
  matchFun: String
}

type FindOutputPage {
  """Page number during pagining process"""
  page: Int!

  """Found records count for page"""
  count: Int!

  """Offset to get records for page"""
  skip: Int!
}

type FindOutputPagination {
  """First page paging information"""
  first: FindOutputPage!

  """Previous paging information"""
  previous: FindOutputPage!

  """Currect paging information"""
  current: FindOutputPage!

  """Next paging information"""
  next: FindOutputPage!

  """Last page paging information"""
  last: FindOutputPage!
}

input FormFieldCreateInput {
  """Title of the settingformcontroltype."""
  title: String!

  """Description of the settingformcontroltype."""
  desc: String
}

type FormFieldCreateOutput {
  """Unique ID of the settingformcontroltype, auto generated."""
  id: Int

  """Title of the settingformcontroltype."""
  title: String

  """Description of the settingformcontroltype."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Form field type"""
  fr_setting: [SettingEntity!]
}

input FormFieldDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FormFieldDeleteInputWhere!]
}

input FormFieldDeleteInputWhere {
  """Unique ID of the settingformcontroltype, auto generated."""
  id: FindOperatorDto

  """Title of the settingformcontroltype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Form field type"""
  fr_setting: [SettingFindInputWhere!]
}

type FormFieldDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type FormFieldEntity {
  """Unique ID of the settingformcontroltype, auto generated."""
  id: Int

  """Title of the settingformcontroltype."""
  title: String

  """Description of the settingformcontroltype."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Form field type"""
  fr_setting: [SettingEntity!]
}

input FormFieldFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FormFieldFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: FormFieldFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: FormFieldFindInputSortOrder
}

input FormFieldFindInputGroupBy {
  title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input FormFieldFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input FormFieldFindInputWhere {
  """Unique ID of the settingformcontroltype, auto generated."""
  id: FindOperatorDto

  """Title of the settingformcontroltype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Form field type"""
  fr_setting: [SettingFindInputWhere!]
}

input FormFieldFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type FormFieldFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [FormFieldEntity!]!
}

input FormFieldRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FormFieldRecoverInputWhere!]
}

input FormFieldRecoverInputWhere {
  """Unique ID of the settingformcontroltype, auto generated."""
  id: FindOperatorDto

  """Title of the settingformcontroltype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Form field type"""
  fr_setting: [SettingFindInputWhere!]
}

type FormFieldRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [FormFieldEntity!]!
}

input FormFieldRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FormFieldRemoveInputWhere!]
}

input FormFieldRemoveInputWhere {
  """Unique ID of the settingformcontroltype, auto generated."""
  id: FindOperatorDto

  """Title of the settingformcontroltype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Form field type"""
  fr_setting: [SettingFindInputWhere!]
}

type FormFieldRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [FormFieldEntity!]!
}

input FormFieldRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FormFieldRestoreInputWhere!]
}

input FormFieldRestoreInputWhere {
  """Unique ID of the settingformcontroltype, auto generated."""
  id: FindOperatorDto

  """Title of the settingformcontroltype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Form field type"""
  fr_setting: [SettingFindInputWhere!]
}

type FormFieldRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input FormFieldSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FormFieldSoftDeleteInputWhere!]
}

input FormFieldSoftDeleteInputWhere {
  """Unique ID of the settingformcontroltype, auto generated."""
  id: FindOperatorDto

  """Title of the settingformcontroltype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Form field type"""
  fr_setting: [SettingFindInputWhere!]
}

type FormFieldSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input FormFieldSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FormFieldSoftRemoveInputWhere!]
}

input FormFieldSoftRemoveInputWhere {
  """Unique ID of the settingformcontroltype, auto generated."""
  id: FindOperatorDto

  """Title of the settingformcontroltype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Form field type"""
  fr_setting: [SettingFindInputWhere!]
}

type FormFieldSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [FormFieldEntity!]!
}

input FormFieldUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [FormFieldUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: FormFieldUpdateInputSets!
}

input FormFieldUpdateInputSets {
  """Title of the settingformcontroltype."""
  title: String

  """Description of the settingformcontroltype."""
  desc: String
}

input FormFieldUpdateInputWhere {
  """Unique ID of the settingformcontroltype, auto generated."""
  id: FindOperatorDto

  """Title of the settingformcontroltype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Form field type"""
  fr_setting: [SettingFindInputWhere!]
}

type FormFieldUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [FormFieldEntity!]!
}

input FormFieldUpsertInput {
  """Title of the settingformcontroltype."""
  title: String!

  """Description of the settingformcontroltype."""
  desc: String

  """Unique ID of the settingformcontroltype, auto generated. undefined"""
  id: Int
}

type FormFieldUpsertOutput {
  """Unique ID of the settingformcontroltype, auto generated."""
  id: Int

  """Title of the settingformcontroltype."""
  title: String

  """Description of the settingformcontroltype."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Form field type"""
  fr_setting: [SettingEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""Used to set buy and sell rate type."""
enum GenderEnum {
  """Other"""
  OTHER

  """Male"""
  MALE

  """Female"""
  FEMALE
}

input GraphLoginInput {
  """Required to gain access to API endpoint."""
  username: String!

  """Required to gain access to API endpoint using JWT token."""
  identify: String!
}

type GraphLoginOutput {
  """Unique ID of the user, auto generated."""
  id: Int

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum

  """Required to gain access to API endpoint."""
  username: String

  """Email is required for varification and communication."""
  email: String

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: String

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: String

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input GraphResetPasswordInput {
  """Required to gain access to API endpoint."""
  username: String!

  """
  Required to gain access to API endpoint using JWT token. Password should be combination of digit, uppercase, lowercase, special charector !@#$%^&* and no more than 3 consecutive identical characters.
  """
  identify: String!

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: String!
}

type GraphResetPasswordOutput {
  """Unique ID of the user, auto generated."""
  id: Int

  """Required to gain access permission to restricted data."""
  role_id: ApiUserRoleEnum

  """Required to gain access to API endpoint."""
  username: String

  """Email is required for varification and communication."""
  email: String

  """Used for authentication using jwt bearer token. Life span is shorter."""
  jwt_access_token: JWT

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: JWT

  """
  If record is suspended, then date-time will be saved when record is suspended otherwise null to indicate record is not suspended.
  """
  suspended: DateTime

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input GraphSignupInput {
  """Required to gain access to API endpoint."""
  username: String!

  """
  Required to gain access to API endpoint using JWT token. Password should be combination of digit, uppercase, lowercase, special charector !@#$%^&* and no more than 3 consecutive identical characters.
  """
  identify: String!

  """Email is required for varification and communication."""
  email: String!
}

type GraphSignupOutput {
  """Required to gain access to API endpoint."""
  username: String

  """Email is required for varification and communication."""
  email: String

  """Required to gain access to API endpoint using JWT token."""
  jwt_access_token: String

  """Required to refresh jwt access token. Life span is bit longer."""
  jwt_refresh_token: String

  """Record created date time."""
  created: DateTime
}

input IdentityCardTypeCreateInput {
  """Name of the user identity card type."""
  name: String!

  """Description of the user identity card type."""
  desc: String
}

type IdentityCardTypeCreateOutput {
  """Unique ID of the user identity card type, auto generated."""
  id: Int

  """Name of the user identity card type."""
  name: String

  """Description of the user identity card type."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of user identity cards for this user identity card type."""
  fr_user_identity_cards: [UserIdentityCardEntity!]
}

input IdentityCardTypeDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [IdentityCardTypeDeleteInputWhere!]
}

input IdentityCardTypeDeleteInputWhere {
  """Unique ID of the user identity card type, auto generated."""
  id: FindOperatorDto

  """Name of the user identity card type."""
  name: FindOperatorDto

  """Description of the user identity card type."""
  desc: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user identity cards for this user identity card type."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]
}

type IdentityCardTypeDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type IdentityCardTypeEntity {
  """Unique ID of the user identity card type, auto generated."""
  id: Int

  """Name of the user identity card type."""
  name: String

  """Description of the user identity card type."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of user identity cards for this user identity card type."""
  fr_user_identity_cards: [UserIdentityCardEntity!]
}

input IdentityCardTypeFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [IdentityCardTypeFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: IdentityCardTypeFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: IdentityCardTypeFindInputSortOrder
}

input IdentityCardTypeFindInputGroupBy {
  name: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input IdentityCardTypeFindInputSortOrder {
  id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input IdentityCardTypeFindInputWhere {
  """Unique ID of the user identity card type, auto generated."""
  id: FindOperatorDto

  """Name of the user identity card type."""
  name: FindOperatorDto

  """Description of the user identity card type."""
  desc: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user identity cards for this user identity card type."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]
}

input IdentityCardTypeFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type IdentityCardTypeFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [IdentityCardTypeEntity!]!
}

input IdentityCardTypeRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [IdentityCardTypeRecoverInputWhere!]
}

input IdentityCardTypeRecoverInputWhere {
  """Unique ID of the user identity card type, auto generated."""
  id: FindOperatorDto

  """Name of the user identity card type."""
  name: FindOperatorDto

  """Description of the user identity card type."""
  desc: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user identity cards for this user identity card type."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]
}

type IdentityCardTypeRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [IdentityCardTypeEntity!]!
}

input IdentityCardTypeRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [IdentityCardTypeRemoveInputWhere!]
}

input IdentityCardTypeRemoveInputWhere {
  """Unique ID of the user identity card type, auto generated."""
  id: FindOperatorDto

  """Name of the user identity card type."""
  name: FindOperatorDto

  """Description of the user identity card type."""
  desc: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user identity cards for this user identity card type."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]
}

type IdentityCardTypeRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [IdentityCardTypeEntity!]!
}

input IdentityCardTypeRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [IdentityCardTypeRestoreInputWhere!]
}

input IdentityCardTypeRestoreInputWhere {
  """Unique ID of the user identity card type, auto generated."""
  id: FindOperatorDto

  """Name of the user identity card type."""
  name: FindOperatorDto

  """Description of the user identity card type."""
  desc: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user identity cards for this user identity card type."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]
}

type IdentityCardTypeRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input IdentityCardTypeSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [IdentityCardTypeSoftDeleteInputWhere!]
}

input IdentityCardTypeSoftDeleteInputWhere {
  """Unique ID of the user identity card type, auto generated."""
  id: FindOperatorDto

  """Name of the user identity card type."""
  name: FindOperatorDto

  """Description of the user identity card type."""
  desc: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user identity cards for this user identity card type."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]
}

type IdentityCardTypeSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input IdentityCardTypeSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [IdentityCardTypeSoftRemoveInputWhere!]
}

input IdentityCardTypeSoftRemoveInputWhere {
  """Unique ID of the user identity card type, auto generated."""
  id: FindOperatorDto

  """Name of the user identity card type."""
  name: FindOperatorDto

  """Description of the user identity card type."""
  desc: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user identity cards for this user identity card type."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]
}

type IdentityCardTypeSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [IdentityCardTypeEntity!]!
}

input IdentityCardTypeUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [IdentityCardTypeUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: IdentityCardTypeUpdateInputSets!
}

input IdentityCardTypeUpdateInputSets {
  """Name of the user identity card type."""
  name: String

  """Description of the user identity card type."""
  desc: String
}

input IdentityCardTypeUpdateInputWhere {
  """Unique ID of the user identity card type, auto generated."""
  id: FindOperatorDto

  """Name of the user identity card type."""
  name: FindOperatorDto

  """Description of the user identity card type."""
  desc: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of user identity cards for this user identity card type."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]
}

type IdentityCardTypeUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [IdentityCardTypeEntity!]!
}

input IdentityCardTypeUpsertInput {
  """Name of the user identity card type."""
  name: String!

  """Description of the user identity card type."""
  desc: String

  """Unique ID of the user identity card type, auto generated. undefined"""
  id: Int
}

type IdentityCardTypeUpsertOutput {
  """Unique ID of the user identity card type, auto generated."""
  id: Int

  """Name of the user identity card type."""
  name: String

  """Description of the user identity card type."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of user identity cards for this user identity card type."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""
A field whose value is either an IPv4 or IPv6 address: https://en.wikipedia.org/wiki/IP_address.
"""
scalar IP

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

"""
A field whose value is a JSON Web Token (JWT): https://jwt.io/introduction.
"""
scalar JWT

input LanguageCreateInput {
  """Name of language."""
  name: String!

  """ISO code of the language."""
  iso_code: String

  """Latitude of the language."""
  latitude: Float

  """Longitude of the language."""
  longitude: Float

  """Macroarea of the language."""
  macroarea: String
}

type LanguageCreateOutput {
  """Unique ID of the language, auto generated."""
  id: Int

  """Name of language."""
  name: String

  """ISO code of the language."""
  iso_code: String

  """Latitude of the language."""
  latitude: Float

  """Longitude of the language."""
  longitude: Float

  """Macroarea of the language."""
  macroarea: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """country language information."""
  fr_country_languagies: [CountryLanguageEntity!]
}

input LanguageDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LanguageDeleteInputWhere!]
}

input LanguageDeleteInputWhere {
  """Unique ID of the language, auto generated."""
  id: FindOperatorDto

  """Name of language."""
  name: FindOperatorDto

  """ISO code of the language."""
  iso_code: FindOperatorDto

  """Latitude of the language."""
  latitude: FindOperatorDto

  """Longitude of the language."""
  longitude: FindOperatorDto

  """Macroarea of the language."""
  macroarea: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """country language information."""
  fr_country_languagies: [CountryLanguageFindInputWhere!]
}

type LanguageDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type LanguageEntity {
  """Unique ID of the language, auto generated."""
  id: Int

  """Name of language."""
  name: String

  """ISO code of the language."""
  iso_code: String

  """Latitude of the language."""
  latitude: Float

  """Longitude of the language."""
  longitude: Float

  """Macroarea of the language."""
  macroarea: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """country language information."""
  fr_country_languagies: [CountryLanguageEntity!]
}

input LanguageFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LanguageFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: LanguageFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: LanguageFindInputSortOrder
}

input LanguageFindInputGroupBy {
  name: Boolean
  iso_code: Boolean
  macroarea: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input LanguageFindInputSortOrder {
  id: RecordSortDirectionEnum

  """Name of language."""
  name: RecordSortDirectionEnum

  """ISO code of the language."""
  iso_code: RecordSortDirectionEnum

  """Macroarea of the language."""
  macroarea: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input LanguageFindInputWhere {
  """Unique ID of the language, auto generated."""
  id: FindOperatorDto

  """Name of language."""
  name: FindOperatorDto

  """ISO code of the language."""
  iso_code: FindOperatorDto

  """Latitude of the language."""
  latitude: FindOperatorDto

  """Longitude of the language."""
  longitude: FindOperatorDto

  """Macroarea of the language."""
  macroarea: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """country language information."""
  fr_country_languagies: [CountryLanguageFindInputWhere!]
}

input LanguageFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type LanguageFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [LanguageEntity!]!
}

input LanguageRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LanguageRecoverInputWhere!]
}

input LanguageRecoverInputWhere {
  """Unique ID of the language, auto generated."""
  id: FindOperatorDto

  """Name of language."""
  name: FindOperatorDto

  """ISO code of the language."""
  iso_code: FindOperatorDto

  """Latitude of the language."""
  latitude: FindOperatorDto

  """Longitude of the language."""
  longitude: FindOperatorDto

  """Macroarea of the language."""
  macroarea: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """country language information."""
  fr_country_languagies: [CountryLanguageFindInputWhere!]
}

type LanguageRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LanguageEntity!]!
}

input LanguageRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LanguageRemoveInputWhere!]
}

input LanguageRemoveInputWhere {
  """Unique ID of the language, auto generated."""
  id: FindOperatorDto

  """Name of language."""
  name: FindOperatorDto

  """ISO code of the language."""
  iso_code: FindOperatorDto

  """Latitude of the language."""
  latitude: FindOperatorDto

  """Longitude of the language."""
  longitude: FindOperatorDto

  """Macroarea of the language."""
  macroarea: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """country language information."""
  fr_country_languagies: [CountryLanguageFindInputWhere!]
}

type LanguageRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LanguageEntity!]!
}

input LanguageRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LanguageRestoreInputWhere!]
}

input LanguageRestoreInputWhere {
  """Unique ID of the language, auto generated."""
  id: FindOperatorDto

  """Name of language."""
  name: FindOperatorDto

  """ISO code of the language."""
  iso_code: FindOperatorDto

  """Latitude of the language."""
  latitude: FindOperatorDto

  """Longitude of the language."""
  longitude: FindOperatorDto

  """Macroarea of the language."""
  macroarea: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """country language information."""
  fr_country_languagies: [CountryLanguageFindInputWhere!]
}

type LanguageRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LanguageSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LanguageSoftDeleteInputWhere!]
}

input LanguageSoftDeleteInputWhere {
  """Unique ID of the language, auto generated."""
  id: FindOperatorDto

  """Name of language."""
  name: FindOperatorDto

  """ISO code of the language."""
  iso_code: FindOperatorDto

  """Latitude of the language."""
  latitude: FindOperatorDto

  """Longitude of the language."""
  longitude: FindOperatorDto

  """Macroarea of the language."""
  macroarea: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """country language information."""
  fr_country_languagies: [CountryLanguageFindInputWhere!]
}

type LanguageSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LanguageSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LanguageSoftRemoveInputWhere!]
}

input LanguageSoftRemoveInputWhere {
  """Unique ID of the language, auto generated."""
  id: FindOperatorDto

  """Name of language."""
  name: FindOperatorDto

  """ISO code of the language."""
  iso_code: FindOperatorDto

  """Latitude of the language."""
  latitude: FindOperatorDto

  """Longitude of the language."""
  longitude: FindOperatorDto

  """Macroarea of the language."""
  macroarea: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """country language information."""
  fr_country_languagies: [CountryLanguageFindInputWhere!]
}

type LanguageSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LanguageEntity!]!
}

input LanguageUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LanguageUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: LanguageUpdateInputSets!
}

input LanguageUpdateInputSets {
  """Name of language."""
  name: String

  """ISO code of the language."""
  iso_code: String

  """Latitude of the language."""
  latitude: Float

  """Longitude of the language."""
  longitude: Float

  """Macroarea of the language."""
  macroarea: String
}

input LanguageUpdateInputWhere {
  """Unique ID of the language, auto generated."""
  id: FindOperatorDto

  """Name of language."""
  name: FindOperatorDto

  """ISO code of the language."""
  iso_code: FindOperatorDto

  """Latitude of the language."""
  latitude: FindOperatorDto

  """Longitude of the language."""
  longitude: FindOperatorDto

  """Macroarea of the language."""
  macroarea: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """country language information."""
  fr_country_languagies: [CountryLanguageFindInputWhere!]
}

type LanguageUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [LanguageEntity!]!
}

input LanguageUpsertInput {
  """Name of language."""
  name: String!

  """ISO code of the language."""
  iso_code: String

  """Latitude of the language."""
  latitude: Float

  """Longitude of the language."""
  longitude: Float

  """Macroarea of the language."""
  macroarea: String

  """Unique ID of the language, auto generated. undefined"""
  id: Int
}

type LanguageUpsertOutput {
  """Unique ID of the language, auto generated."""
  id: Int

  """Name of language."""
  name: String

  """ISO code of the language."""
  iso_code: String

  """Latitude of the language."""
  latitude: Float

  """Longitude of the language."""
  longitude: Float

  """Macroarea of the language."""
  macroarea: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """country language information."""
  fr_country_languagies: [CountryLanguageEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input LeadCreateInput {
  """From user id of the lead."""
  from_u_id: Int

  """To user id of the lead."""
  to_u_id: Int

  """Reference id of the lead."""
  ref_id: String!

  """Reference type of the lead."""
  ref_type: String!

  """Concern issue of the lead."""
  concern_issue: String

  """Preferred contact method of the lead."""
  preferred_contact_method: String

  """Subject of the lead."""
  subject: String!

  """Comment of the lead."""
  comment: String

  """Initial findings of the lead."""
  initial_findings: String

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: DateTime
}

type LeadCreateOutput {
  """Unique ID of the lead, auto generated."""
  id: Int

  """From user id of the lead."""
  from_u_id: Int

  """To user id of the lead."""
  to_u_id: Int

  """Reference id of the lead."""
  ref_id: String

  """Reference type of the lead."""
  ref_type: String

  """Concern issue of the lead."""
  concern_issue: String

  """Preferred contact method of the lead."""
  preferred_contact_method: String

  """Subject of the lead."""
  subject: String

  """Comment of the lead."""
  comment: String

  """Initial findings of the lead."""
  initial_findings: String

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the lead."""
  fr_from_user: UserEntity

  """To user of the lead."""
  fr_to_user: UserEntity

  """Lead source of the lead."""
  fr_lead_followups: [LeadFollowupEntity!]
}

input LeadDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadDeleteInputWhere!]
}

input LeadDeleteInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """From user id of the lead."""
  from_u_id: FindOperatorDto

  """To user id of the lead."""
  to_u_id: FindOperatorDto

  """Reference id of the lead."""
  ref_id: FindOperatorDto

  """Reference type of the lead."""
  ref_type: FindOperatorDto

  """Subject of the lead."""
  subject: FindOperatorDto

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the lead."""
  fr_from_user: [UserFindInputWhere!]

  """To user of the lead."""
  fr_to_user: [UserFindInputWhere!]

  """Lead source of the lead."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type LeadEntity {
  """Unique ID of the lead, auto generated."""
  id: Int

  """From user id of the lead."""
  from_u_id: Int

  """To user id of the lead."""
  to_u_id: Int

  """Reference id of the lead."""
  ref_id: String

  """Reference type of the lead."""
  ref_type: String

  """Concern issue of the lead."""
  concern_issue: String

  """Preferred contact method of the lead."""
  preferred_contact_method: String

  """Subject of the lead."""
  subject: String

  """Comment of the lead."""
  comment: String

  """Initial findings of the lead."""
  initial_findings: String

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the lead."""
  fr_from_user: UserEntity

  """To user of the lead."""
  fr_to_user: UserEntity

  """Lead source of the lead."""
  fr_lead_followups: [LeadFollowupEntity!]
}

input LeadFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: LeadFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: LeadFindInputSortOrder
}

input LeadFindInputGroupBy {
  from_u_id: Boolean
  to_u_id: Boolean
  ref_id: Boolean
  ref_type: Boolean
  subject: Boolean
  first_incoming_message_dt: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input LeadFindInputSortOrder {
  id: RecordSortDirectionEnum
  from_u_id: RecordSortDirectionEnum
  to_u_id: RecordSortDirectionEnum
  ref_id: RecordSortDirectionEnum
  ref_type: RecordSortDirectionEnum
  subject: RecordSortDirectionEnum
  first_incoming_message_dt: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input LeadFindInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """From user id of the lead."""
  from_u_id: FindOperatorDto

  """To user id of the lead."""
  to_u_id: FindOperatorDto

  """Reference id of the lead."""
  ref_id: FindOperatorDto

  """Reference type of the lead."""
  ref_type: FindOperatorDto

  """Subject of the lead."""
  subject: FindOperatorDto

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the lead."""
  fr_from_user: [UserFindInputWhere!]

  """To user of the lead."""
  fr_to_user: [UserFindInputWhere!]

  """Lead source of the lead."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

input LeadFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type LeadFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [LeadEntity!]!
}

input LeadFollowupCreateInput {
  """Lead of the lead followup."""
  lead_id: Int!

  """User id of the lead followup."""
  u_id: Int!

  """Lead potential of the lead followup."""
  leadpot_id: Int

  """Lead follow up status id of the lead followup."""
  leadfst_id: Int!

  """Type of the lead followup."""
  leadfupvia_id: Int!

  """Note of the lead followup."""
  note: String!

  """Competitor note of the lead followup."""
  competitor_note: String!

  """Next followup date of the lead followup."""
  next_followup: DateTime
}

type LeadFollowupCreateOutput {
  """Unique ID of the lead, auto generated."""
  id: Int

  """Lead of the lead followup."""
  lead_id: Int

  """User id of the lead followup."""
  u_id: Int

  """Lead potential of the lead followup."""
  leadpot_id: Int

  """Lead follow up status id of the lead followup."""
  leadfst_id: Int

  """Type of the lead followup."""
  leadfupvia_id: Int

  """Note of the lead followup."""
  note: String

  """Competitor note of the lead followup."""
  competitor_note: String

  """Next followup date of the lead followup."""
  next_followup: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead of the lead followup."""
  fr_leads: LeadEntity

  """User of the lead followup."""
  fr_user: UserEntity

  """Followup status of the lead followup."""
  fr_lead_followupsts: LeadFollowupStatusEntity

  """Followup via of the lead followup."""
  fr_lead_followup_via: LeadFollowupViaEntity

  """Potential of the lead followup."""
  fr_lead_potential: LeadPotentialEntity
}

input LeadFollowupDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupDeleteInputWhere!]
}

input LeadFollowupDeleteInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Lead of the lead followup."""
  lead_id: FindOperatorDto

  """User id of the lead followup."""
  u_id: FindOperatorDto

  """Lead potential of the lead followup."""
  leadpot_id: FindOperatorDto

  """Lead follow up status id of the lead followup."""
  leadfst_id: FindOperatorDto

  """Type of the lead followup."""
  leadfupvia_id: FindOperatorDto

  """Next followup date of the lead followup."""
  next_followup: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead of the lead followup."""
  fr_leads: [LeadFindInputWhere!]

  """User of the lead followup."""
  fr_user: [UserFindInputWhere!]

  """Followup status of the lead followup."""
  fr_lead_followupsts: [LeadFollowupStatusFindInputWhere!]

  """Followup via of the lead followup."""
  fr_lead_followup_via: [LeadFollowupViaFindInputWhere!]

  """Potential of the lead followup."""
  fr_lead_potential: [LeadPotentialFindInputWhere!]
}

type LeadFollowupDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type LeadFollowupEntity {
  """Unique ID of the lead, auto generated."""
  id: Int

  """Lead of the lead followup."""
  lead_id: Int

  """User id of the lead followup."""
  u_id: Int

  """Lead potential of the lead followup."""
  leadpot_id: Int

  """Lead follow up status id of the lead followup."""
  leadfst_id: Int

  """Type of the lead followup."""
  leadfupvia_id: Int

  """Note of the lead followup."""
  note: String

  """Competitor note of the lead followup."""
  competitor_note: String

  """Next followup date of the lead followup."""
  next_followup: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead of the lead followup."""
  fr_leads: LeadEntity

  """User of the lead followup."""
  fr_user: UserEntity

  """Followup status of the lead followup."""
  fr_lead_followupsts: LeadFollowupStatusEntity

  """Followup via of the lead followup."""
  fr_lead_followup_via: LeadFollowupViaEntity

  """Potential of the lead followup."""
  fr_lead_potential: LeadPotentialEntity
}

input LeadFollowupFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: LeadFollowupFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: LeadFollowupFindInputSortOrder
}

input LeadFollowupFindInputGroupBy {
  lead_id: Boolean
  u_id: Boolean
  leadpot_id: Boolean
  leadfst_id: Boolean
  leadfupvia_id: Boolean
  next_followup: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input LeadFollowupFindInputSortOrder {
  id: RecordSortDirectionEnum
  lead_id: RecordSortDirectionEnum
  u_id: RecordSortDirectionEnum
  leadfst_id: RecordSortDirectionEnum
  leadpot_id: RecordSortDirectionEnum
  leadfupvia_id: RecordSortDirectionEnum
  next_followup: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input LeadFollowupFindInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Lead of the lead followup."""
  lead_id: FindOperatorDto

  """User id of the lead followup."""
  u_id: FindOperatorDto

  """Lead potential of the lead followup."""
  leadpot_id: FindOperatorDto

  """Lead follow up status id of the lead followup."""
  leadfst_id: FindOperatorDto

  """Type of the lead followup."""
  leadfupvia_id: FindOperatorDto

  """Next followup date of the lead followup."""
  next_followup: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead of the lead followup."""
  fr_leads: [LeadFindInputWhere!]

  """User of the lead followup."""
  fr_user: [UserFindInputWhere!]

  """Followup status of the lead followup."""
  fr_lead_followupsts: [LeadFollowupStatusFindInputWhere!]

  """Followup via of the lead followup."""
  fr_lead_followup_via: [LeadFollowupViaFindInputWhere!]

  """Potential of the lead followup."""
  fr_lead_potential: [LeadPotentialFindInputWhere!]
}

input LeadFollowupFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type LeadFollowupFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [LeadFollowupEntity!]!
}

input LeadFollowupRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupRecoverInputWhere!]
}

input LeadFollowupRecoverInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Lead of the lead followup."""
  lead_id: FindOperatorDto

  """User id of the lead followup."""
  u_id: FindOperatorDto

  """Lead potential of the lead followup."""
  leadpot_id: FindOperatorDto

  """Lead follow up status id of the lead followup."""
  leadfst_id: FindOperatorDto

  """Type of the lead followup."""
  leadfupvia_id: FindOperatorDto

  """Next followup date of the lead followup."""
  next_followup: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead of the lead followup."""
  fr_leads: [LeadFindInputWhere!]

  """User of the lead followup."""
  fr_user: [UserFindInputWhere!]

  """Followup status of the lead followup."""
  fr_lead_followupsts: [LeadFollowupStatusFindInputWhere!]

  """Followup via of the lead followup."""
  fr_lead_followup_via: [LeadFollowupViaFindInputWhere!]

  """Potential of the lead followup."""
  fr_lead_potential: [LeadPotentialFindInputWhere!]
}

type LeadFollowupRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadFollowupEntity!]!
}

input LeadFollowupRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupRemoveInputWhere!]
}

input LeadFollowupRemoveInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Lead of the lead followup."""
  lead_id: FindOperatorDto

  """User id of the lead followup."""
  u_id: FindOperatorDto

  """Lead potential of the lead followup."""
  leadpot_id: FindOperatorDto

  """Lead follow up status id of the lead followup."""
  leadfst_id: FindOperatorDto

  """Type of the lead followup."""
  leadfupvia_id: FindOperatorDto

  """Next followup date of the lead followup."""
  next_followup: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead of the lead followup."""
  fr_leads: [LeadFindInputWhere!]

  """User of the lead followup."""
  fr_user: [UserFindInputWhere!]

  """Followup status of the lead followup."""
  fr_lead_followupsts: [LeadFollowupStatusFindInputWhere!]

  """Followup via of the lead followup."""
  fr_lead_followup_via: [LeadFollowupViaFindInputWhere!]

  """Potential of the lead followup."""
  fr_lead_potential: [LeadPotentialFindInputWhere!]
}

type LeadFollowupRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadFollowupEntity!]!
}

input LeadFollowupRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupRestoreInputWhere!]
}

input LeadFollowupRestoreInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Lead of the lead followup."""
  lead_id: FindOperatorDto

  """User id of the lead followup."""
  u_id: FindOperatorDto

  """Lead potential of the lead followup."""
  leadpot_id: FindOperatorDto

  """Lead follow up status id of the lead followup."""
  leadfst_id: FindOperatorDto

  """Type of the lead followup."""
  leadfupvia_id: FindOperatorDto

  """Next followup date of the lead followup."""
  next_followup: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead of the lead followup."""
  fr_leads: [LeadFindInputWhere!]

  """User of the lead followup."""
  fr_user: [UserFindInputWhere!]

  """Followup status of the lead followup."""
  fr_lead_followupsts: [LeadFollowupStatusFindInputWhere!]

  """Followup via of the lead followup."""
  fr_lead_followup_via: [LeadFollowupViaFindInputWhere!]

  """Potential of the lead followup."""
  fr_lead_potential: [LeadPotentialFindInputWhere!]
}

type LeadFollowupRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LeadFollowupSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupSoftDeleteInputWhere!]
}

input LeadFollowupSoftDeleteInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Lead of the lead followup."""
  lead_id: FindOperatorDto

  """User id of the lead followup."""
  u_id: FindOperatorDto

  """Lead potential of the lead followup."""
  leadpot_id: FindOperatorDto

  """Lead follow up status id of the lead followup."""
  leadfst_id: FindOperatorDto

  """Type of the lead followup."""
  leadfupvia_id: FindOperatorDto

  """Next followup date of the lead followup."""
  next_followup: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead of the lead followup."""
  fr_leads: [LeadFindInputWhere!]

  """User of the lead followup."""
  fr_user: [UserFindInputWhere!]

  """Followup status of the lead followup."""
  fr_lead_followupsts: [LeadFollowupStatusFindInputWhere!]

  """Followup via of the lead followup."""
  fr_lead_followup_via: [LeadFollowupViaFindInputWhere!]

  """Potential of the lead followup."""
  fr_lead_potential: [LeadPotentialFindInputWhere!]
}

type LeadFollowupSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LeadFollowupSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupSoftRemoveInputWhere!]
}

input LeadFollowupSoftRemoveInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Lead of the lead followup."""
  lead_id: FindOperatorDto

  """User id of the lead followup."""
  u_id: FindOperatorDto

  """Lead potential of the lead followup."""
  leadpot_id: FindOperatorDto

  """Lead follow up status id of the lead followup."""
  leadfst_id: FindOperatorDto

  """Type of the lead followup."""
  leadfupvia_id: FindOperatorDto

  """Next followup date of the lead followup."""
  next_followup: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead of the lead followup."""
  fr_leads: [LeadFindInputWhere!]

  """User of the lead followup."""
  fr_user: [UserFindInputWhere!]

  """Followup status of the lead followup."""
  fr_lead_followupsts: [LeadFollowupStatusFindInputWhere!]

  """Followup via of the lead followup."""
  fr_lead_followup_via: [LeadFollowupViaFindInputWhere!]

  """Potential of the lead followup."""
  fr_lead_potential: [LeadPotentialFindInputWhere!]
}

type LeadFollowupSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadFollowupEntity!]!
}

input LeadFollowupStatusCreateInput {
  """Title of the lead followup status."""
  title: String!

  """Description of the lead followup status."""
  desc: String
}

type LeadFollowupStatusCreateOutput {
  """Unique ID of the lead, auto generated."""
  id: Int

  """Title of the lead followup status."""
  title: String!

  """Description of the lead followup status."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead followup of the lead followup status."""
  fr_lead_followups_status: [LeadFollowupEntity!]
}

input LeadFollowupStatusDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupStatusDeleteInputWhere!]
}

input LeadFollowupStatusDeleteInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead followup status."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup status."""
  fr_lead_followups_status: [LeadFollowupFindInputWhere!]
}

type LeadFollowupStatusDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type LeadFollowupStatusEntity {
  """Unique ID of the lead, auto generated."""
  id: Int

  """Title of the lead followup status."""
  title: String!

  """Description of the lead followup status."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead followup of the lead followup status."""
  fr_lead_followups_status: [LeadFollowupEntity!]
}

input LeadFollowupStatusFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupStatusFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: LeadFollowupStatusFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: LeadFollowupStatusFindInputSortOrder
}

input LeadFollowupStatusFindInputGroupBy {
  title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input LeadFollowupStatusFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input LeadFollowupStatusFindInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead followup status."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup status."""
  fr_lead_followups_status: [LeadFollowupFindInputWhere!]
}

input LeadFollowupStatusFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type LeadFollowupStatusFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [LeadFollowupStatusEntity!]!
}

input LeadFollowupStatusRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupStatusRecoverInputWhere!]
}

input LeadFollowupStatusRecoverInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead followup status."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup status."""
  fr_lead_followups_status: [LeadFollowupFindInputWhere!]
}

type LeadFollowupStatusRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadFollowupStatusEntity!]!
}

input LeadFollowupStatusRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupStatusRemoveInputWhere!]
}

input LeadFollowupStatusRemoveInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead followup status."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup status."""
  fr_lead_followups_status: [LeadFollowupFindInputWhere!]
}

type LeadFollowupStatusRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadFollowupStatusEntity!]!
}

input LeadFollowupStatusRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupStatusRestoreInputWhere!]
}

input LeadFollowupStatusRestoreInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead followup status."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup status."""
  fr_lead_followups_status: [LeadFollowupFindInputWhere!]
}

type LeadFollowupStatusRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LeadFollowupStatusSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupStatusSoftDeleteInputWhere!]
}

input LeadFollowupStatusSoftDeleteInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead followup status."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup status."""
  fr_lead_followups_status: [LeadFollowupFindInputWhere!]
}

type LeadFollowupStatusSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LeadFollowupStatusSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupStatusSoftRemoveInputWhere!]
}

input LeadFollowupStatusSoftRemoveInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead followup status."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup status."""
  fr_lead_followups_status: [LeadFollowupFindInputWhere!]
}

type LeadFollowupStatusSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadFollowupStatusEntity!]!
}

input LeadFollowupStatusUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupStatusUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: LeadFollowupStatusUpdateInputSets!
}

input LeadFollowupStatusUpdateInputSets {
  """Title of the lead followup status."""
  title: String

  """Description of the lead followup status."""
  desc: String
}

input LeadFollowupStatusUpdateInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead followup status."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup status."""
  fr_lead_followups_status: [LeadFollowupFindInputWhere!]
}

type LeadFollowupStatusUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [LeadFollowupStatusEntity!]!
}

input LeadFollowupStatusUpsertInput {
  """Title of the lead followup status."""
  title: String!

  """Description of the lead followup status."""
  desc: String

  """Unique ID of the lead, auto generated. undefined"""
  id: Int
}

type LeadFollowupStatusUpsertOutput {
  """Unique ID of the lead, auto generated."""
  id: Int

  """Title of the lead followup status."""
  title: String!

  """Description of the lead followup status."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead followup of the lead followup status."""
  fr_lead_followups_status: [LeadFollowupEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input LeadFollowupUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: LeadFollowupUpdateInputSets!
}

input LeadFollowupUpdateInputSets {
  """Lead of the lead followup."""
  lead_id: Int

  """User id of the lead followup."""
  u_id: Int

  """Lead potential of the lead followup."""
  leadpot_id: Int

  """Lead follow up status id of the lead followup."""
  leadfst_id: Int

  """Type of the lead followup."""
  leadfupvia_id: Int

  """Note of the lead followup."""
  note: String

  """Competitor note of the lead followup."""
  competitor_note: String

  """Next followup date of the lead followup."""
  next_followup: DateTime
}

input LeadFollowupUpdateInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Lead of the lead followup."""
  lead_id: FindOperatorDto

  """User id of the lead followup."""
  u_id: FindOperatorDto

  """Lead potential of the lead followup."""
  leadpot_id: FindOperatorDto

  """Lead follow up status id of the lead followup."""
  leadfst_id: FindOperatorDto

  """Type of the lead followup."""
  leadfupvia_id: FindOperatorDto

  """Next followup date of the lead followup."""
  next_followup: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead of the lead followup."""
  fr_leads: [LeadFindInputWhere!]

  """User of the lead followup."""
  fr_user: [UserFindInputWhere!]

  """Followup status of the lead followup."""
  fr_lead_followupsts: [LeadFollowupStatusFindInputWhere!]

  """Followup via of the lead followup."""
  fr_lead_followup_via: [LeadFollowupViaFindInputWhere!]

  """Potential of the lead followup."""
  fr_lead_potential: [LeadPotentialFindInputWhere!]
}

type LeadFollowupUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [LeadFollowupEntity!]!
}

input LeadFollowupUpsertInput {
  """Lead of the lead followup."""
  lead_id: Int!

  """User id of the lead followup."""
  u_id: Int!

  """Lead potential of the lead followup."""
  leadpot_id: Int

  """Lead follow up status id of the lead followup."""
  leadfst_id: Int!

  """Type of the lead followup."""
  leadfupvia_id: Int!

  """Note of the lead followup."""
  note: String!

  """Competitor note of the lead followup."""
  competitor_note: String!

  """Next followup date of the lead followup."""
  next_followup: DateTime

  """Unique ID of the lead, auto generated. undefined"""
  id: Int
}

type LeadFollowupUpsertOutput {
  """Unique ID of the lead, auto generated."""
  id: Int

  """Lead of the lead followup."""
  lead_id: Int

  """User id of the lead followup."""
  u_id: Int

  """Lead potential of the lead followup."""
  leadpot_id: Int

  """Lead follow up status id of the lead followup."""
  leadfst_id: Int

  """Type of the lead followup."""
  leadfupvia_id: Int

  """Note of the lead followup."""
  note: String

  """Competitor note of the lead followup."""
  competitor_note: String

  """Next followup date of the lead followup."""
  next_followup: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead of the lead followup."""
  fr_leads: LeadEntity

  """User of the lead followup."""
  fr_user: UserEntity

  """Followup status of the lead followup."""
  fr_lead_followupsts: LeadFollowupStatusEntity

  """Followup via of the lead followup."""
  fr_lead_followup_via: LeadFollowupViaEntity

  """Potential of the lead followup."""
  fr_lead_potential: LeadPotentialEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input LeadFollowupViaCreateInput {
  """Title of the email template."""
  title: String!

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime
}

type LeadFollowupViaCreateOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead followup of the lead followup via."""
  fr_lead_followups: [LeadFollowupEntity!]
}

input LeadFollowupViaDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupViaDeleteInputWhere!]
}

input LeadFollowupViaDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Description of the email template."""
  desc: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup via."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadFollowupViaDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type LeadFollowupViaEntity {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead followup of the lead followup via."""
  fr_lead_followups: [LeadFollowupEntity!]
}

input LeadFollowupViaFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupViaFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: LeadFollowupViaFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: LeadFollowupViaFindInputSortOrder
}

input LeadFollowupViaFindInputGroupBy {
  title: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input LeadFollowupViaFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input LeadFollowupViaFindInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Description of the email template."""
  desc: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup via."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

input LeadFollowupViaFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type LeadFollowupViaFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [LeadFollowupViaEntity!]!
}

input LeadFollowupViaRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupViaRecoverInputWhere!]
}

input LeadFollowupViaRecoverInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Description of the email template."""
  desc: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup via."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadFollowupViaRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadFollowupViaEntity!]!
}

input LeadFollowupViaRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupViaRemoveInputWhere!]
}

input LeadFollowupViaRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Description of the email template."""
  desc: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup via."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadFollowupViaRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadFollowupViaEntity!]!
}

input LeadFollowupViaRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupViaRestoreInputWhere!]
}

input LeadFollowupViaRestoreInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Description of the email template."""
  desc: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup via."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadFollowupViaRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LeadFollowupViaSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupViaSoftDeleteInputWhere!]
}

input LeadFollowupViaSoftDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Description of the email template."""
  desc: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup via."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadFollowupViaSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LeadFollowupViaSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupViaSoftRemoveInputWhere!]
}

input LeadFollowupViaSoftRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Description of the email template."""
  desc: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup via."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadFollowupViaSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadFollowupViaEntity!]!
}

input LeadFollowupViaUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadFollowupViaUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: LeadFollowupViaUpdateInputSets!
}

input LeadFollowupViaUpdateInputSets {
  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime
}

input LeadFollowupViaUpdateInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Description of the email template."""
  desc: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Lead followup of the lead followup via."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadFollowupViaUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [LeadFollowupViaEntity!]!
}

input LeadFollowupViaUpsertInput {
  """Title of the email template."""
  title: String!

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """Unique ID of the email template, auto generated. undefined"""
  id: Int
}

type LeadFollowupViaUpsertOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead followup of the lead followup via."""
  fr_lead_followups: [LeadFollowupEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input LeadPotentialCreateInput {
  """Title of the lead potential."""
  title: String!

  """Description of the lead potential."""
  desc: String
}

type LeadPotentialCreateOutput {
  """Unique ID of the lead, auto generated."""
  id: Int

  """Title of the lead potential."""
  title: String!

  """Description of the lead potential."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead followup of the lead potential."""
  fr_lead_followup: [LeadFollowupEntity!]
}

input LeadPotentialDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadPotentialDeleteInputWhere!]
}

input LeadPotentialDeleteInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead potential."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type LeadPotentialDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type LeadPotentialEntity {
  """Unique ID of the lead, auto generated."""
  id: Int

  """Title of the lead potential."""
  title: String!

  """Description of the lead potential."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead followup of the lead potential."""
  fr_lead_followup: [LeadFollowupEntity!]
}

input LeadPotentialFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadPotentialFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: LeadPotentialFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: LeadPotentialFindInputSortOrder
}

input LeadPotentialFindInputGroupBy {
  title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input LeadPotentialFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input LeadPotentialFindInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead potential."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

input LeadPotentialFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type LeadPotentialFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [LeadPotentialEntity!]!
}

input LeadPotentialRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadPotentialRecoverInputWhere!]
}

input LeadPotentialRecoverInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead potential."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type LeadPotentialRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadPotentialEntity!]!
}

input LeadPotentialRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadPotentialRemoveInputWhere!]
}

input LeadPotentialRemoveInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead potential."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type LeadPotentialRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadPotentialEntity!]!
}

input LeadPotentialRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadPotentialRestoreInputWhere!]
}

input LeadPotentialRestoreInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead potential."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type LeadPotentialRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LeadPotentialSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadPotentialSoftDeleteInputWhere!]
}

input LeadPotentialSoftDeleteInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead potential."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type LeadPotentialSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LeadPotentialSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadPotentialSoftRemoveInputWhere!]
}

input LeadPotentialSoftRemoveInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead potential."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type LeadPotentialSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadPotentialEntity!]!
}

input LeadPotentialUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadPotentialUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: LeadPotentialUpdateInputSets!
}

input LeadPotentialUpdateInputSets {
  """Title of the lead potential."""
  title: String

  """Description of the lead potential."""
  desc: String
}

input LeadPotentialUpdateInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """Title of the lead potential."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type LeadPotentialUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [LeadPotentialEntity!]!
}

input LeadPotentialUpsertInput {
  """Title of the lead potential."""
  title: String!

  """Description of the lead potential."""
  desc: String

  """Unique ID of the lead, auto generated. undefined"""
  id: Int
}

type LeadPotentialUpsertOutput {
  """Unique ID of the lead, auto generated."""
  id: Int

  """Title of the lead potential."""
  title: String!

  """Description of the lead potential."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Lead followup of the lead potential."""
  fr_lead_followup: [LeadFollowupEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input LeadRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadRecoverInputWhere!]
}

input LeadRecoverInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """From user id of the lead."""
  from_u_id: FindOperatorDto

  """To user id of the lead."""
  to_u_id: FindOperatorDto

  """Reference id of the lead."""
  ref_id: FindOperatorDto

  """Reference type of the lead."""
  ref_type: FindOperatorDto

  """Subject of the lead."""
  subject: FindOperatorDto

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the lead."""
  fr_from_user: [UserFindInputWhere!]

  """To user of the lead."""
  fr_to_user: [UserFindInputWhere!]

  """Lead source of the lead."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadEntity!]!
}

input LeadRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadRemoveInputWhere!]
}

input LeadRemoveInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """From user id of the lead."""
  from_u_id: FindOperatorDto

  """To user id of the lead."""
  to_u_id: FindOperatorDto

  """Reference id of the lead."""
  ref_id: FindOperatorDto

  """Reference type of the lead."""
  ref_type: FindOperatorDto

  """Subject of the lead."""
  subject: FindOperatorDto

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the lead."""
  fr_from_user: [UserFindInputWhere!]

  """To user of the lead."""
  fr_to_user: [UserFindInputWhere!]

  """Lead source of the lead."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadEntity!]!
}

input LeadRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadRestoreInputWhere!]
}

input LeadRestoreInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """From user id of the lead."""
  from_u_id: FindOperatorDto

  """To user id of the lead."""
  to_u_id: FindOperatorDto

  """Reference id of the lead."""
  ref_id: FindOperatorDto

  """Reference type of the lead."""
  ref_type: FindOperatorDto

  """Subject of the lead."""
  subject: FindOperatorDto

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the lead."""
  fr_from_user: [UserFindInputWhere!]

  """To user of the lead."""
  fr_to_user: [UserFindInputWhere!]

  """Lead source of the lead."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LeadSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadSoftDeleteInputWhere!]
}

input LeadSoftDeleteInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """From user id of the lead."""
  from_u_id: FindOperatorDto

  """To user id of the lead."""
  to_u_id: FindOperatorDto

  """Reference id of the lead."""
  ref_id: FindOperatorDto

  """Reference type of the lead."""
  ref_type: FindOperatorDto

  """Subject of the lead."""
  subject: FindOperatorDto

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the lead."""
  fr_from_user: [UserFindInputWhere!]

  """To user of the lead."""
  fr_to_user: [UserFindInputWhere!]

  """Lead source of the lead."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input LeadSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadSoftRemoveInputWhere!]
}

input LeadSoftRemoveInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """From user id of the lead."""
  from_u_id: FindOperatorDto

  """To user id of the lead."""
  to_u_id: FindOperatorDto

  """Reference id of the lead."""
  ref_id: FindOperatorDto

  """Reference type of the lead."""
  ref_type: FindOperatorDto

  """Subject of the lead."""
  subject: FindOperatorDto

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the lead."""
  fr_from_user: [UserFindInputWhere!]

  """To user of the lead."""
  fr_to_user: [UserFindInputWhere!]

  """Lead source of the lead."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [LeadEntity!]!
}

input LeadUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [LeadUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: LeadUpdateInputSets!
}

input LeadUpdateInputSets {
  """From user id of the lead."""
  from_u_id: Int

  """To user id of the lead."""
  to_u_id: Int

  """Reference id of the lead."""
  ref_id: String

  """Reference type of the lead."""
  ref_type: String

  """Concern issue of the lead."""
  concern_issue: String

  """Preferred contact method of the lead."""
  preferred_contact_method: String

  """Subject of the lead."""
  subject: String

  """Comment of the lead."""
  comment: String

  """Initial findings of the lead."""
  initial_findings: String

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: DateTime
}

input LeadUpdateInputWhere {
  """Unique ID of the lead, auto generated."""
  id: FindOperatorDto

  """From user id of the lead."""
  from_u_id: FindOperatorDto

  """To user id of the lead."""
  to_u_id: FindOperatorDto

  """Reference id of the lead."""
  ref_id: FindOperatorDto

  """Reference type of the lead."""
  ref_type: FindOperatorDto

  """Subject of the lead."""
  subject: FindOperatorDto

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the lead."""
  fr_from_user: [UserFindInputWhere!]

  """To user of the lead."""
  fr_to_user: [UserFindInputWhere!]

  """Lead source of the lead."""
  fr_lead_followups: [LeadFollowupFindInputWhere!]
}

type LeadUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [LeadEntity!]!
}

input LeadUpsertInput {
  """From user id of the lead."""
  from_u_id: Int

  """To user id of the lead."""
  to_u_id: Int

  """Reference id of the lead."""
  ref_id: String!

  """Reference type of the lead."""
  ref_type: String!

  """Concern issue of the lead."""
  concern_issue: String

  """Preferred contact method of the lead."""
  preferred_contact_method: String

  """Subject of the lead."""
  subject: String!

  """Comment of the lead."""
  comment: String

  """Initial findings of the lead."""
  initial_findings: String

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: DateTime

  """Unique ID of the lead, auto generated. undefined"""
  id: Int
}

type LeadUpsertOutput {
  """Unique ID of the lead, auto generated."""
  id: Int

  """From user id of the lead."""
  from_u_id: Int

  """To user id of the lead."""
  to_u_id: Int

  """Reference id of the lead."""
  ref_id: String

  """Reference type of the lead."""
  ref_type: String

  """Concern issue of the lead."""
  concern_issue: String

  """Preferred contact method of the lead."""
  preferred_contact_method: String

  """Subject of the lead."""
  subject: String

  """Comment of the lead."""
  comment: String

  """Initial findings of the lead."""
  initial_findings: String

  """The date and time when the first incoming message was received."""
  first_incoming_message_dt: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the lead."""
  fr_from_user: UserEntity

  """To user of the lead."""
  fr_to_user: UserEntity

  """Lead source of the lead."""
  fr_lead_followups: [LeadFollowupEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""
A field whose value is a IEEE 802 48-bit MAC address: https://en.wikipedia.org/wiki/MAC_address.
"""
scalar MAC

input MeasurementCategoryCreateInput {
  """Title of the email template."""
  title: String!

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime
}

type MeasurementCategoryCreateOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Categories of the Measurement."""
  fr_measurement_units: [MeasurementUnitEntity!]
}

input MeasurementCategoryDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementCategoryDeleteInputWhere!]
}

input MeasurementCategoryDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the Measurement."""
  fr_measurement_units: [MeasurementUnitFindInputWhere!]
}

type MeasurementCategoryDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type MeasurementCategoryEntity {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Categories of the Measurement."""
  fr_measurement_units: [MeasurementUnitEntity!]
}

input MeasurementCategoryFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementCategoryFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: MeasurementCategoryFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: MeasurementCategoryFindInputSortOrder
}

input MeasurementCategoryFindInputGroupBy {
  title: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input MeasurementCategoryFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input MeasurementCategoryFindInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the Measurement."""
  fr_measurement_units: [MeasurementUnitFindInputWhere!]
}

input MeasurementCategoryFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type MeasurementCategoryFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [MeasurementCategoryEntity!]!
}

input MeasurementCategoryRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementCategoryRecoverInputWhere!]
}

input MeasurementCategoryRecoverInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the Measurement."""
  fr_measurement_units: [MeasurementUnitFindInputWhere!]
}

type MeasurementCategoryRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [MeasurementCategoryEntity!]!
}

input MeasurementCategoryRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementCategoryRemoveInputWhere!]
}

input MeasurementCategoryRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the Measurement."""
  fr_measurement_units: [MeasurementUnitFindInputWhere!]
}

type MeasurementCategoryRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [MeasurementCategoryEntity!]!
}

input MeasurementCategoryRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementCategoryRestoreInputWhere!]
}

input MeasurementCategoryRestoreInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the Measurement."""
  fr_measurement_units: [MeasurementUnitFindInputWhere!]
}

type MeasurementCategoryRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input MeasurementCategorySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementCategorySoftDeleteInputWhere!]
}

input MeasurementCategorySoftDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the Measurement."""
  fr_measurement_units: [MeasurementUnitFindInputWhere!]
}

type MeasurementCategorySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input MeasurementCategorySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementCategorySoftRemoveInputWhere!]
}

input MeasurementCategorySoftRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the Measurement."""
  fr_measurement_units: [MeasurementUnitFindInputWhere!]
}

type MeasurementCategorySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [MeasurementCategoryEntity!]!
}

input MeasurementCategoryUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementCategoryUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: MeasurementCategoryUpdateInputSets!
}

input MeasurementCategoryUpdateInputSets {
  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime
}

input MeasurementCategoryUpdateInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories of the Measurement."""
  fr_measurement_units: [MeasurementUnitFindInputWhere!]
}

type MeasurementCategoryUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [MeasurementCategoryEntity!]!
}

input MeasurementCategoryUpsertInput {
  """Title of the email template."""
  title: String!

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """Unique ID of the email template, auto generated. undefined"""
  id: Int
}

type MeasurementCategoryUpsertOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Categories of the Measurement."""
  fr_measurement_units: [MeasurementUnitEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input MeasurementUnitCreateInput {
  """Measurement category of the measurement unit."""
  mcat_id: Int

  """Name of the measurement unit."""
  name: String!

  """Abbreviation of the measurement unit."""
  abbreviation: String!

  """Short description of the measurement unit."""
  short_desc: String!
}

type MeasurementUnitCreateOutput {
  """Unique ID of the measurement unit, auto generated."""
  id: Int

  """Measurement category of the measurement unit."""
  mcat_id: Int

  """Name of the measurement unit."""
  name: String

  """Abbreviation of the measurement unit."""
  abbreviation: String

  """Short description of the measurement unit."""
  short_desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Categories for this measurement."""
  fr_mu_category: MeasurementCategoryEntity
}

input MeasurementUnitDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementUnitDeleteInputWhere!]
}

input MeasurementUnitDeleteInputWhere {
  """Unique ID of the measurement unit, auto generated."""
  id: FindOperatorDto

  """Measurement category of the measurement unit."""
  mcat_id: FindOperatorDto

  """Name of the measurement unit."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories for this measurement."""
  fr_mu_category: [MeasurementCategoryFindInputWhere!]
}

type MeasurementUnitDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type MeasurementUnitEntity {
  """Unique ID of the measurement unit, auto generated."""
  id: Int

  """Measurement category of the measurement unit."""
  mcat_id: Int

  """Name of the measurement unit."""
  name: String

  """Abbreviation of the measurement unit."""
  abbreviation: String

  """Short description of the measurement unit."""
  short_desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Categories for this measurement."""
  fr_mu_category: MeasurementCategoryEntity
}

input MeasurementUnitFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementUnitFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: MeasurementUnitFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: MeasurementUnitFindInputSortOrder
}

input MeasurementUnitFindInputGroupBy {
  mcat_id: Boolean
  name: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input MeasurementUnitFindInputSortOrder {
  id: RecordSortDirectionEnum
  mcat_id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input MeasurementUnitFindInputWhere {
  """Unique ID of the measurement unit, auto generated."""
  id: FindOperatorDto

  """Measurement category of the measurement unit."""
  mcat_id: FindOperatorDto

  """Name of the measurement unit."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories for this measurement."""
  fr_mu_category: [MeasurementCategoryFindInputWhere!]
}

input MeasurementUnitFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type MeasurementUnitFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [MeasurementUnitEntity!]!
}

input MeasurementUnitRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementUnitRecoverInputWhere!]
}

input MeasurementUnitRecoverInputWhere {
  """Unique ID of the measurement unit, auto generated."""
  id: FindOperatorDto

  """Measurement category of the measurement unit."""
  mcat_id: FindOperatorDto

  """Name of the measurement unit."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories for this measurement."""
  fr_mu_category: [MeasurementCategoryFindInputWhere!]
}

type MeasurementUnitRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [MeasurementUnitEntity!]!
}

input MeasurementUnitRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementUnitRemoveInputWhere!]
}

input MeasurementUnitRemoveInputWhere {
  """Unique ID of the measurement unit, auto generated."""
  id: FindOperatorDto

  """Measurement category of the measurement unit."""
  mcat_id: FindOperatorDto

  """Name of the measurement unit."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories for this measurement."""
  fr_mu_category: [MeasurementCategoryFindInputWhere!]
}

type MeasurementUnitRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [MeasurementUnitEntity!]!
}

input MeasurementUnitRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementUnitRestoreInputWhere!]
}

input MeasurementUnitRestoreInputWhere {
  """Unique ID of the measurement unit, auto generated."""
  id: FindOperatorDto

  """Measurement category of the measurement unit."""
  mcat_id: FindOperatorDto

  """Name of the measurement unit."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories for this measurement."""
  fr_mu_category: [MeasurementCategoryFindInputWhere!]
}

type MeasurementUnitRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input MeasurementUnitSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementUnitSoftDeleteInputWhere!]
}

input MeasurementUnitSoftDeleteInputWhere {
  """Unique ID of the measurement unit, auto generated."""
  id: FindOperatorDto

  """Measurement category of the measurement unit."""
  mcat_id: FindOperatorDto

  """Name of the measurement unit."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories for this measurement."""
  fr_mu_category: [MeasurementCategoryFindInputWhere!]
}

type MeasurementUnitSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input MeasurementUnitSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementUnitSoftRemoveInputWhere!]
}

input MeasurementUnitSoftRemoveInputWhere {
  """Unique ID of the measurement unit, auto generated."""
  id: FindOperatorDto

  """Measurement category of the measurement unit."""
  mcat_id: FindOperatorDto

  """Name of the measurement unit."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories for this measurement."""
  fr_mu_category: [MeasurementCategoryFindInputWhere!]
}

type MeasurementUnitSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [MeasurementUnitEntity!]!
}

input MeasurementUnitUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [MeasurementUnitUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: MeasurementUnitUpdateInputSets!
}

input MeasurementUnitUpdateInputSets {
  """Measurement category of the measurement unit."""
  mcat_id: Int

  """Name of the measurement unit."""
  name: String

  """Abbreviation of the measurement unit."""
  abbreviation: String

  """Short description of the measurement unit."""
  short_desc: String
}

input MeasurementUnitUpdateInputWhere {
  """Unique ID of the measurement unit, auto generated."""
  id: FindOperatorDto

  """Measurement category of the measurement unit."""
  mcat_id: FindOperatorDto

  """Name of the measurement unit."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Categories for this measurement."""
  fr_mu_category: [MeasurementCategoryFindInputWhere!]
}

type MeasurementUnitUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [MeasurementUnitEntity!]!
}

input MeasurementUnitUpsertInput {
  """Measurement category of the measurement unit."""
  mcat_id: Int

  """Name of the measurement unit."""
  name: String!

  """Abbreviation of the measurement unit."""
  abbreviation: String!

  """Short description of the measurement unit."""
  short_desc: String!

  """Unique ID of the measurement unit, auto generated. undefined"""
  id: Int
}

type MeasurementUnitUpsertOutput {
  """Unique ID of the measurement unit, auto generated."""
  id: Int

  """Measurement category of the measurement unit."""
  mcat_id: Int

  """Name of the measurement unit."""
  name: String

  """Abbreviation of the measurement unit."""
  abbreviation: String

  """Short description of the measurement unit."""
  short_desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Categories for this measurement."""
  fr_mu_category: MeasurementCategoryEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

type Mutation {
  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingOpenHouseCreate(input: [RetsListingOpenHouseCreateInput!]!): [RetsListingOpenHouseCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsListingOpenHouseUpdate(input: RetsListingOpenHouseUpdateInput!): RetsListingOpenHouseUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsListingOpenHouseSoftDelete(input: RetsListingOpenHouseSoftDeleteInput!): RetsListingOpenHouseSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsListingOpenHouseDelete(input: RetsListingOpenHouseDeleteInput!): RetsListingOpenHouseDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsListingOpenHouseRestore(input: RetsListingOpenHouseRestoreInput!): RetsListingOpenHouseRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingOpenHouseUpsert(input: [RetsListingOpenHouseUpsertInput!]!): [RetsListingOpenHouseUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsListingOpenHouseSoftRemove(input: RetsListingOpenHouseSoftRemoveInput!): RetsListingOpenHouseSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingOpenHouseRemove(input: RetsListingOpenHouseRemoveInput!): RetsListingOpenHouseRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingOpenHouseRecover(input: RetsListingOpenHouseRecoverInput!): RetsListingOpenHouseRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingCreate(input: [RetsListingCreateInput!]!): [RetsListingCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsListingUpdate(input: RetsListingUpdateInput!): RetsListingUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsListingSoftDelete(input: RetsListingSoftDeleteInput!): RetsListingSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsListingDelete(input: RetsListingDeleteInput!): RetsListingDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsListingRestore(input: RetsListingRestoreInput!): RetsListingRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingUpsert(input: [RetsListingUpsertInput!]!): [RetsListingUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsListingSoftRemove(input: RetsListingSoftRemoveInput!): RetsListingSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingRemove(input: RetsListingRemoveInput!): RetsListingRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingRecover(input: RetsListingRecoverInput!): RetsListingRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingAdditionalInfoCreate(input: [RetsListingAdditionalInfoCreateInput!]!): [RetsListingAdditionalInfoCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsListingAdditionalInfoUpdate(input: RetsListingAdditionalInfoUpdateInput!): RetsListingAdditionalInfoUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsListingAdditionalInfoSoftDelete(input: RetsListingAdditionalInfoSoftDeleteInput!): RetsListingAdditionalInfoSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsListingAdditionalInfoDelete(input: RetsListingAdditionalInfoDeleteInput!): RetsListingAdditionalInfoDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsListingAdditionalInfoRestore(input: RetsListingAdditionalInfoRestoreInput!): RetsListingAdditionalInfoRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingAdditionalInfoUpsert(input: [RetsListingAdditionalInfoUpsertInput!]!): [RetsListingAdditionalInfoUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsListingAdditionalInfoSoftRemove(input: RetsListingAdditionalInfoSoftRemoveInput!): RetsListingAdditionalInfoSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingAdditionalInfoRemove(input: RetsListingAdditionalInfoRemoveInput!): RetsListingAdditionalInfoRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingAdditionalInfoRecover(input: RetsListingAdditionalInfoRecoverInput!): RetsListingAdditionalInfoRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingAgentCreate(input: [RetsListingAgentCreateInput!]!): [RetsListingAgentCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsListingAgentUpdate(input: RetsListingAgentUpdateInput!): RetsListingAgentUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsListingAgentSoftDelete(input: RetsListingAgentSoftDeleteInput!): RetsListingAgentSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsListingAgentDelete(input: RetsListingAgentDeleteInput!): RetsListingAgentDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsListingAgentRestore(input: RetsListingAgentRestoreInput!): RetsListingAgentRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingAgentUpsert(input: [RetsListingAgentUpsertInput!]!): [RetsListingAgentUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsListingAgentSoftRemove(input: RetsListingAgentSoftRemoveInput!): RetsListingAgentSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingAgentRemove(input: RetsListingAgentRemoveInput!): RetsListingAgentRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingAgentRecover(input: RetsListingAgentRecoverInput!): RetsListingAgentRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingOfficeCreate(input: [RetsListingOfficeCreateInput!]!): [RetsListingOfficeCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsListingOfficeUpdate(input: RetsListingOfficeUpdateInput!): RetsListingOfficeUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsListingOfficeSoftDelete(input: RetsListingOfficeSoftDeleteInput!): RetsListingOfficeSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsListingOfficeDelete(input: RetsListingOfficeDeleteInput!): RetsListingOfficeDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsListingOfficeRestore(input: RetsListingOfficeRestoreInput!): RetsListingOfficeRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingOfficeUpsert(input: [RetsListingOfficeUpsertInput!]!): [RetsListingOfficeUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsListingOfficeSoftRemove(input: RetsListingOfficeSoftRemoveInput!): RetsListingOfficeSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingOfficeRemove(input: RetsListingOfficeRemoveInput!): RetsListingOfficeRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingOfficeRecover(input: RetsListingOfficeRecoverInput!): RetsListingOfficeRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingPhotosCreate(input: [RetsListingPhotosCreateInput!]!): [RetsListingPhotosCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsListingPhotosUpdate(input: RetsListingPhotosUpdateInput!): RetsListingPhotosUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsListingPhotosSoftDelete(input: RetsListingPhotosSoftDeleteInput!): RetsListingPhotosSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsListingPhotosDelete(input: RetsListingPhotosDeleteInput!): RetsListingPhotosDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsListingPhotosRestore(input: RetsListingPhotosRestoreInput!): RetsListingPhotosRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingPhotosUpsert(input: [RetsListingPhotosUpsertInput!]!): [RetsListingPhotosUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsListingPhotosSoftRemove(input: RetsListingPhotosSoftRemoveInput!): RetsListingPhotosSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingPhotosRemove(input: RetsListingPhotosRemoveInput!): RetsListingPhotosRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingPhotosRecover(input: RetsListingPhotosRecoverInput!): RetsListingPhotosRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingMetadataCreate(input: [RetsListingMetadataCreateInput!]!): [RetsListingMetadataCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsListingMetadataUpdate(input: RetsListingMetadataUpdateInput!): RetsListingMetadataUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsListingMetadataSoftDelete(input: RetsListingMetadataSoftDeleteInput!): RetsListingMetadataSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsListingMetadataDelete(input: RetsListingMetadataDeleteInput!): RetsListingMetadataDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsListingMetadataRestore(input: RetsListingMetadataRestoreInput!): RetsListingMetadataRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingMetadataUpsert(input: [RetsListingMetadataUpsertInput!]!): [RetsListingMetadataUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsListingMetadataSoftRemove(input: RetsListingMetadataSoftRemoveInput!): RetsListingMetadataSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingMetadataRemove(input: RetsListingMetadataRemoveInput!): RetsListingMetadataRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingMetadataRecover(input: RetsListingMetadataRecoverInput!): RetsListingMetadataRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingRoomCreate(input: [RetsListingRoomCreateInput!]!): [RetsListingRoomCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsListingRoomUpdate(input: RetsListingRoomUpdateInput!): RetsListingRoomUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsListingRoomSoftDelete(input: RetsListingRoomSoftDeleteInput!): RetsListingRoomSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsListingRoomDelete(input: RetsListingRoomDeleteInput!): RetsListingRoomDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsListingRoomRestore(input: RetsListingRoomRestoreInput!): RetsListingRoomRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingRoomUpsert(input: [RetsListingRoomUpsertInput!]!): [RetsListingRoomUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsListingRoomSoftRemove(input: RetsListingRoomSoftRemoveInput!): RetsListingRoomSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingRoomRemove(input: RetsListingRoomRemoveInput!): RetsListingRoomRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingRoomRecover(input: RetsListingRoomRecoverInput!): RetsListingRoomRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingUnitCreate(input: [RetsListingUnitCreateInput!]!): [RetsListingUnitCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsListingUnitUpdate(input: RetsListingUnitUpdateInput!): RetsListingUnitUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsListingUnitSoftDelete(input: RetsListingUnitSoftDeleteInput!): RetsListingUnitSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsListingUnitDelete(input: RetsListingUnitDeleteInput!): RetsListingUnitDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsListingUnitRestore(input: RetsListingUnitRestoreInput!): RetsListingUnitRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingUnitUpsert(input: [RetsListingUnitUpsertInput!]!): [RetsListingUnitUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsListingUnitSoftRemove(input: RetsListingUnitSoftRemoveInput!): RetsListingUnitSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingUnitRemove(input: RetsListingUnitRemoveInput!): RetsListingUnitRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingUnitRecover(input: RetsListingUnitRecoverInput!): RetsListingUnitRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingVirtualToursCreate(input: [RetsListingVirtualToursCreateInput!]!): [RetsListingVirtualToursCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsListingVirtualToursUpdate(input: RetsListingVirtualToursUpdateInput!): RetsListingVirtualToursUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsListingVirtualToursSoftDelete(input: RetsListingVirtualToursSoftDeleteInput!): RetsListingVirtualToursSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsListingVirtualToursDelete(input: RetsListingVirtualToursDeleteInput!): RetsListingVirtualToursDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsListingVirtualToursRestore(input: RetsListingVirtualToursRestoreInput!): RetsListingVirtualToursRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsListingVirtualToursUpsert(input: [RetsListingVirtualToursUpsertInput!]!): [RetsListingVirtualToursUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsListingVirtualToursSoftRemove(input: RetsListingVirtualToursSoftRemoveInput!): RetsListingVirtualToursSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingVirtualToursRemove(input: RetsListingVirtualToursRemoveInput!): RetsListingVirtualToursRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsListingVirtualToursRecover(input: RetsListingVirtualToursRecoverInput!): RetsListingVirtualToursRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsMlsProviderCreate(input: [RetsMlsProviderCreateInput!]!): [RetsMlsProviderCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsMlsProviderUpdate(input: RetsMlsProviderUpdateInput!): RetsMlsProviderUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsMlsProviderSoftDelete(input: RetsMlsProviderSoftDeleteInput!): RetsMlsProviderSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsMlsProviderDelete(input: RetsMlsProviderDeleteInput!): RetsMlsProviderDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsMlsProviderRestore(input: RetsMlsProviderRestoreInput!): RetsMlsProviderRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsMlsProviderUpsert(input: [RetsMlsProviderUpsertInput!]!): [RetsMlsProviderUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsMlsProviderSoftRemove(input: RetsMlsProviderSoftRemoveInput!): RetsMlsProviderSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsMlsProviderRemove(input: RetsMlsProviderRemoveInput!): RetsMlsProviderRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsMlsProviderRecover(input: RetsMlsProviderRecoverInput!): RetsMlsProviderRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsMlsProviderConfigCreate(input: [RetsMlsProviderConfigCreateInput!]!): [RetsMlsProviderConfigCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RetsMlsProviderConfigUpdate(input: RetsMlsProviderConfigUpdateInput!): RetsMlsProviderConfigUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RetsMlsProviderConfigSoftDelete(input: RetsMlsProviderConfigSoftDeleteInput!): RetsMlsProviderConfigSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RetsMlsProviderConfigDelete(input: RetsMlsProviderConfigDeleteInput!): RetsMlsProviderConfigDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RetsMlsProviderConfigRestore(input: RetsMlsProviderConfigRestoreInput!): RetsMlsProviderConfigRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RetsMlsProviderConfigUpsert(input: [RetsMlsProviderConfigUpsertInput!]!): [RetsMlsProviderConfigUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RetsMlsProviderConfigSoftRemove(input: RetsMlsProviderConfigSoftRemoveInput!): RetsMlsProviderConfigSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsMlsProviderConfigRemove(input: RetsMlsProviderConfigRemoveInput!): RetsMlsProviderConfigRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RetsMlsProviderConfigRecover(input: RetsMlsProviderConfigRecoverInput!): RetsMlsProviderConfigRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserFavouritePropertyCreate(input: [UserFavouritePropertyCreateInput!]!): [UserFavouritePropertyCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserFavouritePropertyUpdate(input: UserFavouritePropertyUpdateInput!): UserFavouritePropertyUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserFavouritePropertySoftDelete(input: UserFavouritePropertySoftDeleteInput!): UserFavouritePropertySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserFavouritePropertyDelete(input: UserFavouritePropertyDeleteInput!): UserFavouritePropertyDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserFavouritePropertyRestore(input: UserFavouritePropertyRestoreInput!): UserFavouritePropertyRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserFavouritePropertyUpsert(input: [UserFavouritePropertyUpsertInput!]!): [UserFavouritePropertyUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserFavouritePropertySoftRemove(input: UserFavouritePropertySoftRemoveInput!): UserFavouritePropertySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserFavouritePropertyRemove(input: UserFavouritePropertyRemoveInput!): UserFavouritePropertyRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserFavouritePropertyRecover(input: UserFavouritePropertyRecoverInput!): UserFavouritePropertyRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserSavedSearchCreate(input: [UserSavedSearchCreateInput!]!): [UserSavedSearchCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserSavedSearchUpdate(input: UserSavedSearchUpdateInput!): UserSavedSearchUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserSavedSearchSoftDelete(input: UserSavedSearchSoftDeleteInput!): UserSavedSearchSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserSavedSearchDelete(input: UserSavedSearchDeleteInput!): UserSavedSearchDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserSavedSearchRestore(input: UserSavedSearchRestoreInput!): UserSavedSearchRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserSavedSearchUpsert(input: [UserSavedSearchUpsertInput!]!): [UserSavedSearchUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserSavedSearchSoftRemove(input: UserSavedSearchSoftRemoveInput!): UserSavedSearchSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserSavedSearchRemove(input: UserSavedSearchRemoveInput!): UserSavedSearchRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserSavedSearchRecover(input: UserSavedSearchRecoverInput!): UserSavedSearchRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByAddressCreate(input: [ProcessedSearchByAddressCreateInput!]!): [ProcessedSearchByAddressCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ProcessedSearchByAddressUpdate(input: ProcessedSearchByAddressUpdateInput!): ProcessedSearchByAddressUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ProcessedSearchByAddressSoftDelete(input: ProcessedSearchByAddressSoftDeleteInput!): ProcessedSearchByAddressSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ProcessedSearchByAddressDelete(input: ProcessedSearchByAddressDeleteInput!): ProcessedSearchByAddressDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ProcessedSearchByAddressRestore(input: ProcessedSearchByAddressRestoreInput!): ProcessedSearchByAddressRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByAddressUpsert(input: [ProcessedSearchByAddressUpsertInput!]!): [ProcessedSearchByAddressUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ProcessedSearchByAddressSoftRemove(input: ProcessedSearchByAddressSoftRemoveInput!): ProcessedSearchByAddressSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByAddressRemove(input: ProcessedSearchByAddressRemoveInput!): ProcessedSearchByAddressRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByAddressRecover(input: ProcessedSearchByAddressRecoverInput!): ProcessedSearchByAddressRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByCityCreate(input: [ProcessedSearchByCityCreateInput!]!): [ProcessedSearchByCityCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ProcessedSearchByCityUpdate(input: ProcessedSearchByCityUpdateInput!): ProcessedSearchByCityUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ProcessedSearchByCitySoftDelete(input: ProcessedSearchByCitySoftDeleteInput!): ProcessedSearchByCitySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ProcessedSearchByCityDelete(input: ProcessedSearchByCityDeleteInput!): ProcessedSearchByCityDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ProcessedSearchByCityRestore(input: ProcessedSearchByCityRestoreInput!): ProcessedSearchByCityRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByCityUpsert(input: [ProcessedSearchByCityUpsertInput!]!): [ProcessedSearchByCityUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ProcessedSearchByCitySoftRemove(input: ProcessedSearchByCitySoftRemoveInput!): ProcessedSearchByCitySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByCityRemove(input: ProcessedSearchByCityRemoveInput!): ProcessedSearchByCityRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByCityRecover(input: ProcessedSearchByCityRecoverInput!): ProcessedSearchByCityRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByCountyCreate(input: [ProcessedSearchByCountyCreateInput!]!): [ProcessedSearchByCountyCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ProcessedSearchByCountyUpdate(input: ProcessedSearchByCountyUpdateInput!): ProcessedSearchByCountyUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ProcessedSearchByCountySoftDelete(input: ProcessedSearchByCountySoftDeleteInput!): ProcessedSearchByCountySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ProcessedSearchByCountyDelete(input: ProcessedSearchByCountyDeleteInput!): ProcessedSearchByCountyDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ProcessedSearchByCountyRestore(input: ProcessedSearchByCountyRestoreInput!): ProcessedSearchByCountyRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByCountyUpsert(input: [ProcessedSearchByCountyUpsertInput!]!): [ProcessedSearchByCountyUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ProcessedSearchByCountySoftRemove(input: ProcessedSearchByCountySoftRemoveInput!): ProcessedSearchByCountySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByCountyRemove(input: ProcessedSearchByCountyRemoveInput!): ProcessedSearchByCountyRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByCountyRecover(input: ProcessedSearchByCountyRecoverInput!): ProcessedSearchByCountyRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByMapSearchCreate(input: [ProcessedSearchByMapSearchCreateInput!]!): [ProcessedSearchByMapSearchCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ProcessedSearchByMapSearchUpdate(input: ProcessedSearchByMapSearchUpdateInput!): ProcessedSearchByMapSearchUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ProcessedSearchByMapSearchSoftDelete(input: ProcessedSearchByMapSearchSoftDeleteInput!): ProcessedSearchByMapSearchSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ProcessedSearchByMapSearchDelete(input: ProcessedSearchByMapSearchDeleteInput!): ProcessedSearchByMapSearchDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ProcessedSearchByMapSearchRestore(input: ProcessedSearchByMapSearchRestoreInput!): ProcessedSearchByMapSearchRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByMapSearchUpsert(input: [ProcessedSearchByMapSearchUpsertInput!]!): [ProcessedSearchByMapSearchUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ProcessedSearchByMapSearchSoftRemove(input: ProcessedSearchByMapSearchSoftRemoveInput!): ProcessedSearchByMapSearchSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByMapSearchRemove(input: ProcessedSearchByMapSearchRemoveInput!): ProcessedSearchByMapSearchRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByMapSearchRecover(input: ProcessedSearchByMapSearchRecoverInput!): ProcessedSearchByMapSearchRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByMlsCreate(input: [ProcessedSearchByMlsCreateInput!]!): [ProcessedSearchByMlsCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ProcessedSearchByMlsUpdate(input: ProcessedSearchByMlsUpdateInput!): ProcessedSearchByMlsUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ProcessedSearchByMlsSoftDelete(input: ProcessedSearchByMlsSoftDeleteInput!): ProcessedSearchByMlsSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ProcessedSearchByMlsDelete(input: ProcessedSearchByMlsDeleteInput!): ProcessedSearchByMlsDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ProcessedSearchByMlsRestore(input: ProcessedSearchByMlsRestoreInput!): ProcessedSearchByMlsRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByMlsUpsert(input: [ProcessedSearchByMlsUpsertInput!]!): [ProcessedSearchByMlsUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ProcessedSearchByMlsSoftRemove(input: ProcessedSearchByMlsSoftRemoveInput!): ProcessedSearchByMlsSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByMlsRemove(input: ProcessedSearchByMlsRemoveInput!): ProcessedSearchByMlsRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByMlsRecover(input: ProcessedSearchByMlsRecoverInput!): ProcessedSearchByMlsRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByNeighbourhoodCreate(input: [ProcessedSearchByNeighbourhoodCreateInput!]!): [ProcessedSearchByNeighbourhoodCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ProcessedSearchByNeighbourhoodUpdate(input: ProcessedSearchByNeighbourhoodUpdateInput!): ProcessedSearchByNeighbourhoodUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ProcessedSearchByNeighbourhoodSoftDelete(input: ProcessedSearchByNeighbourhoodSoftDeleteInput!): ProcessedSearchByNeighbourhoodSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ProcessedSearchByNeighbourhoodDelete(input: ProcessedSearchByNeighbourhoodDeleteInput!): ProcessedSearchByNeighbourhoodDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ProcessedSearchByNeighbourhoodRestore(input: ProcessedSearchByNeighbourhoodRestoreInput!): ProcessedSearchByNeighbourhoodRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByNeighbourhoodUpsert(input: [ProcessedSearchByNeighbourhoodUpsertInput!]!): [ProcessedSearchByNeighbourhoodUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ProcessedSearchByNeighbourhoodSoftRemove(input: ProcessedSearchByNeighbourhoodSoftRemoveInput!): ProcessedSearchByNeighbourhoodSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByNeighbourhoodRemove(input: ProcessedSearchByNeighbourhoodRemoveInput!): ProcessedSearchByNeighbourhoodRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByNeighbourhoodRecover(input: ProcessedSearchByNeighbourhoodRecoverInput!): ProcessedSearchByNeighbourhoodRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchBySubdivisionCreate(input: [ProcessedSearchBySubdivisionCreateInput!]!): [ProcessedSearchBySubdivisionCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ProcessedSearchBySubdivisionUpdate(input: ProcessedSearchBySubdivisionUpdateInput!): ProcessedSearchBySubdivisionUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ProcessedSearchBySubdivisionSoftDelete(input: ProcessedSearchBySubdivisionSoftDeleteInput!): ProcessedSearchBySubdivisionSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ProcessedSearchBySubdivisionDelete(input: ProcessedSearchBySubdivisionDeleteInput!): ProcessedSearchBySubdivisionDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ProcessedSearchBySubdivisionRestore(input: ProcessedSearchBySubdivisionRestoreInput!): ProcessedSearchBySubdivisionRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchBySubdivisionUpsert(input: [ProcessedSearchBySubdivisionUpsertInput!]!): [ProcessedSearchBySubdivisionUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ProcessedSearchBySubdivisionSoftRemove(input: ProcessedSearchBySubdivisionSoftRemoveInput!): ProcessedSearchBySubdivisionSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchBySubdivisionRemove(input: ProcessedSearchBySubdivisionRemoveInput!): ProcessedSearchBySubdivisionRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchBySubdivisionRecover(input: ProcessedSearchBySubdivisionRecoverInput!): ProcessedSearchBySubdivisionRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByZipcodeCreate(input: [ProcessedSearchByZipcodeCreateInput!]!): [ProcessedSearchByZipcodeCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ProcessedSearchByZipcodeUpdate(input: ProcessedSearchByZipcodeUpdateInput!): ProcessedSearchByZipcodeUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ProcessedSearchByZipcodeSoftDelete(input: ProcessedSearchByZipcodeSoftDeleteInput!): ProcessedSearchByZipcodeSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ProcessedSearchByZipcodeDelete(input: ProcessedSearchByZipcodeDeleteInput!): ProcessedSearchByZipcodeDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ProcessedSearchByZipcodeRestore(input: ProcessedSearchByZipcodeRestoreInput!): ProcessedSearchByZipcodeRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ProcessedSearchByZipcodeUpsert(input: [ProcessedSearchByZipcodeUpsertInput!]!): [ProcessedSearchByZipcodeUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ProcessedSearchByZipcodeSoftRemove(input: ProcessedSearchByZipcodeSoftRemoveInput!): ProcessedSearchByZipcodeSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByZipcodeRemove(input: ProcessedSearchByZipcodeRemoveInput!): ProcessedSearchByZipcodeRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ProcessedSearchByZipcodeRecover(input: ProcessedSearchByZipcodeRecoverInput!): ProcessedSearchByZipcodeRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ApiEndpointAuthCreate(input: [ApiEndpointAuthCreateInput!]!): [ApiEndpointAuthCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ApiEndpointAuthUpdate(input: ApiEndpointAuthUpdateInput!): ApiEndpointAuthUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ApiEndpointAuthSoftDelete(input: ApiEndpointAuthSoftDeleteInput!): ApiEndpointAuthSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ApiEndpointAuthDelete(input: ApiEndpointAuthDeleteInput!): ApiEndpointAuthDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ApiEndpointAuthRestore(input: ApiEndpointAuthRestoreInput!): ApiEndpointAuthRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ApiEndpointAuthUpsert(input: [ApiEndpointAuthUpsertInput!]!): [ApiEndpointAuthUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ApiEndpointAuthSoftRemove(input: ApiEndpointAuthSoftRemoveInput!): ApiEndpointAuthSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ApiEndpointAuthRemove(input: ApiEndpointAuthRemoveInput!): ApiEndpointAuthRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ApiEndpointAuthRecover(input: ApiEndpointAuthRecoverInput!): ApiEndpointAuthRecoverOutput!

  """Signup to get access to the application data."""
  GraphSignup(input: GraphSignupInput!): GraphSignupOutput!

  """Signin to get JWT token and gain access to the application data."""
  GraphSignin(input: GraphLoginInput!): GraphLoginOutput!

  """Refresh JWT access token using refresh token."""
  GraphRefreshJWT(jwtRefreshToken: String!): GraphLoginOutput!

  """Reset your password using JWT refresh token."""
  GraphResetPassword(input: GraphResetPasswordInput!): GraphResetPasswordOutput!

  """
  Signout and remove JWT token for the current state. Next time login to regain access.
  """
  GraphSignout: Boolean!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RegionCreate(input: [RegionCreateInput!]!): [RegionCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  RegionUpdate(input: RegionUpdateInput!): RegionUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  RegionSoftDelete(input: RegionSoftDeleteInput!): RegionSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  RegionDelete(input: RegionDeleteInput!): RegionDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  RegionRestore(input: RegionRestoreInput!): RegionRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  RegionUpsert(input: [RegionUpsertInput!]!): [RegionUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  RegionSoftRemove(input: RegionSoftRemoveInput!): RegionSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RegionRemove(input: RegionRemoveInput!): RegionRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  RegionRecover(input: RegionRecoverInput!): RegionRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SubregionCreate(input: [SubregionCreateInput!]!): [SubregionCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  SubregionUpdate(input: SubregionUpdateInput!): SubregionUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  SubregionSoftDelete(input: SubregionSoftDeleteInput!): SubregionSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  SubregionDelete(input: SubregionDeleteInput!): SubregionDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  SubregionRestore(input: SubregionRestoreInput!): SubregionRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SubregionUpsert(input: [SubregionUpsertInput!]!): [SubregionUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  SubregionSoftRemove(input: SubregionSoftRemoveInput!): SubregionSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SubregionRemove(input: SubregionRemoveInput!): SubregionRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SubregionRecover(input: SubregionRecoverInput!): SubregionRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  CountryCreate(input: [CountryCreateInput!]!): [CountryCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  CountryUpdate(input: CountryUpdateInput!): CountryUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  CountrySoftDelete(input: CountrySoftDeleteInput!): CountrySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  CountryDelete(input: CountryDeleteInput!): CountryDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  CountryRestore(input: CountryRestoreInput!): CountryRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  CountryUpsert(input: [CountryUpsertInput!]!): [CountryUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  CountrySoftRemove(input: CountrySoftRemoveInput!): CountrySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  CountryRemove(input: CountryRemoveInput!): CountryRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  CountryRecover(input: CountryRecoverInput!): CountryRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  StateCreate(input: [StateCreateInput!]!): [StateCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  StateUpdate(input: StateUpdateInput!): StateUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  StateSoftDelete(input: StateSoftDeleteInput!): StateSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  StateDelete(input: StateDeleteInput!): StateDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  StateRestore(input: StateRestoreInput!): StateRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  StateUpsert(input: [StateUpsertInput!]!): [StateUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  StateSoftRemove(input: StateSoftRemoveInput!): StateSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  StateRemove(input: StateRemoveInput!): StateRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  StateRecover(input: StateRecoverInput!): StateRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  CityCreate(input: [CityCreateInput!]!): [CityCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  CityUpdate(input: CityUpdateInput!): CityUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  CitySoftDelete(input: CitySoftDeleteInput!): CitySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  CityDelete(input: CityDeleteInput!): CityDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  CityRestore(input: CityRestoreInput!): CityRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  CityUpsert(input: [CityUpsertInput!]!): [CityUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  CitySoftRemove(input: CitySoftRemoveInput!): CitySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  CityRemove(input: CityRemoveInput!): CityRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  CityRecover(input: CityRecoverInput!): CityRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LanguageCreate(input: [LanguageCreateInput!]!): [LanguageCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  LanguageUpdate(input: LanguageUpdateInput!): LanguageUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  LanguageSoftDelete(input: LanguageSoftDeleteInput!): LanguageSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  LanguageDelete(input: LanguageDeleteInput!): LanguageDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  LanguageRestore(input: LanguageRestoreInput!): LanguageRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LanguageUpsert(input: [LanguageUpsertInput!]!): [LanguageUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  LanguageSoftRemove(input: LanguageSoftRemoveInput!): LanguageSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LanguageRemove(input: LanguageRemoveInput!): LanguageRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LanguageRecover(input: LanguageRecoverInput!): LanguageRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  CountryLanguageCreate(input: [CountryLanguageCreateInput!]!): [CountryLanguageCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  CountryLanguageUpdate(input: CountryLanguageUpdateInput!): CountryLanguageUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  CountryLanguageSoftDelete(input: CountryLanguageSoftDeleteInput!): CountryLanguageSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  CountryLanguageDelete(input: CountryLanguageDeleteInput!): CountryLanguageDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  CountryLanguageRestore(input: CountryLanguageRestoreInput!): CountryLanguageRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  CountryLanguageUpsert(input: [CountryLanguageUpsertInput!]!): [CountryLanguageUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  CountryLanguageSoftRemove(input: CountryLanguageSoftRemoveInput!): CountryLanguageSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  CountryLanguageRemove(input: CountryLanguageRemoveInput!): CountryLanguageRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  CountryLanguageRecover(input: CountryLanguageRecoverInput!): CountryLanguageRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  TimezoneCreate(input: [TimezoneCreateInput!]!): [TimezoneCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  TimezoneUpdate(input: TimezoneUpdateInput!): TimezoneUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  TimezoneSoftDelete(input: TimezoneSoftDeleteInput!): TimezoneSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  TimezoneDelete(input: TimezoneDeleteInput!): TimezoneDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  TimezoneRestore(input: TimezoneRestoreInput!): TimezoneRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  TimezoneUpsert(input: [TimezoneUpsertInput!]!): [TimezoneUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  TimezoneSoftRemove(input: TimezoneSoftRemoveInput!): TimezoneSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  TimezoneRemove(input: TimezoneRemoveInput!): TimezoneRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  TimezoneRecover(input: TimezoneRecoverInput!): TimezoneRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  CountryTimezoneCreate(input: [CountryTimezoneCreateInput!]!): [CountryTimezoneCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  CountryTimezoneUpdate(input: CountryTimezoneUpdateInput!): CountryTimezoneUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  CountryTimezoneSoftDelete(input: CountryTimezoneSoftDeleteInput!): CountryTimezoneSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  CountryTimezoneDelete(input: CountryTimezoneDeleteInput!): CountryTimezoneDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  CountryTimezoneRestore(input: CountryTimezoneRestoreInput!): CountryTimezoneRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  CountryTimezoneUpsert(input: [CountryTimezoneUpsertInput!]!): [CountryTimezoneUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  CountryTimezoneSoftRemove(input: CountryTimezoneSoftRemoveInput!): CountryTimezoneSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  CountryTimezoneRemove(input: CountryTimezoneRemoveInput!): CountryTimezoneRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  CountryTimezoneRecover(input: CountryTimezoneRecoverInput!): CountryTimezoneRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ThirdPartyPlatformCreate(input: [ThirdPartyPlatformCreateInput!]!): [ThirdPartyPlatformCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ThirdPartyPlatformUpdate(input: ThirdPartyPlatformUpdateInput!): ThirdPartyPlatformUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ThirdPartyPlatformSoftDelete(input: ThirdPartyPlatformSoftDeleteInput!): ThirdPartyPlatformSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ThirdPartyPlatformDelete(input: ThirdPartyPlatformDeleteInput!): ThirdPartyPlatformDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ThirdPartyPlatformRestore(input: ThirdPartyPlatformRestoreInput!): ThirdPartyPlatformRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ThirdPartyPlatformUpsert(input: [ThirdPartyPlatformUpsertInput!]!): [ThirdPartyPlatformUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ThirdPartyPlatformSoftRemove(input: ThirdPartyPlatformSoftRemoveInput!): ThirdPartyPlatformSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ThirdPartyPlatformRemove(input: ThirdPartyPlatformRemoveInput!): ThirdPartyPlatformRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ThirdPartyPlatformRecover(input: ThirdPartyPlatformRecoverInput!): ThirdPartyPlatformRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  AuthorisationCreate(input: [AuthorisationCreateInput!]!): [AuthorisationCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  AuthorisationUpdate(input: AuthorisationUpdateInput!): AuthorisationUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  AuthorisationSoftDelete(input: AuthorisationSoftDeleteInput!): AuthorisationSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  AuthorisationDelete(input: AuthorisationDeleteInput!): AuthorisationDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  AuthorisationRestore(input: AuthorisationRestoreInput!): AuthorisationRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  AuthorisationUpsert(input: [AuthorisationUpsertInput!]!): [AuthorisationUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  AuthorisationSoftRemove(input: AuthorisationSoftRemoveInput!): AuthorisationSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  AuthorisationRemove(input: AuthorisationRemoveInput!): AuthorisationRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  AuthorisationRecover(input: AuthorisationRecoverInput!): AuthorisationRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  DeviceCreate(input: [DeviceCreateInput!]!): [DeviceCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  DeviceUpdate(input: DeviceUpdateInput!): DeviceUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  DeviceSoftDelete(input: DeviceSoftDeleteInput!): DeviceSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  DeviceDelete(input: DeviceDeleteInput!): DeviceDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  DeviceRestore(input: DeviceRestoreInput!): DeviceRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  DeviceUpsert(input: [DeviceUpsertInput!]!): [DeviceUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  DeviceSoftRemove(input: DeviceSoftRemoveInput!): DeviceSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  DeviceRemove(input: DeviceRemoveInput!): DeviceRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  DeviceRecover(input: DeviceRecoverInput!): DeviceRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  IdentityCardTypeCreate(input: [IdentityCardTypeCreateInput!]!): [IdentityCardTypeCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  IdentityCardTypeUpdate(input: IdentityCardTypeUpdateInput!): IdentityCardTypeUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  IdentityCardTypeSoftDelete(input: IdentityCardTypeSoftDeleteInput!): IdentityCardTypeSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  IdentityCardTypeDelete(input: IdentityCardTypeDeleteInput!): IdentityCardTypeDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  IdentityCardTypeRestore(input: IdentityCardTypeRestoreInput!): IdentityCardTypeRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  IdentityCardTypeUpsert(input: [IdentityCardTypeUpsertInput!]!): [IdentityCardTypeUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  IdentityCardTypeSoftRemove(input: IdentityCardTypeSoftRemoveInput!): IdentityCardTypeSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  IdentityCardTypeRemove(input: IdentityCardTypeRemoveInput!): IdentityCardTypeRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  IdentityCardTypeRecover(input: IdentityCardTypeRecoverInput!): IdentityCardTypeRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  FormFieldCreate(input: [FormFieldCreateInput!]!): [FormFieldCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  FormFieldUpdate(input: FormFieldUpdateInput!): FormFieldUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  FormFieldSoftDelete(input: FormFieldSoftDeleteInput!): FormFieldSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  FormFieldDelete(input: FormFieldDeleteInput!): FormFieldDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  FormFieldRestore(input: FormFieldRestoreInput!): FormFieldRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  FormFieldUpsert(input: [FormFieldUpsertInput!]!): [FormFieldUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  FormFieldSoftRemove(input: FormFieldSoftRemoveInput!): FormFieldSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  FormFieldRemove(input: FormFieldRemoveInput!): FormFieldRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  FormFieldRecover(input: FormFieldRecoverInput!): FormFieldRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  AlertDurationCreate(input: [AlertDurationCreateInput!]!): [AlertDurationCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  AlertDurationUpdate(input: AlertDurationUpdateInput!): AlertDurationUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  AlertDurationSoftDelete(input: AlertDurationSoftDeleteInput!): AlertDurationSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  AlertDurationDelete(input: AlertDurationDeleteInput!): AlertDurationDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  AlertDurationRestore(input: AlertDurationRestoreInput!): AlertDurationRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  AlertDurationUpsert(input: [AlertDurationUpsertInput!]!): [AlertDurationUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  AlertDurationSoftRemove(input: AlertDurationSoftRemoveInput!): AlertDurationSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  AlertDurationRemove(input: AlertDurationRemoveInput!): AlertDurationRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  AlertDurationRecover(input: AlertDurationRecoverInput!): AlertDurationRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  WorkStatusCreate(input: [WorkStatusCreateInput!]!): [WorkStatusCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  WorkStatusUpdate(input: WorkStatusUpdateInput!): WorkStatusUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  WorkStatusSoftDelete(input: WorkStatusSoftDeleteInput!): WorkStatusSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  WorkStatusDelete(input: WorkStatusDeleteInput!): WorkStatusDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  WorkStatusRestore(input: WorkStatusRestoreInput!): WorkStatusRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  WorkStatusUpsert(input: [WorkStatusUpsertInput!]!): [WorkStatusUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  WorkStatusSoftRemove(input: WorkStatusSoftRemoveInput!): WorkStatusSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  WorkStatusRemove(input: WorkStatusRemoveInput!): WorkStatusRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  WorkStatusRecover(input: WorkStatusRecoverInput!): WorkStatusRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SettingTypeCreate(input: [SettingTypeCreateInput!]!): [SettingTypeCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  SettingTypeUpdate(input: SettingTypeUpdateInput!): SettingTypeUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  SettingTypeSoftDelete(input: SettingTypeSoftDeleteInput!): SettingTypeSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  SettingTypeDelete(input: SettingTypeDeleteInput!): SettingTypeDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  SettingTypeRestore(input: SettingTypeRestoreInput!): SettingTypeRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SettingTypeUpsert(input: [SettingTypeUpsertInput!]!): [SettingTypeUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  SettingTypeSoftRemove(input: SettingTypeSoftRemoveInput!): SettingTypeSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SettingTypeRemove(input: SettingTypeRemoveInput!): SettingTypeRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SettingTypeRecover(input: SettingTypeRecoverInput!): SettingTypeRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SettingCategoryCreate(input: [SettingCategoryCreateInput!]!): [SettingCategoryCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  SettingCategoryUpdate(input: SettingCategoryUpdateInput!): SettingCategoryUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  SettingCategorySoftDelete(input: SettingCategorySoftDeleteInput!): SettingCategorySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  SettingCategoryDelete(input: SettingCategoryDeleteInput!): SettingCategoryDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  SettingCategoryRestore(input: SettingCategoryRestoreInput!): SettingCategoryRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SettingCategoryUpsert(input: [SettingCategoryUpsertInput!]!): [SettingCategoryUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  SettingCategorySoftRemove(input: SettingCategorySoftRemoveInput!): SettingCategorySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SettingCategoryRemove(input: SettingCategoryRemoveInput!): SettingCategoryRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SettingCategoryRecover(input: SettingCategoryRecoverInput!): SettingCategoryRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  StaticDataCreate(input: [StaticDataCreateInput!]!): [StaticDataCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  StaticDataUpdate(input: StaticDataUpdateInput!): StaticDataUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  StaticDataSoftDelete(input: StaticDataSoftDeleteInput!): StaticDataSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  StaticDataDelete(input: StaticDataDeleteInput!): StaticDataDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  StaticDataRestore(input: StaticDataRestoreInput!): StaticDataRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  StaticDataUpsert(input: [StaticDataUpsertInput!]!): [StaticDataUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  StaticDataSoftRemove(input: StaticDataSoftRemoveInput!): StaticDataSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  StaticDataRemove(input: StaticDataRemoveInput!): StaticDataRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  StaticDataRecover(input: StaticDataRecoverInput!): StaticDataRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  StaticDataValueCreate(input: [StaticDataValueCreateInput!]!): [StaticDataValueCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  StaticDataValueUpdate(input: StaticDataValueUpdateInput!): StaticDataValueUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  StaticDataValueSoftDelete(input: StaticDataValueSoftDeleteInput!): StaticDataValueSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  StaticDataValueDelete(input: StaticDataValueDeleteInput!): StaticDataValueDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  StaticDataValueRestore(input: StaticDataValueRestoreInput!): StaticDataValueRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  StaticDataValueUpsert(input: [StaticDataValueUpsertInput!]!): [StaticDataValueUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  StaticDataValueSoftRemove(input: StaticDataValueSoftRemoveInput!): StaticDataValueSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  StaticDataValueRemove(input: StaticDataValueRemoveInput!): StaticDataValueRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  StaticDataValueRecover(input: StaticDataValueRecoverInput!): StaticDataValueRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SettingPreferenceCreate(input: [SettingPreferenceCreateInput!]!): [SettingPreferenceCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  SettingPreferenceUpdate(input: SettingPreferenceUpdateInput!): SettingPreferenceUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  SettingPreferenceSoftDelete(input: SettingPreferenceSoftDeleteInput!): SettingPreferenceSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  SettingPreferenceDelete(input: SettingPreferenceDeleteInput!): SettingPreferenceDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  SettingPreferenceRestore(input: SettingPreferenceRestoreInput!): SettingPreferenceRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SettingPreferenceUpsert(input: [SettingPreferenceUpsertInput!]!): [SettingPreferenceUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  SettingPreferenceSoftRemove(input: SettingPreferenceSoftRemoveInput!): SettingPreferenceSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SettingPreferenceRemove(input: SettingPreferenceRemoveInput!): SettingPreferenceRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SettingPreferenceRecover(input: SettingPreferenceRecoverInput!): SettingPreferenceRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SettingCreate(input: [SettingCreateInput!]!): [SettingCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  SettingUpdate(input: SettingUpdateInput!): SettingUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  SettingSoftDelete(input: SettingSoftDeleteInput!): SettingSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  SettingDelete(input: SettingDeleteInput!): SettingDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  SettingRestore(input: SettingRestoreInput!): SettingRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SettingUpsert(input: [SettingUpsertInput!]!): [SettingUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  SettingSoftRemove(input: SettingSoftRemoveInput!): SettingSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SettingRemove(input: SettingRemoveInput!): SettingRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SettingRecover(input: SettingRecoverInput!): SettingRecoverOutput!

  """
  Upload files for given single record id. You can also upload multiple files for same record at once but cannot upload multiple fields files for same record. Each upload field needs to be provided in request body. Simple rule is must be one record one field with single or multiple files at a time. Returns saved file(s) info.
  """
  UserUpload(attachment: [Upload!]!, input: UserUploadInput!): [UserUploadOutput!]!

  """
  Delete uploaded files for given single record id. You can also delete multiple files for same record at once. This is as per set criteria in entity. Returns deleted file(s) info.
  """
  UserUploadDelete(input: [UserUploadDeleteInput!]!): [UserUploadDeleteOutput!]!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserCreate(input: [UserCreateInput!]!): [UserCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserUpdate(input: UserUpdateInput!): UserUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserSoftDelete(input: UserSoftDeleteInput!): UserSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserDelete(input: UserDeleteInput!): UserDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserRestore(input: UserRestoreInput!): UserRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserUpsert(input: [UserUpsertInput!]!): [UserUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserSoftRemove(input: UserSoftRemoveInput!): UserSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserRemove(input: UserRemoveInput!): UserRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserRecover(input: UserRecoverInput!): UserRecoverOutput!

  """
  Signup to get access restricted area. Required any one username or primary_email or primary_mobile.
  """
  AppSignup(input: AppSignupInput!): AppSignupOutput!

  """
  Grant Signup to get access restricted area. Required any one username or primary_email or primary_mobile.
  """
  AppGrantSignup(input: AppGrantSignupInput!): AppGrantSignupOutput!

  """Grants a new role to an existing user."""
  AppGrantRole(input: UserAuthorisationCreateInput!): [UserAuthorisationCreateOutput!]!

  """Signin to get your account access."""
  AppSignin(input: AppSigninInput!): AppSigninOutput!

  """Signin using OTP to get your account access."""
  AppOtpSignin(input: AppOtpSigninInput!): AppOtpSigninOutput!

  """Reset your password."""
  AppResetPassword(input: AppResetPasswordInput!): AppResetPasswordOutput!

  """Forgot password."""
  AppForgotPassword(input: AppForgotPasswordInput!): AppForgotPasswordOutput!

  """Recover Forgot password."""
  AppRecoverForgotPassword(input: AppRecoverForgotPasswordInput!): AppRecoverForgotPasswordOutput!

  """
  Signout and remove session for the current state. Next time login to regain access.
  """
  AppSignout: Boolean!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserAuthenticationCreate(input: [UserAuthenticationCreateInput!]!): [UserAuthenticationCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserAuthenticationUpdate(input: UserAuthenticationUpdateInput!): UserAuthenticationUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserAuthenticationSoftDelete(input: UserAuthenticationSoftDeleteInput!): UserAuthenticationSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserAuthenticationDelete(input: UserAuthenticationDeleteInput!): UserAuthenticationDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserAuthenticationRestore(input: UserAuthenticationRestoreInput!): UserAuthenticationRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserAuthenticationUpsert(input: [UserAuthenticationUpsertInput!]!): [UserAuthenticationUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserAuthenticationSoftRemove(input: UserAuthenticationSoftRemoveInput!): UserAuthenticationSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserAuthenticationRemove(input: UserAuthenticationRemoveInput!): UserAuthenticationRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserAuthenticationRecover(input: UserAuthenticationRecoverInput!): UserAuthenticationRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  QueueTypeCreate(input: [QueueTypeCreateInput!]!): [QueueTypeCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  QueueTypeUpdate(input: QueueTypeUpdateInput!): QueueTypeUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  QueueTypeSoftDelete(input: QueueTypeSoftDeleteInput!): QueueTypeSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  QueueTypeDelete(input: QueueTypeDeleteInput!): QueueTypeDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  QueueTypeRestore(input: QueueTypeRestoreInput!): QueueTypeRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  QueueTypeUpsert(input: [QueueTypeUpsertInput!]!): [QueueTypeUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  QueueTypeSoftRemove(input: QueueTypeSoftRemoveInput!): QueueTypeSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  QueueTypeRemove(input: QueueTypeRemoveInput!): QueueTypeRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  QueueTypeRecover(input: QueueTypeRecoverInput!): QueueTypeRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  QueueSmsCreate(input: [QueueSmsCreateInput!]!): [QueueSmsCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  QueueSmsUpdate(input: QueueSmsUpdateInput!): QueueSmsUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  QueueSmsSoftDelete(input: QueueSmsSoftDeleteInput!): QueueSmsSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  QueueSmsDelete(input: QueueSmsDeleteInput!): QueueSmsDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  QueueSmsRestore(input: QueueSmsRestoreInput!): QueueSmsRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  QueueSmsUpsert(input: [QueueSmsUpsertInput!]!): [QueueSmsUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  QueueSmsSoftRemove(input: QueueSmsSoftRemoveInput!): QueueSmsSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  QueueSmsRemove(input: QueueSmsRemoveInput!): QueueSmsRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  QueueSmsRecover(input: QueueSmsRecoverInput!): QueueSmsRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  QueueEmailCreate(input: [QueueEmailCreateInput!]!): [QueueEmailCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  QueueEmailUpdate(input: QueueEmailUpdateInput!): QueueEmailUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  QueueEmailSoftDelete(input: QueueEmailSoftDeleteInput!): QueueEmailSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  QueueEmailDelete(input: QueueEmailDeleteInput!): QueueEmailDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  QueueEmailRestore(input: QueueEmailRestoreInput!): QueueEmailRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  QueueEmailUpsert(input: [QueueEmailUpsertInput!]!): [QueueEmailUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  QueueEmailSoftRemove(input: QueueEmailSoftRemoveInput!): QueueEmailSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  QueueEmailRemove(input: QueueEmailRemoveInput!): QueueEmailRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  QueueEmailRecover(input: QueueEmailRecoverInput!): QueueEmailRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  QueueWhatsappCreate(input: [QueueWhatsappCreateInput!]!): [QueueWhatsappCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  QueueWhatsappUpdate(input: QueueWhatsappUpdateInput!): QueueWhatsappUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  QueueWhatsappSoftDelete(input: QueueWhatsappSoftDeleteInput!): QueueWhatsappSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  QueueWhatsappDelete(input: QueueWhatsappDeleteInput!): QueueWhatsappDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  QueueWhatsappRestore(input: QueueWhatsappRestoreInput!): QueueWhatsappRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  QueueWhatsappUpsert(input: [QueueWhatsappUpsertInput!]!): [QueueWhatsappUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  QueueWhatsappSoftRemove(input: QueueWhatsappSoftRemoveInput!): QueueWhatsappSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  QueueWhatsappRemove(input: QueueWhatsappRemoveInput!): QueueWhatsappRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  QueueWhatsappRecover(input: QueueWhatsappRecoverInput!): QueueWhatsappRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  EmailTemplateCreate(input: [EmailTemplateCreateInput!]!): [EmailTemplateCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  EmailTemplateUpdate(input: EmailTemplateUpdateInput!): EmailTemplateUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  EmailTemplateSoftDelete(input: EmailTemplateSoftDeleteInput!): EmailTemplateSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  EmailTemplateDelete(input: EmailTemplateDeleteInput!): EmailTemplateDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  EmailTemplateRestore(input: EmailTemplateRestoreInput!): EmailTemplateRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  EmailTemplateUpsert(input: [EmailTemplateUpsertInput!]!): [EmailTemplateUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  EmailTemplateSoftRemove(input: EmailTemplateSoftRemoveInput!): EmailTemplateSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  EmailTemplateRemove(input: EmailTemplateRemoveInput!): EmailTemplateRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  EmailTemplateRecover(input: EmailTemplateRecoverInput!): EmailTemplateRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  EmailTemplateCategoryCreate(input: [EmailTemplateCategoryCreateInput!]!): [EmailTemplateCategoryCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  EmailTemplateCategoryUpdate(input: EmailTemplateCategoryUpdateInput!): EmailTemplateCategoryUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  EmailTemplateCategorySoftDelete(input: EmailTemplateCategorySoftDeleteInput!): EmailTemplateCategorySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  EmailTemplateCategoryDelete(input: EmailTemplateCategoryDeleteInput!): EmailTemplateCategoryDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  EmailTemplateCategoryRestore(input: EmailTemplateCategoryRestoreInput!): EmailTemplateCategoryRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  EmailTemplateCategoryUpsert(input: [EmailTemplateCategoryUpsertInput!]!): [EmailTemplateCategoryUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  EmailTemplateCategorySoftRemove(input: EmailTemplateCategorySoftRemoveInput!): EmailTemplateCategorySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  EmailTemplateCategoryRemove(input: EmailTemplateCategoryRemoveInput!): EmailTemplateCategoryRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  EmailTemplateCategoryRecover(input: EmailTemplateCategoryRecoverInput!): EmailTemplateCategoryRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SessionCreate(input: [SessionCreateInput!]!): [SessionCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  SessionUpdate(input: SessionUpdateInput!): SessionUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  SessionSoftDelete(input: SessionSoftDeleteInput!): SessionSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  SessionDelete(input: SessionDeleteInput!): SessionDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  SessionRestore(input: SessionRestoreInput!): SessionRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SessionUpsert(input: [SessionUpsertInput!]!): [SessionUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  SessionSoftRemove(input: SessionSoftRemoveInput!): SessionSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SessionRemove(input: SessionRemoveInput!): SessionRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SessionRecover(input: SessionRecoverInput!): SessionRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SessionMetaCreate(input: [SessionMetaCreateInput!]!): [SessionMetaCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  SessionMetaUpdate(input: SessionMetaUpdateInput!): SessionMetaUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  SessionMetaSoftDelete(input: SessionMetaSoftDeleteInput!): SessionMetaSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  SessionMetaDelete(input: SessionMetaDeleteInput!): SessionMetaDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  SessionMetaRestore(input: SessionMetaRestoreInput!): SessionMetaRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  SessionMetaUpsert(input: [SessionMetaUpsertInput!]!): [SessionMetaUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  SessionMetaSoftRemove(input: SessionMetaSoftRemoveInput!): SessionMetaSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SessionMetaRemove(input: SessionMetaRemoveInput!): SessionMetaRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  SessionMetaRecover(input: SessionMetaRecoverInput!): SessionMetaRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserAuthorisationCreate(input: [UserAuthorisationCreateInput!]!): [UserAuthorisationCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserAuthorisationUpdate(input: UserAuthorisationUpdateInput!): UserAuthorisationUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserAuthorisationSoftDelete(input: UserAuthorisationSoftDeleteInput!): UserAuthorisationSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserAuthorisationDelete(input: UserAuthorisationDeleteInput!): UserAuthorisationDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserAuthorisationRestore(input: UserAuthorisationRestoreInput!): UserAuthorisationRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserAuthorisationUpsert(input: [UserAuthorisationUpsertInput!]!): [UserAuthorisationUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserAuthorisationSoftRemove(input: UserAuthorisationSoftRemoveInput!): UserAuthorisationSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserAuthorisationRemove(input: UserAuthorisationRemoveInput!): UserAuthorisationRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserAuthorisationRecover(input: UserAuthorisationRecoverInput!): UserAuthorisationRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserDeviceCreate(input: [UserDeviceCreateInput!]!): [UserDeviceCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserDeviceUpdate(input: UserDeviceUpdateInput!): UserDeviceUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserDeviceSoftDelete(input: UserDeviceSoftDeleteInput!): UserDeviceSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserDeviceDelete(input: UserDeviceDeleteInput!): UserDeviceDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserDeviceRestore(input: UserDeviceRestoreInput!): UserDeviceRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserDeviceUpsert(input: [UserDeviceUpsertInput!]!): [UserDeviceUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserDeviceSoftRemove(input: UserDeviceSoftRemoveInput!): UserDeviceSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserDeviceRemove(input: UserDeviceRemoveInput!): UserDeviceRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserDeviceRecover(input: UserDeviceRecoverInput!): UserDeviceRecoverOutput!

  """
  Upload files for given single record id. You can also upload multiple files for same record at once but cannot upload multiple fields files for same record. Each upload field needs to be provided in request body. Simple rule is must be one record one field with single or multiple files at a time. Returns saved file(s) info.
  """
  UserCorporateInfoUpload(attachment: [Upload!]!, input: UserCorporateInfoUploadInput!): [UserCorporateInfoUploadOutput!]!

  """
  Delete uploaded files for given single record id. You can also delete multiple files for same record at once. This is as per set criteria in entity. Returns deleted file(s) info.
  """
  UserCorporateInfoUploadDelete(input: [UserCorporateInfoUploadDeleteInput!]!): [UserCorporateInfoUploadDeleteOutput!]!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserCorporateInfoCreate(input: [UserCorporateInfoCreateInput!]!): [UserCorporateInfoCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserCorporateInfoUpdate(input: UserCorporateInfoUpdateInput!): UserCorporateInfoUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserCorporateInfoSoftDelete(input: UserCorporateInfoSoftDeleteInput!): UserCorporateInfoSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserCorporateInfoDelete(input: UserCorporateInfoDeleteInput!): UserCorporateInfoDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserCorporateInfoRestore(input: UserCorporateInfoRestoreInput!): UserCorporateInfoRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserCorporateInfoUpsert(input: [UserCorporateInfoUpsertInput!]!): [UserCorporateInfoUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserCorporateInfoSoftRemove(input: UserCorporateInfoSoftRemoveInput!): UserCorporateInfoSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserCorporateInfoRemove(input: UserCorporateInfoRemoveInput!): UserCorporateInfoRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserCorporateInfoRecover(input: UserCorporateInfoRecoverInput!): UserCorporateInfoRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserPersonalInfoCreate(input: [UserPersonalInfoCreateInput!]!): [UserPersonalInfoCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserPersonalInfoUpdate(input: UserPersonalInfoUpdateInput!): UserPersonalInfoUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserPersonalInfoSoftDelete(input: UserPersonalInfoSoftDeleteInput!): UserPersonalInfoSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserPersonalInfoDelete(input: UserPersonalInfoDeleteInput!): UserPersonalInfoDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserPersonalInfoRestore(input: UserPersonalInfoRestoreInput!): UserPersonalInfoRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserPersonalInfoUpsert(input: [UserPersonalInfoUpsertInput!]!): [UserPersonalInfoUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserPersonalInfoSoftRemove(input: UserPersonalInfoSoftRemoveInput!): UserPersonalInfoSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserPersonalInfoRemove(input: UserPersonalInfoRemoveInput!): UserPersonalInfoRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserPersonalInfoRecover(input: UserPersonalInfoRecoverInput!): UserPersonalInfoRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserAddressCreate(input: [UserAddressCreateInput!]!): [UserAddressCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserAddressUpdate(input: UserAddressUpdateInput!): UserAddressUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserAddressSoftDelete(input: UserAddressSoftDeleteInput!): UserAddressSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserAddressDelete(input: UserAddressDeleteInput!): UserAddressDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserAddressRestore(input: UserAddressRestoreInput!): UserAddressRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserAddressUpsert(input: [UserAddressUpsertInput!]!): [UserAddressUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserAddressSoftRemove(input: UserAddressSoftRemoveInput!): UserAddressSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserAddressRemove(input: UserAddressRemoveInput!): UserAddressRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserAddressRecover(input: UserAddressRecoverInput!): UserAddressRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserIdentityCardCreate(input: [UserIdentityCardCreateInput!]!): [UserIdentityCardCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserIdentityCardUpdate(input: UserIdentityCardUpdateInput!): UserIdentityCardUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserIdentityCardSoftDelete(input: UserIdentityCardSoftDeleteInput!): UserIdentityCardSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserIdentityCardDelete(input: UserIdentityCardDeleteInput!): UserIdentityCardDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserIdentityCardRestore(input: UserIdentityCardRestoreInput!): UserIdentityCardRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserIdentityCardUpsert(input: [UserIdentityCardUpsertInput!]!): [UserIdentityCardUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserIdentityCardSoftRemove(input: UserIdentityCardSoftRemoveInput!): UserIdentityCardSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserIdentityCardRemove(input: UserIdentityCardRemoveInput!): UserIdentityCardRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserIdentityCardRecover(input: UserIdentityCardRecoverInput!): UserIdentityCardRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserHierarchyCreate(input: [UserHierarchyCreateInput!]!): [UserHierarchyCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserHierarchyUpdate(input: UserHierarchyUpdateInput!): UserHierarchyUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserHierarchySoftDelete(input: UserHierarchySoftDeleteInput!): UserHierarchySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserHierarchyDelete(input: UserHierarchyDeleteInput!): UserHierarchyDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserHierarchyRestore(input: UserHierarchyRestoreInput!): UserHierarchyRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserHierarchyUpsert(input: [UserHierarchyUpsertInput!]!): [UserHierarchyUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserHierarchySoftRemove(input: UserHierarchySoftRemoveInput!): UserHierarchySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserHierarchyRemove(input: UserHierarchyRemoveInput!): UserHierarchyRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserHierarchyRecover(input: UserHierarchyRecoverInput!): UserHierarchyRecoverOutput!

  """
  Upload files for given single record id. You can also upload multiple files for same record at once but cannot upload multiple fields files for same record. Each upload field needs to be provided in request body. Simple rule is must be one record one field with single or multiple files at a time. Returns saved file(s) info.
  """
  UserFileUpload(attachment: [Upload!]!, input: UserFileUploadInput!): [UserFileUploadOutput!]!

  """
  Delete uploaded files for given single record id. You can also delete multiple files for same record at once. This is as per set criteria in entity. Returns deleted file(s) info.
  """
  UserFileUploadDelete(input: [UserFileUploadDeleteInput!]!): [UserFileUploadDeleteOutput!]!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserFileCreate(input: [UserFileCreateInput!]!): [UserFileCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserFileUpdate(input: UserFileUpdateInput!): UserFileUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserFileSoftDelete(input: UserFileSoftDeleteInput!): UserFileSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserFileDelete(input: UserFileDeleteInput!): UserFileDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserFileRestore(input: UserFileRestoreInput!): UserFileRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserFileUpsert(input: [UserFileUpsertInput!]!): [UserFileUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserFileSoftRemove(input: UserFileSoftRemoveInput!): UserFileSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserFileRemove(input: UserFileRemoveInput!): UserFileRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserFileRecover(input: UserFileRecoverInput!): UserFileRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserFavCreate(input: [UserFavCreateInput!]!): [UserFavCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserFavUpdate(input: UserFavUpdateInput!): UserFavUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserFavSoftDelete(input: UserFavSoftDeleteInput!): UserFavSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserFavDelete(input: UserFavDeleteInput!): UserFavDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserFavRestore(input: UserFavRestoreInput!): UserFavRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserFavUpsert(input: [UserFavUpsertInput!]!): [UserFavUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserFavSoftRemove(input: UserFavSoftRemoveInput!): UserFavSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserFavRemove(input: UserFavRemoveInput!): UserFavRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserFavRecover(input: UserFavRecoverInput!): UserFavRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserFavCategoryCreate(input: [UserFavCategoryCreateInput!]!): [UserFavCategoryCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserFavCategoryUpdate(input: UserFavCategoryUpdateInput!): UserFavCategoryUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserFavCategorySoftDelete(input: UserFavCategorySoftDeleteInput!): UserFavCategorySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserFavCategoryDelete(input: UserFavCategoryDeleteInput!): UserFavCategoryDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserFavCategoryRestore(input: UserFavCategoryRestoreInput!): UserFavCategoryRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserFavCategoryUpsert(input: [UserFavCategoryUpsertInput!]!): [UserFavCategoryUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserFavCategorySoftRemove(input: UserFavCategorySoftRemoveInput!): UserFavCategorySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserFavCategoryRemove(input: UserFavCategoryRemoveInput!): UserFavCategoryRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserFavCategoryRecover(input: UserFavCategoryRecoverInput!): UserFavCategoryRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  AcademicFieldCreate(input: [AcademicFieldCreateInput!]!): [AcademicFieldCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  AcademicFieldUpdate(input: AcademicFieldUpdateInput!): AcademicFieldUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  AcademicFieldSoftDelete(input: AcademicFieldSoftDeleteInput!): AcademicFieldSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  AcademicFieldDelete(input: AcademicFieldDeleteInput!): AcademicFieldDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  AcademicFieldRestore(input: AcademicFieldRestoreInput!): AcademicFieldRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  AcademicFieldUpsert(input: [AcademicFieldUpsertInput!]!): [AcademicFieldUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  AcademicFieldSoftRemove(input: AcademicFieldSoftRemoveInput!): AcademicFieldSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  AcademicFieldRemove(input: AcademicFieldRemoveInput!): AcademicFieldRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  AcademicFieldRecover(input: AcademicFieldRecoverInput!): AcademicFieldRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  AcademicDegreeCreate(input: [AcademicDegreeCreateInput!]!): [AcademicDegreeCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  AcademicDegreeUpdate(input: AcademicDegreeUpdateInput!): AcademicDegreeUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  AcademicDegreeSoftDelete(input: AcademicDegreeSoftDeleteInput!): AcademicDegreeSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  AcademicDegreeDelete(input: AcademicDegreeDeleteInput!): AcademicDegreeDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  AcademicDegreeRestore(input: AcademicDegreeRestoreInput!): AcademicDegreeRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  AcademicDegreeUpsert(input: [AcademicDegreeUpsertInput!]!): [AcademicDegreeUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  AcademicDegreeSoftRemove(input: AcademicDegreeSoftRemoveInput!): AcademicDegreeSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  AcademicDegreeRemove(input: AcademicDegreeRemoveInput!): AcademicDegreeRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  AcademicDegreeRecover(input: AcademicDegreeRecoverInput!): AcademicDegreeRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  WebhookResponseCreate(input: [WebhookResponseCreateInput!]!): [WebhookResponseCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  WebhookResponseUpdate(input: WebhookResponseUpdateInput!): WebhookResponseUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  WebhookResponseSoftDelete(input: WebhookResponseSoftDeleteInput!): WebhookResponseSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  WebhookResponseDelete(input: WebhookResponseDeleteInput!): WebhookResponseDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  WebhookResponseRestore(input: WebhookResponseRestoreInput!): WebhookResponseRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  WebhookResponseUpsert(input: [WebhookResponseUpsertInput!]!): [WebhookResponseUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  WebhookResponseSoftRemove(input: WebhookResponseSoftRemoveInput!): WebhookResponseSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  WebhookResponseRemove(input: WebhookResponseRemoveInput!): WebhookResponseRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  WebhookResponseRecover(input: WebhookResponseRecoverInput!): WebhookResponseRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  WebhookResponseDataCreate(input: [WebhookResponseDataCreateInput!]!): [WebhookResponseDataCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  WebhookResponseDataUpdate(input: WebhookResponseDataUpdateInput!): WebhookResponseDataUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  WebhookResponseDataSoftDelete(input: WebhookResponseDataSoftDeleteInput!): WebhookResponseDataSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  WebhookResponseDataDelete(input: WebhookResponseDataDeleteInput!): WebhookResponseDataDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  WebhookResponseDataRestore(input: WebhookResponseDataRestoreInput!): WebhookResponseDataRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  WebhookResponseDataUpsert(input: [WebhookResponseDataUpsertInput!]!): [WebhookResponseDataUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  WebhookResponseDataSoftRemove(input: WebhookResponseDataSoftRemoveInput!): WebhookResponseDataSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  WebhookResponseDataRemove(input: WebhookResponseDataRemoveInput!): WebhookResponseDataRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  WebhookResponseDataRecover(input: WebhookResponseDataRecoverInput!): WebhookResponseDataRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LeadCreate(input: [LeadCreateInput!]!): [LeadCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  LeadUpdate(input: LeadUpdateInput!): LeadUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  LeadSoftDelete(input: LeadSoftDeleteInput!): LeadSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  LeadDelete(input: LeadDeleteInput!): LeadDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  LeadRestore(input: LeadRestoreInput!): LeadRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LeadUpsert(input: [LeadUpsertInput!]!): [LeadUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  LeadSoftRemove(input: LeadSoftRemoveInput!): LeadSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LeadRemove(input: LeadRemoveInput!): LeadRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LeadRecover(input: LeadRecoverInput!): LeadRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ConnectionSourceCreate(input: [ConnectionSourceCreateInput!]!): [ConnectionSourceCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ConnectionSourceUpdate(input: ConnectionSourceUpdateInput!): ConnectionSourceUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ConnectionSourceSoftDelete(input: ConnectionSourceSoftDeleteInput!): ConnectionSourceSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ConnectionSourceDelete(input: ConnectionSourceDeleteInput!): ConnectionSourceDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ConnectionSourceRestore(input: ConnectionSourceRestoreInput!): ConnectionSourceRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ConnectionSourceUpsert(input: [ConnectionSourceUpsertInput!]!): [ConnectionSourceUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ConnectionSourceSoftRemove(input: ConnectionSourceSoftRemoveInput!): ConnectionSourceSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ConnectionSourceRemove(input: ConnectionSourceRemoveInput!): ConnectionSourceRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ConnectionSourceRecover(input: ConnectionSourceRecoverInput!): ConnectionSourceRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ConnectionSourceCategoriesCreate(input: [ConnectionSourceCategoriesCreateInput!]!): [ConnectionSourceCategoriesCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  ConnectionSourceCategoriesUpdate(input: ConnectionSourceCategoriesUpdateInput!): ConnectionSourceCategoriesUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  ConnectionSourceCategoriesSoftDelete(input: ConnectionSourceCategoriesSoftDeleteInput!): ConnectionSourceCategoriesSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  ConnectionSourceCategoriesDelete(input: ConnectionSourceCategoriesDeleteInput!): ConnectionSourceCategoriesDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  ConnectionSourceCategoriesRestore(input: ConnectionSourceCategoriesRestoreInput!): ConnectionSourceCategoriesRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  ConnectionSourceCategoriesUpsert(input: [ConnectionSourceCategoriesUpsertInput!]!): [ConnectionSourceCategoriesUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  ConnectionSourceCategoriesSoftRemove(input: ConnectionSourceCategoriesSoftRemoveInput!): ConnectionSourceCategoriesSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ConnectionSourceCategoriesRemove(input: ConnectionSourceCategoriesRemoveInput!): ConnectionSourceCategoriesRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  ConnectionSourceCategoriesRecover(input: ConnectionSourceCategoriesRecoverInput!): ConnectionSourceCategoriesRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LeadFollowupCreate(input: [LeadFollowupCreateInput!]!): [LeadFollowupCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  LeadFollowupUpdate(input: LeadFollowupUpdateInput!): LeadFollowupUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  LeadFollowupSoftDelete(input: LeadFollowupSoftDeleteInput!): LeadFollowupSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  LeadFollowupDelete(input: LeadFollowupDeleteInput!): LeadFollowupDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  LeadFollowupRestore(input: LeadFollowupRestoreInput!): LeadFollowupRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LeadFollowupUpsert(input: [LeadFollowupUpsertInput!]!): [LeadFollowupUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  LeadFollowupSoftRemove(input: LeadFollowupSoftRemoveInput!): LeadFollowupSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LeadFollowupRemove(input: LeadFollowupRemoveInput!): LeadFollowupRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LeadFollowupRecover(input: LeadFollowupRecoverInput!): LeadFollowupRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LeadFollowupStatusCreate(input: [LeadFollowupStatusCreateInput!]!): [LeadFollowupStatusCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  LeadFollowupStatusUpdate(input: LeadFollowupStatusUpdateInput!): LeadFollowupStatusUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  LeadFollowupStatusSoftDelete(input: LeadFollowupStatusSoftDeleteInput!): LeadFollowupStatusSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  LeadFollowupStatusDelete(input: LeadFollowupStatusDeleteInput!): LeadFollowupStatusDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  LeadFollowupStatusRestore(input: LeadFollowupStatusRestoreInput!): LeadFollowupStatusRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LeadFollowupStatusUpsert(input: [LeadFollowupStatusUpsertInput!]!): [LeadFollowupStatusUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  LeadFollowupStatusSoftRemove(input: LeadFollowupStatusSoftRemoveInput!): LeadFollowupStatusSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LeadFollowupStatusRemove(input: LeadFollowupStatusRemoveInput!): LeadFollowupStatusRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LeadFollowupStatusRecover(input: LeadFollowupStatusRecoverInput!): LeadFollowupStatusRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LeadFollowupViaCreate(input: [LeadFollowupViaCreateInput!]!): [LeadFollowupViaCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  LeadFollowupViaUpdate(input: LeadFollowupViaUpdateInput!): LeadFollowupViaUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  LeadFollowupViaSoftDelete(input: LeadFollowupViaSoftDeleteInput!): LeadFollowupViaSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  LeadFollowupViaDelete(input: LeadFollowupViaDeleteInput!): LeadFollowupViaDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  LeadFollowupViaRestore(input: LeadFollowupViaRestoreInput!): LeadFollowupViaRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LeadFollowupViaUpsert(input: [LeadFollowupViaUpsertInput!]!): [LeadFollowupViaUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  LeadFollowupViaSoftRemove(input: LeadFollowupViaSoftRemoveInput!): LeadFollowupViaSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LeadFollowupViaRemove(input: LeadFollowupViaRemoveInput!): LeadFollowupViaRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LeadFollowupViaRecover(input: LeadFollowupViaRecoverInput!): LeadFollowupViaRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LeadPotentialCreate(input: [LeadPotentialCreateInput!]!): [LeadPotentialCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  LeadPotentialUpdate(input: LeadPotentialUpdateInput!): LeadPotentialUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  LeadPotentialSoftDelete(input: LeadPotentialSoftDeleteInput!): LeadPotentialSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  LeadPotentialDelete(input: LeadPotentialDeleteInput!): LeadPotentialDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  LeadPotentialRestore(input: LeadPotentialRestoreInput!): LeadPotentialRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  LeadPotentialUpsert(input: [LeadPotentialUpsertInput!]!): [LeadPotentialUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  LeadPotentialSoftRemove(input: LeadPotentialSoftRemoveInput!): LeadPotentialSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LeadPotentialRemove(input: LeadPotentialRemoveInput!): LeadPotentialRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  LeadPotentialRecover(input: LeadPotentialRecoverInput!): LeadPotentialRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  WebPageMasterCreate(input: [WebPageMasterCreateInput!]!): [WebPageMasterCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  WebPageMasterUpdate(input: WebPageMasterUpdateInput!): WebPageMasterUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  WebPageMasterSoftDelete(input: WebPageMasterSoftDeleteInput!): WebPageMasterSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  WebPageMasterDelete(input: WebPageMasterDeleteInput!): WebPageMasterDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  WebPageMasterRestore(input: WebPageMasterRestoreInput!): WebPageMasterRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  WebPageMasterUpsert(input: [WebPageMasterUpsertInput!]!): [WebPageMasterUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  WebPageMasterSoftRemove(input: WebPageMasterSoftRemoveInput!): WebPageMasterSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  WebPageMasterRemove(input: WebPageMasterRemoveInput!): WebPageMasterRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  WebPageMasterRecover(input: WebPageMasterRecoverInput!): WebPageMasterRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  WebPageHierarchyCreate(input: [WebPageHierarchyCreateInput!]!): [WebPageHierarchyCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  WebPageHierarchyUpdate(input: WebPageHierarchyUpdateInput!): WebPageHierarchyUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  WebPageHierarchySoftDelete(input: WebPageHierarchySoftDeleteInput!): WebPageHierarchySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  WebPageHierarchyDelete(input: WebPageHierarchyDeleteInput!): WebPageHierarchyDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  WebPageHierarchyRestore(input: WebPageHierarchyRestoreInput!): WebPageHierarchyRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  WebPageHierarchyUpsert(input: [WebPageHierarchyUpsertInput!]!): [WebPageHierarchyUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  WebPageHierarchySoftRemove(input: WebPageHierarchySoftRemoveInput!): WebPageHierarchySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  WebPageHierarchyRemove(input: WebPageHierarchyRemoveInput!): WebPageHierarchyRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  WebPageHierarchyRecover(input: WebPageHierarchyRecoverInput!): WebPageHierarchyRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  NewsLetterCreate(input: [NewsLetterCreateInput!]!): [NewsLetterCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  NewsLetterUpdate(input: NewsLetterUpdateInput!): NewsLetterUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  NewsLetterSoftDelete(input: NewsLetterSoftDeleteInput!): NewsLetterSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  NewsLetterDelete(input: NewsLetterDeleteInput!): NewsLetterDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  NewsLetterRestore(input: NewsLetterRestoreInput!): NewsLetterRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  NewsLetterUpsert(input: [NewsLetterUpsertInput!]!): [NewsLetterUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  NewsLetterSoftRemove(input: NewsLetterSoftRemoveInput!): NewsLetterSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  NewsLetterRemove(input: NewsLetterRemoveInput!): NewsLetterRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  NewsLetterRecover(input: NewsLetterRecoverInput!): NewsLetterRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  NewsLetterScheduleCreate(input: [NewsLetterScheduleCreateInput!]!): [NewsLetterScheduleCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  NewsLetterScheduleUpdate(input: NewsLetterScheduleUpdateInput!): NewsLetterScheduleUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  NewsLetterScheduleSoftDelete(input: NewsLetterScheduleSoftDeleteInput!): NewsLetterScheduleSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  NewsLetterScheduleDelete(input: NewsLetterScheduleDeleteInput!): NewsLetterScheduleDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  NewsLetterScheduleRestore(input: NewsLetterScheduleRestoreInput!): NewsLetterScheduleRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  NewsLetterScheduleUpsert(input: [NewsLetterScheduleUpsertInput!]!): [NewsLetterScheduleUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  NewsLetterScheduleSoftRemove(input: NewsLetterScheduleSoftRemoveInput!): NewsLetterScheduleSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  NewsLetterScheduleRemove(input: NewsLetterScheduleRemoveInput!): NewsLetterScheduleRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  NewsLetterScheduleRecover(input: NewsLetterScheduleRecoverInput!): NewsLetterScheduleRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  NewsLetterTrackLogCreate(input: [NewsLetterTrackLogCreateInput!]!): [NewsLetterTrackLogCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  NewsLetterTrackLogUpdate(input: NewsLetterTrackLogUpdateInput!): NewsLetterTrackLogUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  NewsLetterTrackLogSoftDelete(input: NewsLetterTrackLogSoftDeleteInput!): NewsLetterTrackLogSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  NewsLetterTrackLogDelete(input: NewsLetterTrackLogDeleteInput!): NewsLetterTrackLogDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  NewsLetterTrackLogRestore(input: NewsLetterTrackLogRestoreInput!): NewsLetterTrackLogRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  NewsLetterTrackLogUpsert(input: [NewsLetterTrackLogUpsertInput!]!): [NewsLetterTrackLogUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  NewsLetterTrackLogSoftRemove(input: NewsLetterTrackLogSoftRemoveInput!): NewsLetterTrackLogSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  NewsLetterTrackLogRemove(input: NewsLetterTrackLogRemoveInput!): NewsLetterTrackLogRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  NewsLetterTrackLogRecover(input: NewsLetterTrackLogRecoverInput!): NewsLetterTrackLogRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  NewsLetterUserCreate(input: [NewsLetterUserCreateInput!]!): [NewsLetterUserCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  NewsLetterUserUpdate(input: NewsLetterUserUpdateInput!): NewsLetterUserUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  NewsLetterUserSoftDelete(input: NewsLetterUserSoftDeleteInput!): NewsLetterUserSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  NewsLetterUserDelete(input: NewsLetterUserDeleteInput!): NewsLetterUserDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  NewsLetterUserRestore(input: NewsLetterUserRestoreInput!): NewsLetterUserRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  NewsLetterUserUpsert(input: [NewsLetterUserUpsertInput!]!): [NewsLetterUserUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  NewsLetterUserSoftRemove(input: NewsLetterUserSoftRemoveInput!): NewsLetterUserSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  NewsLetterUserRemove(input: NewsLetterUserRemoveInput!): NewsLetterUserRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  NewsLetterUserRecover(input: NewsLetterUserRecoverInput!): NewsLetterUserRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  NewsLetterCategoryCreate(input: [NewsLetterCategoryCreateInput!]!): [NewsLetterCategoryCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  NewsLetterCategoryUpdate(input: NewsLetterCategoryUpdateInput!): NewsLetterCategoryUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  NewsLetterCategorySoftDelete(input: NewsLetterCategorySoftDeleteInput!): NewsLetterCategorySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  NewsLetterCategoryDelete(input: NewsLetterCategoryDeleteInput!): NewsLetterCategoryDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  NewsLetterCategoryRestore(input: NewsLetterCategoryRestoreInput!): NewsLetterCategoryRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  NewsLetterCategoryUpsert(input: [NewsLetterCategoryUpsertInput!]!): [NewsLetterCategoryUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  NewsLetterCategorySoftRemove(input: NewsLetterCategorySoftRemoveInput!): NewsLetterCategorySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  NewsLetterCategoryRemove(input: NewsLetterCategoryRemoveInput!): NewsLetterCategoryRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  NewsLetterCategoryRecover(input: NewsLetterCategoryRecoverInput!): NewsLetterCategoryRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserNewsLetterSubscriptionCreate(input: [UserNewsLetterSubscriptionCreateInput!]!): [UserNewsLetterSubscriptionCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  UserNewsLetterSubscriptionUpdate(input: UserNewsLetterSubscriptionUpdateInput!): UserNewsLetterSubscriptionUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  UserNewsLetterSubscriptionSoftDelete(input: UserNewsLetterSubscriptionSoftDeleteInput!): UserNewsLetterSubscriptionSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  UserNewsLetterSubscriptionDelete(input: UserNewsLetterSubscriptionDeleteInput!): UserNewsLetterSubscriptionDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  UserNewsLetterSubscriptionRestore(input: UserNewsLetterSubscriptionRestoreInput!): UserNewsLetterSubscriptionRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  UserNewsLetterSubscriptionUpsert(input: [UserNewsLetterSubscriptionUpsertInput!]!): [UserNewsLetterSubscriptionUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  UserNewsLetterSubscriptionSoftRemove(input: UserNewsLetterSubscriptionSoftRemoveInput!): UserNewsLetterSubscriptionSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserNewsLetterSubscriptionRemove(input: UserNewsLetterSubscriptionRemoveInput!): UserNewsLetterSubscriptionRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  UserNewsLetterSubscriptionRecover(input: UserNewsLetterSubscriptionRecoverInput!): UserNewsLetterSubscriptionRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  FaqCreate(input: [FaqCreateInput!]!): [FaqCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  FaqUpdate(input: FaqUpdateInput!): FaqUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  FaqSoftDelete(input: FaqSoftDeleteInput!): FaqSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  FaqDelete(input: FaqDeleteInput!): FaqDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  FaqRestore(input: FaqRestoreInput!): FaqRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  FaqUpsert(input: [FaqUpsertInput!]!): [FaqUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  FaqSoftRemove(input: FaqSoftRemoveInput!): FaqSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  FaqRemove(input: FaqRemoveInput!): FaqRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  FaqRecover(input: FaqRecoverInput!): FaqRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  FaqCategoryCreate(input: [FaqCategoryCreateInput!]!): [FaqCategoryCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  FaqCategoryUpdate(input: FaqCategoryUpdateInput!): FaqCategoryUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  FaqCategorySoftDelete(input: FaqCategorySoftDeleteInput!): FaqCategorySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  FaqCategoryDelete(input: FaqCategoryDeleteInput!): FaqCategoryDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  FaqCategoryRestore(input: FaqCategoryRestoreInput!): FaqCategoryRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  FaqCategoryUpsert(input: [FaqCategoryUpsertInput!]!): [FaqCategoryUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  FaqCategorySoftRemove(input: FaqCategorySoftRemoveInput!): FaqCategorySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  FaqCategoryRemove(input: FaqCategoryRemoveInput!): FaqCategoryRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  FaqCategoryRecover(input: FaqCategoryRecoverInput!): FaqCategoryRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  MeasurementUnitCreate(input: [MeasurementUnitCreateInput!]!): [MeasurementUnitCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  MeasurementUnitUpdate(input: MeasurementUnitUpdateInput!): MeasurementUnitUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  MeasurementUnitSoftDelete(input: MeasurementUnitSoftDeleteInput!): MeasurementUnitSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  MeasurementUnitDelete(input: MeasurementUnitDeleteInput!): MeasurementUnitDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  MeasurementUnitRestore(input: MeasurementUnitRestoreInput!): MeasurementUnitRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  MeasurementUnitUpsert(input: [MeasurementUnitUpsertInput!]!): [MeasurementUnitUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  MeasurementUnitSoftRemove(input: MeasurementUnitSoftRemoveInput!): MeasurementUnitSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  MeasurementUnitRemove(input: MeasurementUnitRemoveInput!): MeasurementUnitRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  MeasurementUnitRecover(input: MeasurementUnitRecoverInput!): MeasurementUnitRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  MeasurementCategoryCreate(input: [MeasurementCategoryCreateInput!]!): [MeasurementCategoryCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  MeasurementCategoryUpdate(input: MeasurementCategoryUpdateInput!): MeasurementCategoryUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  MeasurementCategorySoftDelete(input: MeasurementCategorySoftDeleteInput!): MeasurementCategorySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  MeasurementCategoryDelete(input: MeasurementCategoryDeleteInput!): MeasurementCategoryDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  MeasurementCategoryRestore(input: MeasurementCategoryRestoreInput!): MeasurementCategoryRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  MeasurementCategoryUpsert(input: [MeasurementCategoryUpsertInput!]!): [MeasurementCategoryUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  MeasurementCategorySoftRemove(input: MeasurementCategorySoftRemoveInput!): MeasurementCategorySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  MeasurementCategoryRemove(input: MeasurementCategoryRemoveInput!): MeasurementCategoryRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  MeasurementCategoryRecover(input: MeasurementCategoryRecoverInput!): MeasurementCategoryRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  BusinessPrimaryCategoryCreate(input: [BusinessPrimaryCategoryCreateInput!]!): [BusinessPrimaryCategoryCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  BusinessPrimaryCategoryUpdate(input: BusinessPrimaryCategoryUpdateInput!): BusinessPrimaryCategoryUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  BusinessPrimaryCategorySoftDelete(input: BusinessPrimaryCategorySoftDeleteInput!): BusinessPrimaryCategorySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  BusinessPrimaryCategoryDelete(input: BusinessPrimaryCategoryDeleteInput!): BusinessPrimaryCategoryDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  BusinessPrimaryCategoryRestore(input: BusinessPrimaryCategoryRestoreInput!): BusinessPrimaryCategoryRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  BusinessPrimaryCategoryUpsert(input: [BusinessPrimaryCategoryUpsertInput!]!): [BusinessPrimaryCategoryUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  BusinessPrimaryCategorySoftRemove(input: BusinessPrimaryCategorySoftRemoveInput!): BusinessPrimaryCategorySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  BusinessPrimaryCategoryRemove(input: BusinessPrimaryCategoryRemoveInput!): BusinessPrimaryCategoryRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  BusinessPrimaryCategoryRecover(input: BusinessPrimaryCategoryRecoverInput!): BusinessPrimaryCategoryRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  BusinessSecondaryCategoryCreate(input: [BusinessSecondaryCategoryCreateInput!]!): [BusinessSecondaryCategoryCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  BusinessSecondaryCategoryUpdate(input: BusinessSecondaryCategoryUpdateInput!): BusinessSecondaryCategoryUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  BusinessSecondaryCategorySoftDelete(input: BusinessSecondaryCategorySoftDeleteInput!): BusinessSecondaryCategorySoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  BusinessSecondaryCategoryDelete(input: BusinessSecondaryCategoryDeleteInput!): BusinessSecondaryCategoryDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  BusinessSecondaryCategoryRestore(input: BusinessSecondaryCategoryRestoreInput!): BusinessSecondaryCategoryRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  BusinessSecondaryCategoryUpsert(input: [BusinessSecondaryCategoryUpsertInput!]!): [BusinessSecondaryCategoryUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  BusinessSecondaryCategorySoftRemove(input: BusinessSecondaryCategorySoftRemoveInput!): BusinessSecondaryCategorySoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  BusinessSecondaryCategoryRemove(input: BusinessSecondaryCategoryRemoveInput!): BusinessSecondaryCategoryRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  BusinessSecondaryCategoryRecover(input: BusinessSecondaryCategoryRecoverInput!): BusinessSecondaryCategoryRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  BusinessCreate(input: [BusinessCreateInput!]!): [BusinessCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  BusinessUpdate(input: BusinessUpdateInput!): BusinessUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  BusinessSoftDelete(input: BusinessSoftDeleteInput!): BusinessSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  BusinessDelete(input: BusinessDeleteInput!): BusinessDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  BusinessRestore(input: BusinessRestoreInput!): BusinessRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  BusinessUpsert(input: [BusinessUpsertInput!]!): [BusinessUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  BusinessSoftRemove(input: BusinessSoftRemoveInput!): BusinessSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  BusinessRemove(input: BusinessRemoveInput!): BusinessRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  BusinessRecover(input: BusinessRecoverInput!): BusinessRecoverOutput!

  """
  Create new record in entity. You can also create multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  CrawlerLeadCreate(input: [CrawlerLeadCreateInput!]!): [CrawlerLeadCreateOutput!]!

  """
  Update records, as per provided where criteria. This is easy, quick and simple way for majority of update operation.
  """
  CrawlerLeadUpdate(input: CrawlerLeadUpdateInput!): CrawlerLeadUpdateOutput!

  """
  Start soft delete records. This is safe for mass delete and it performs very fast. Unlike soft remove softDelete do not perform data check and directly perform soft delete. This can be restored or recorved but do not return processed data in return.
  """
  CrawlerLeadSoftDelete(input: CrawlerLeadSoftDeleteInput!): CrawlerLeadSoftDeleteOutput!

  """
  Delete records, which cannot be recovered or restored. Unlike remove delete do not check record in database before it perform delete operation, so its fast. Do not provide processed data in return.
  """
  CrawlerLeadDelete(input: CrawlerLeadDeleteInput!): CrawlerLeadDeleteOutput!

  """
  Restore records, which are soft deleted or removed. Unline recover restore do not check record in database before it perform restore operation, so its fast. You will affected records numbers only in return.
  """
  CrawlerLeadRestore(input: CrawlerLeadRestoreInput!): CrawlerLeadRestoreOutput!

  """
  Upsert new record in entity. It can insert and update at the same time. You can also upsert multiple records at once. Returns only saved data, not relation data set with other entities.
  """
  CrawlerLeadUpsert(input: [CrawlerLeadUpsertInput!]!): [CrawlerLeadUpsertOutput!]!

  """
  Start soft remove records, which can be recovered or restored. Checked the user in database before it perform remove operation. This is safe for mass delete and accidentally data loss. First perform soft remove and after you can go for remove and delete.
  """
  CrawlerLeadSoftRemove(input: CrawlerLeadSoftRemoveInput!): CrawlerLeadSoftRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  CrawlerLeadRemove(input: CrawlerLeadRemoveInput!): CrawlerLeadRemoveOutput!

  """
  Remove records, which cannot be recovered or restored. Checked the record in database before it perform remove operation. You will get removed records in return.
  """
  CrawlerLeadRecover(input: CrawlerLeadRecoverInput!): CrawlerLeadRecoverOutput!
}

input NewsLetterCategoryCreateInput {
  """Title of the email template."""
  title: String!

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime
}

type NewsLetterCategoryCreateOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletter categories of the Newsletter."""
  fr_newsletters: [NewsLetterEntity!]

  """Newsletter categories of the User Newsletter Subscription."""
  fr_user_newsletters_subscriptions: [UserNewsLetterSubscriptionEntity!]
}

input NewsLetterCategoryDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterCategoryDeleteInputWhere!]
}

input NewsLetterCategoryDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletter categories of the Newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletter categories of the User Newsletter Subscription."""
  fr_user_newsletters_subscriptions: [UserNewsLetterSubscriptionFindInputWhere!]
}

type NewsLetterCategoryDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type NewsLetterCategoryEntity {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletter categories of the Newsletter."""
  fr_newsletters: [NewsLetterEntity!]

  """Newsletter categories of the User Newsletter Subscription."""
  fr_user_newsletters_subscriptions: [UserNewsLetterSubscriptionEntity!]
}

input NewsLetterCategoryFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterCategoryFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: NewsLetterCategoryFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: NewsLetterCategoryFindInputSortOrder
}

input NewsLetterCategoryFindInputGroupBy {
  title: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input NewsLetterCategoryFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input NewsLetterCategoryFindInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletter categories of the Newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletter categories of the User Newsletter Subscription."""
  fr_user_newsletters_subscriptions: [UserNewsLetterSubscriptionFindInputWhere!]
}

input NewsLetterCategoryFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type NewsLetterCategoryFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [NewsLetterCategoryEntity!]!
}

input NewsLetterCategoryRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterCategoryRecoverInputWhere!]
}

input NewsLetterCategoryRecoverInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletter categories of the Newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletter categories of the User Newsletter Subscription."""
  fr_user_newsletters_subscriptions: [UserNewsLetterSubscriptionFindInputWhere!]
}

type NewsLetterCategoryRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterCategoryEntity!]!
}

input NewsLetterCategoryRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterCategoryRemoveInputWhere!]
}

input NewsLetterCategoryRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletter categories of the Newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletter categories of the User Newsletter Subscription."""
  fr_user_newsletters_subscriptions: [UserNewsLetterSubscriptionFindInputWhere!]
}

type NewsLetterCategoryRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterCategoryEntity!]!
}

input NewsLetterCategoryRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterCategoryRestoreInputWhere!]
}

input NewsLetterCategoryRestoreInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletter categories of the Newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletter categories of the User Newsletter Subscription."""
  fr_user_newsletters_subscriptions: [UserNewsLetterSubscriptionFindInputWhere!]
}

type NewsLetterCategoryRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input NewsLetterCategorySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterCategorySoftDeleteInputWhere!]
}

input NewsLetterCategorySoftDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletter categories of the Newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletter categories of the User Newsletter Subscription."""
  fr_user_newsletters_subscriptions: [UserNewsLetterSubscriptionFindInputWhere!]
}

type NewsLetterCategorySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input NewsLetterCategorySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterCategorySoftRemoveInputWhere!]
}

input NewsLetterCategorySoftRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletter categories of the Newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletter categories of the User Newsletter Subscription."""
  fr_user_newsletters_subscriptions: [UserNewsLetterSubscriptionFindInputWhere!]
}

type NewsLetterCategorySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterCategoryEntity!]!
}

input NewsLetterCategoryUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterCategoryUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: NewsLetterCategoryUpdateInputSets!
}

input NewsLetterCategoryUpdateInputSets {
  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime
}

input NewsLetterCategoryUpdateInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """Indicates if email template active or not."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletter categories of the Newsletter."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletter categories of the User Newsletter Subscription."""
  fr_user_newsletters_subscriptions: [UserNewsLetterSubscriptionFindInputWhere!]
}

type NewsLetterCategoryUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [NewsLetterCategoryEntity!]!
}

input NewsLetterCategoryUpsertInput {
  """Title of the email template."""
  title: String!

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """Unique ID of the email template, auto generated. undefined"""
  id: Int
}

type NewsLetterCategoryUpsertOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """Description of the email template."""
  desc: String

  """Indicates if email template active or not."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletter categories of the Newsletter."""
  fr_newsletters: [NewsLetterEntity!]

  """Newsletter categories of the User Newsletter Subscription."""
  fr_user_newsletters_subscriptions: [UserNewsLetterSubscriptionEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input NewsLetterCreateInput {
  """Template id of the newsletter."""
  etmpl_id: Int!

  """Categories for newsletter."""
  nlcat_id: Int

  """Third Party ID of the newsletter."""
  tppltf_id: Int!

  """Title of the newsletter."""
  title: String!

  """Subject of the newsletter."""
  subject: String

  """Content body of the newsletter."""
  content: String

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: YesNoEnum!

  """The ID of the user who added the entry."""
  created_u_id: Int!

  """The AR ID of the user who added the entry."""
  created_ar_id: Int!

  """Indicates if the active or not in the newsletter."""
  active: DateTime
}

type NewsLetterCreateOutput {
  """Unique ID of the newsletter, auto generated."""
  id: Int

  """Template id of the newsletter."""
  etmpl_id: Int

  """Categories for newsletter."""
  nlcat_id: Int

  """Third Party ID of the newsletter."""
  tppltf_id: Int

  """Title of the newsletter."""
  title: String

  """Subject of the newsletter."""
  subject: String

  """Content body of the newsletter."""
  content: String

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: YesNoEnum

  """The ID of the user who added the entry."""
  created_u_id: Int

  """The AR ID of the user who added the entry."""
  created_ar_id: Int

  """Indicates if the active or not in the newsletter."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Email Templates of NewsLetter."""
  fr_email_templates: EmailTemplateEntity

  """Users of NewsLetter."""
  fr_users: UserEntity

  """Third party platform of NewsLetter."""
  fr_nl_third_party_platform: ThirdPartyPlatformEntity

  """Authorization roles of NewsLetter."""
  fr_authorization_roles: AuthorisationEntity

  """News letter schedule for this news letter."""
  fr_nl_schedule: [NewsLetterScheduleEntity!]

  """News letter tracking log for this news letter."""
  fr_nl_tracking_log: [NewsLetterTrackLogEntity!]

  """News letter user for this news letter."""
  fr_nl_user: [NewsLetterUserEntity!]

  """Categories for this news letter."""
  fr_nl_category: NewsLetterCategoryEntity
}

input NewsLetterDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterDeleteInputWhere!]
}

input NewsLetterDeleteInputWhere {
  """Unique ID of the newsletter, auto generated."""
  id: FindOperatorDto

  """Template id of the newsletter."""
  etmpl_id: FindOperatorDto

  """Categories for newsletter."""
  nlcat_id: FindOperatorDto

  """Third Party ID of the newsletter."""
  tppltf_id: FindOperatorDto

  """Title of the newsletter."""
  title: FindOperatorDto

  """Subject of the newsletter."""
  subject: FindOperatorDto

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: FindOperatorDto

  """The ID of the user who added the entry."""
  created_u_id: FindOperatorDto

  """The AR ID of the user who added the entry."""
  created_ar_id: FindOperatorDto

  """Indicates if the active or not in the newsletter."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email Templates of NewsLetter."""
  fr_email_templates: [EmailTemplateFindInputWhere!]

  """Third party platform of NewsLetter."""
  fr_nl_third_party_platform: [ThirdPartyPlatformFindInputWhere!]

  """Users of NewsLetter."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of NewsLetter."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Categories for this news letter."""
  fr_nl_category: [NewsLetterCategoryFindInputWhere!]

  """News letter schedule for this news letter."""
  fr_nl_schedule: [NewsLetterScheduleFindInputWhere!]

  """News letter tracking log for this news letter."""
  fr_nl_tracking_log: [NewsLetterScheduleFindInputWhere!]

  """News letter user for this news letter."""
  fr_nl_user: [NewsLetterScheduleFindInputWhere!]
}

type NewsLetterDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type NewsLetterEntity {
  """Unique ID of the newsletter, auto generated."""
  id: Int

  """Template id of the newsletter."""
  etmpl_id: Int

  """Categories for newsletter."""
  nlcat_id: Int

  """Third Party ID of the newsletter."""
  tppltf_id: Int

  """Title of the newsletter."""
  title: String

  """Subject of the newsletter."""
  subject: String

  """Content body of the newsletter."""
  content: String

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: YesNoEnum

  """The ID of the user who added the entry."""
  created_u_id: Int

  """The AR ID of the user who added the entry."""
  created_ar_id: Int

  """Indicates if the active or not in the newsletter."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Email Templates of NewsLetter."""
  fr_email_templates: EmailTemplateEntity

  """Users of NewsLetter."""
  fr_users: UserEntity

  """Third party platform of NewsLetter."""
  fr_nl_third_party_platform: ThirdPartyPlatformEntity

  """Authorization roles of NewsLetter."""
  fr_authorization_roles: AuthorisationEntity

  """News letter schedule for this news letter."""
  fr_nl_schedule: [NewsLetterScheduleEntity!]

  """News letter tracking log for this news letter."""
  fr_nl_tracking_log: [NewsLetterTrackLogEntity!]

  """News letter user for this news letter."""
  fr_nl_user: [NewsLetterUserEntity!]

  """Categories for this news letter."""
  fr_nl_category: NewsLetterCategoryEntity
}

input NewsLetterFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: NewsLetterFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: NewsLetterFindInputSortOrder
}

input NewsLetterFindInputGroupBy {
  etmpl_id: Boolean
  nlcat_id: Boolean
  tppltf_id: Boolean
  title: Boolean
  subject: Boolean
  use_default: Boolean
  created_u_id: Boolean
  created_ar_id: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input NewsLetterFindInputSortOrder {
  id: RecordSortDirectionEnum
  etmpl_id: RecordSortDirectionEnum
  nlcat_id: RecordSortDirectionEnum
  tppltf_id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  subject: RecordSortDirectionEnum
  use_default: RecordSortDirectionEnum
  created_u_id: RecordSortDirectionEnum
  created_ar_id: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input NewsLetterFindInputWhere {
  """Unique ID of the newsletter, auto generated."""
  id: FindOperatorDto

  """Template id of the newsletter."""
  etmpl_id: FindOperatorDto

  """Categories for newsletter."""
  nlcat_id: FindOperatorDto

  """Third Party ID of the newsletter."""
  tppltf_id: FindOperatorDto

  """Title of the newsletter."""
  title: FindOperatorDto

  """Subject of the newsletter."""
  subject: FindOperatorDto

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: FindOperatorDto

  """The ID of the user who added the entry."""
  created_u_id: FindOperatorDto

  """The AR ID of the user who added the entry."""
  created_ar_id: FindOperatorDto

  """Indicates if the active or not in the newsletter."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email Templates of NewsLetter."""
  fr_email_templates: [EmailTemplateFindInputWhere!]

  """Third party platform of NewsLetter."""
  fr_nl_third_party_platform: [ThirdPartyPlatformFindInputWhere!]

  """Users of NewsLetter."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of NewsLetter."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Categories for this news letter."""
  fr_nl_category: [NewsLetterCategoryFindInputWhere!]

  """News letter schedule for this news letter."""
  fr_nl_schedule: [NewsLetterScheduleFindInputWhere!]

  """News letter tracking log for this news letter."""
  fr_nl_tracking_log: [NewsLetterScheduleFindInputWhere!]

  """News letter user for this news letter."""
  fr_nl_user: [NewsLetterScheduleFindInputWhere!]
}

input NewsLetterFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type NewsLetterFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [NewsLetterEntity!]!
}

input NewsLetterRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterRecoverInputWhere!]
}

input NewsLetterRecoverInputWhere {
  """Unique ID of the newsletter, auto generated."""
  id: FindOperatorDto

  """Template id of the newsletter."""
  etmpl_id: FindOperatorDto

  """Categories for newsletter."""
  nlcat_id: FindOperatorDto

  """Third Party ID of the newsletter."""
  tppltf_id: FindOperatorDto

  """Title of the newsletter."""
  title: FindOperatorDto

  """Subject of the newsletter."""
  subject: FindOperatorDto

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: FindOperatorDto

  """The ID of the user who added the entry."""
  created_u_id: FindOperatorDto

  """The AR ID of the user who added the entry."""
  created_ar_id: FindOperatorDto

  """Indicates if the active or not in the newsletter."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email Templates of NewsLetter."""
  fr_email_templates: [EmailTemplateFindInputWhere!]

  """Third party platform of NewsLetter."""
  fr_nl_third_party_platform: [ThirdPartyPlatformFindInputWhere!]

  """Users of NewsLetter."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of NewsLetter."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Categories for this news letter."""
  fr_nl_category: [NewsLetterCategoryFindInputWhere!]

  """News letter schedule for this news letter."""
  fr_nl_schedule: [NewsLetterScheduleFindInputWhere!]

  """News letter tracking log for this news letter."""
  fr_nl_tracking_log: [NewsLetterScheduleFindInputWhere!]

  """News letter user for this news letter."""
  fr_nl_user: [NewsLetterScheduleFindInputWhere!]
}

type NewsLetterRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterEntity!]!
}

input NewsLetterRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterRemoveInputWhere!]
}

input NewsLetterRemoveInputWhere {
  """Unique ID of the newsletter, auto generated."""
  id: FindOperatorDto

  """Template id of the newsletter."""
  etmpl_id: FindOperatorDto

  """Categories for newsletter."""
  nlcat_id: FindOperatorDto

  """Third Party ID of the newsletter."""
  tppltf_id: FindOperatorDto

  """Title of the newsletter."""
  title: FindOperatorDto

  """Subject of the newsletter."""
  subject: FindOperatorDto

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: FindOperatorDto

  """The ID of the user who added the entry."""
  created_u_id: FindOperatorDto

  """The AR ID of the user who added the entry."""
  created_ar_id: FindOperatorDto

  """Indicates if the active or not in the newsletter."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email Templates of NewsLetter."""
  fr_email_templates: [EmailTemplateFindInputWhere!]

  """Third party platform of NewsLetter."""
  fr_nl_third_party_platform: [ThirdPartyPlatformFindInputWhere!]

  """Users of NewsLetter."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of NewsLetter."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Categories for this news letter."""
  fr_nl_category: [NewsLetterCategoryFindInputWhere!]

  """News letter schedule for this news letter."""
  fr_nl_schedule: [NewsLetterScheduleFindInputWhere!]

  """News letter tracking log for this news letter."""
  fr_nl_tracking_log: [NewsLetterScheduleFindInputWhere!]

  """News letter user for this news letter."""
  fr_nl_user: [NewsLetterScheduleFindInputWhere!]
}

type NewsLetterRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterEntity!]!
}

input NewsLetterRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterRestoreInputWhere!]
}

input NewsLetterRestoreInputWhere {
  """Unique ID of the newsletter, auto generated."""
  id: FindOperatorDto

  """Template id of the newsletter."""
  etmpl_id: FindOperatorDto

  """Categories for newsletter."""
  nlcat_id: FindOperatorDto

  """Third Party ID of the newsletter."""
  tppltf_id: FindOperatorDto

  """Title of the newsletter."""
  title: FindOperatorDto

  """Subject of the newsletter."""
  subject: FindOperatorDto

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: FindOperatorDto

  """The ID of the user who added the entry."""
  created_u_id: FindOperatorDto

  """The AR ID of the user who added the entry."""
  created_ar_id: FindOperatorDto

  """Indicates if the active or not in the newsletter."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email Templates of NewsLetter."""
  fr_email_templates: [EmailTemplateFindInputWhere!]

  """Third party platform of NewsLetter."""
  fr_nl_third_party_platform: [ThirdPartyPlatformFindInputWhere!]

  """Users of NewsLetter."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of NewsLetter."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Categories for this news letter."""
  fr_nl_category: [NewsLetterCategoryFindInputWhere!]

  """News letter schedule for this news letter."""
  fr_nl_schedule: [NewsLetterScheduleFindInputWhere!]

  """News letter tracking log for this news letter."""
  fr_nl_tracking_log: [NewsLetterScheduleFindInputWhere!]

  """News letter user for this news letter."""
  fr_nl_user: [NewsLetterScheduleFindInputWhere!]
}

type NewsLetterRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input NewsLetterScheduleCreateInput {
  """NewsLetter ID of the newsletter schedule."""
  nl_id: Int!

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: DateTime!

  """The total record associated with this newsletter schedule."""
  total_record: Int!

  """
  The record number of the last successfully sent newsletter in this schedule.
  """
  sent_last_rec_no: Int!

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: DateTime

  """The current status of the newsletter schedule."""
  wrkstatus_id: Int

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: Int

  """The ID of the user who added the newsletter schedule."""
  created_u_id: Int!

  """The type of entity that added the newsletter schedule."""
  created_ar_id: Int!

  """Indicates whether the newsletter schedule is currently active."""
  active: DateTime
}

type NewsLetterScheduleCreateOutput {
  """Unique ID of the newsletter schedule, auto generated."""
  id: Int

  """NewsLetter ID of the newsletter schedule."""
  nl_id: Int

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: DateTime

  """The total record associated with this newsletter schedule."""
  total_record: Int

  """
  The record number of the last successfully sent newsletter in this schedule.
  """
  sent_last_rec_no: Int

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: DateTime

  """The current status of the newsletter schedule."""
  wrkstatus_id: Int

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: Int

  """The ID of the user who added the newsletter schedule."""
  created_u_id: Int

  """The type of entity that added the newsletter schedule."""
  created_ar_id: Int

  """Indicates whether the newsletter schedule is currently active."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """NewsLetter of Newsletter schedule."""
  fr_newsletters: NewsLetterEntity

  """Users of Newsletter schedule."""
  fr_users: UserEntity

  """Authorization roles of Newsletter schedule."""
  fr_authorization_roles: AuthorisationEntity

  """Users of Newsletter schedule."""
  fr_nl_user: [NewsLetterUserEntity!]

  """Status of Newsletter schedule."""
  fr_work_status: WorkStatusEntity

  """Approval status of Newsletter schedule."""
  fr_approval_wrkstatus: WorkStatusEntity
}

input NewsLetterScheduleDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterScheduleDeleteInputWhere!]
}

input NewsLetterScheduleDeleteInputWhere {
  """Unique ID of the newsletter schedule, auto generated."""
  id: FindOperatorDto

  """NewsLetter ID of the newsletter schedule."""
  nl_id: FindOperatorDto

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: FindOperatorDto

  """The total record associated with this newsletter schedule."""
  total_record: FindOperatorDto

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: FindOperatorDto

  """The current status of the newsletter schedule."""
  wrkstatus_id: FindOperatorDto

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: FindOperatorDto

  """The ID of the user who added the newsletter schedule."""
  created_u_id: FindOperatorDto

  """The type of entity that added the newsletter schedule."""
  created_ar_id: FindOperatorDto

  """Indicates whether the newsletter schedule is currently active."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """NewsLetter of Newsletter schedule."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of Newsletter schedule."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Status of Newsletter schedule."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Approval status of Newsletter schedule."""
  fr_approval_wrkstatus: [WorkStatusFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_nl_user: [NewsLetterUserFindInputWhere!]
}

type NewsLetterScheduleDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type NewsLetterScheduleEntity {
  """Unique ID of the newsletter schedule, auto generated."""
  id: Int

  """NewsLetter ID of the newsletter schedule."""
  nl_id: Int

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: DateTime

  """The total record associated with this newsletter schedule."""
  total_record: Int

  """
  The record number of the last successfully sent newsletter in this schedule.
  """
  sent_last_rec_no: Int

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: DateTime

  """The current status of the newsletter schedule."""
  wrkstatus_id: Int

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: Int

  """The ID of the user who added the newsletter schedule."""
  created_u_id: Int

  """The type of entity that added the newsletter schedule."""
  created_ar_id: Int

  """Indicates whether the newsletter schedule is currently active."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """NewsLetter of Newsletter schedule."""
  fr_newsletters: NewsLetterEntity

  """Users of Newsletter schedule."""
  fr_users: UserEntity

  """Authorization roles of Newsletter schedule."""
  fr_authorization_roles: AuthorisationEntity

  """Users of Newsletter schedule."""
  fr_nl_user: [NewsLetterUserEntity!]

  """Status of Newsletter schedule."""
  fr_work_status: WorkStatusEntity

  """Approval status of Newsletter schedule."""
  fr_approval_wrkstatus: WorkStatusEntity
}

input NewsLetterScheduleFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterScheduleFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: NewsLetterScheduleFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: NewsLetterScheduleFindInputSortOrder
}

input NewsLetterScheduleFindInputGroupBy {
  nl_id: Boolean
  scheduled: Boolean
  total_record: Boolean
  completed: Boolean
  wrkstatus_id: Boolean
  approval_wrkstatus_id: Boolean
  created_u_id: Boolean
  created_ar_id: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input NewsLetterScheduleFindInputSortOrder {
  id: RecordSortDirectionEnum
  nl_id: RecordSortDirectionEnum
  scheduled: RecordSortDirectionEnum
  total_record: RecordSortDirectionEnum
  completed: RecordSortDirectionEnum
  wrkstatus_id: RecordSortDirectionEnum
  approval_wrkstatus_id: RecordSortDirectionEnum
  created_u_id: RecordSortDirectionEnum
  created_ar_id: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input NewsLetterScheduleFindInputWhere {
  """Unique ID of the newsletter schedule, auto generated."""
  id: FindOperatorDto

  """NewsLetter ID of the newsletter schedule."""
  nl_id: FindOperatorDto

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: FindOperatorDto

  """The total record associated with this newsletter schedule."""
  total_record: FindOperatorDto

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: FindOperatorDto

  """The current status of the newsletter schedule."""
  wrkstatus_id: FindOperatorDto

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: FindOperatorDto

  """The ID of the user who added the newsletter schedule."""
  created_u_id: FindOperatorDto

  """The type of entity that added the newsletter schedule."""
  created_ar_id: FindOperatorDto

  """Indicates whether the newsletter schedule is currently active."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """NewsLetter of Newsletter schedule."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of Newsletter schedule."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Status of Newsletter schedule."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Approval status of Newsletter schedule."""
  fr_approval_wrkstatus: [WorkStatusFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_nl_user: [NewsLetterUserFindInputWhere!]
}

input NewsLetterScheduleFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type NewsLetterScheduleFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [NewsLetterScheduleEntity!]!
}

input NewsLetterScheduleRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterScheduleRecoverInputWhere!]
}

input NewsLetterScheduleRecoverInputWhere {
  """Unique ID of the newsletter schedule, auto generated."""
  id: FindOperatorDto

  """NewsLetter ID of the newsletter schedule."""
  nl_id: FindOperatorDto

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: FindOperatorDto

  """The total record associated with this newsletter schedule."""
  total_record: FindOperatorDto

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: FindOperatorDto

  """The current status of the newsletter schedule."""
  wrkstatus_id: FindOperatorDto

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: FindOperatorDto

  """The ID of the user who added the newsletter schedule."""
  created_u_id: FindOperatorDto

  """The type of entity that added the newsletter schedule."""
  created_ar_id: FindOperatorDto

  """Indicates whether the newsletter schedule is currently active."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """NewsLetter of Newsletter schedule."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of Newsletter schedule."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Status of Newsletter schedule."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Approval status of Newsletter schedule."""
  fr_approval_wrkstatus: [WorkStatusFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_nl_user: [NewsLetterUserFindInputWhere!]
}

type NewsLetterScheduleRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterScheduleEntity!]!
}

input NewsLetterScheduleRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterScheduleRemoveInputWhere!]
}

input NewsLetterScheduleRemoveInputWhere {
  """Unique ID of the newsletter schedule, auto generated."""
  id: FindOperatorDto

  """NewsLetter ID of the newsletter schedule."""
  nl_id: FindOperatorDto

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: FindOperatorDto

  """The total record associated with this newsletter schedule."""
  total_record: FindOperatorDto

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: FindOperatorDto

  """The current status of the newsletter schedule."""
  wrkstatus_id: FindOperatorDto

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: FindOperatorDto

  """The ID of the user who added the newsletter schedule."""
  created_u_id: FindOperatorDto

  """The type of entity that added the newsletter schedule."""
  created_ar_id: FindOperatorDto

  """Indicates whether the newsletter schedule is currently active."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """NewsLetter of Newsletter schedule."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of Newsletter schedule."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Status of Newsletter schedule."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Approval status of Newsletter schedule."""
  fr_approval_wrkstatus: [WorkStatusFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_nl_user: [NewsLetterUserFindInputWhere!]
}

type NewsLetterScheduleRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterScheduleEntity!]!
}

input NewsLetterScheduleRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterScheduleRestoreInputWhere!]
}

input NewsLetterScheduleRestoreInputWhere {
  """Unique ID of the newsletter schedule, auto generated."""
  id: FindOperatorDto

  """NewsLetter ID of the newsletter schedule."""
  nl_id: FindOperatorDto

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: FindOperatorDto

  """The total record associated with this newsletter schedule."""
  total_record: FindOperatorDto

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: FindOperatorDto

  """The current status of the newsletter schedule."""
  wrkstatus_id: FindOperatorDto

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: FindOperatorDto

  """The ID of the user who added the newsletter schedule."""
  created_u_id: FindOperatorDto

  """The type of entity that added the newsletter schedule."""
  created_ar_id: FindOperatorDto

  """Indicates whether the newsletter schedule is currently active."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """NewsLetter of Newsletter schedule."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of Newsletter schedule."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Status of Newsletter schedule."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Approval status of Newsletter schedule."""
  fr_approval_wrkstatus: [WorkStatusFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_nl_user: [NewsLetterUserFindInputWhere!]
}

type NewsLetterScheduleRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input NewsLetterScheduleSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterScheduleSoftDeleteInputWhere!]
}

input NewsLetterScheduleSoftDeleteInputWhere {
  """Unique ID of the newsletter schedule, auto generated."""
  id: FindOperatorDto

  """NewsLetter ID of the newsletter schedule."""
  nl_id: FindOperatorDto

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: FindOperatorDto

  """The total record associated with this newsletter schedule."""
  total_record: FindOperatorDto

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: FindOperatorDto

  """The current status of the newsletter schedule."""
  wrkstatus_id: FindOperatorDto

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: FindOperatorDto

  """The ID of the user who added the newsletter schedule."""
  created_u_id: FindOperatorDto

  """The type of entity that added the newsletter schedule."""
  created_ar_id: FindOperatorDto

  """Indicates whether the newsletter schedule is currently active."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """NewsLetter of Newsletter schedule."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of Newsletter schedule."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Status of Newsletter schedule."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Approval status of Newsletter schedule."""
  fr_approval_wrkstatus: [WorkStatusFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_nl_user: [NewsLetterUserFindInputWhere!]
}

type NewsLetterScheduleSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input NewsLetterScheduleSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterScheduleSoftRemoveInputWhere!]
}

input NewsLetterScheduleSoftRemoveInputWhere {
  """Unique ID of the newsletter schedule, auto generated."""
  id: FindOperatorDto

  """NewsLetter ID of the newsletter schedule."""
  nl_id: FindOperatorDto

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: FindOperatorDto

  """The total record associated with this newsletter schedule."""
  total_record: FindOperatorDto

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: FindOperatorDto

  """The current status of the newsletter schedule."""
  wrkstatus_id: FindOperatorDto

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: FindOperatorDto

  """The ID of the user who added the newsletter schedule."""
  created_u_id: FindOperatorDto

  """The type of entity that added the newsletter schedule."""
  created_ar_id: FindOperatorDto

  """Indicates whether the newsletter schedule is currently active."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """NewsLetter of Newsletter schedule."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of Newsletter schedule."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Status of Newsletter schedule."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Approval status of Newsletter schedule."""
  fr_approval_wrkstatus: [WorkStatusFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_nl_user: [NewsLetterUserFindInputWhere!]
}

type NewsLetterScheduleSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterScheduleEntity!]!
}

input NewsLetterScheduleUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterScheduleUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: NewsLetterScheduleUpdateInputSets!
}

input NewsLetterScheduleUpdateInputSets {
  """NewsLetter ID of the newsletter schedule."""
  nl_id: Int

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: DateTime

  """The total record associated with this newsletter schedule."""
  total_record: Int

  """
  The record number of the last successfully sent newsletter in this schedule.
  """
  sent_last_rec_no: Int

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: DateTime

  """The current status of the newsletter schedule."""
  wrkstatus_id: Int

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: Int

  """The ID of the user who added the newsletter schedule."""
  created_u_id: Int

  """The type of entity that added the newsletter schedule."""
  created_ar_id: Int

  """Indicates whether the newsletter schedule is currently active."""
  active: DateTime
}

input NewsLetterScheduleUpdateInputWhere {
  """Unique ID of the newsletter schedule, auto generated."""
  id: FindOperatorDto

  """NewsLetter ID of the newsletter schedule."""
  nl_id: FindOperatorDto

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: FindOperatorDto

  """The total record associated with this newsletter schedule."""
  total_record: FindOperatorDto

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: FindOperatorDto

  """The current status of the newsletter schedule."""
  wrkstatus_id: FindOperatorDto

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: FindOperatorDto

  """The ID of the user who added the newsletter schedule."""
  created_u_id: FindOperatorDto

  """The type of entity that added the newsletter schedule."""
  created_ar_id: FindOperatorDto

  """Indicates whether the newsletter schedule is currently active."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """NewsLetter of Newsletter schedule."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of Newsletter schedule."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Status of Newsletter schedule."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Approval status of Newsletter schedule."""
  fr_approval_wrkstatus: [WorkStatusFindInputWhere!]

  """Users of Newsletter schedule."""
  fr_nl_user: [NewsLetterUserFindInputWhere!]
}

type NewsLetterScheduleUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [NewsLetterScheduleEntity!]!
}

input NewsLetterScheduleUpsertInput {
  """NewsLetter ID of the newsletter schedule."""
  nl_id: Int!

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: DateTime!

  """The total record associated with this newsletter schedule."""
  total_record: Int!

  """
  The record number of the last successfully sent newsletter in this schedule.
  """
  sent_last_rec_no: Int!

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: DateTime

  """The current status of the newsletter schedule."""
  wrkstatus_id: Int

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: Int

  """The ID of the user who added the newsletter schedule."""
  created_u_id: Int!

  """The type of entity that added the newsletter schedule."""
  created_ar_id: Int!

  """Indicates whether the newsletter schedule is currently active."""
  active: DateTime

  """Unique ID of the newsletter schedule, auto generated. undefined"""
  id: Int
}

type NewsLetterScheduleUpsertOutput {
  """Unique ID of the newsletter schedule, auto generated."""
  id: Int

  """NewsLetter ID of the newsletter schedule."""
  nl_id: Int

  """The scheduled date for when the newsletter is set to be sent."""
  scheduled: DateTime

  """The total record associated with this newsletter schedule."""
  total_record: Int

  """
  The record number of the last successfully sent newsletter in this schedule.
  """
  sent_last_rec_no: Int

  """
  Indicates whether the newsletter schedule has been marked as completed.
  """
  completed: DateTime

  """The current status of the newsletter schedule."""
  wrkstatus_id: Int

  """The approval status of the newsletter schedule."""
  approval_wrkstatus_id: Int

  """The ID of the user who added the newsletter schedule."""
  created_u_id: Int

  """The type of entity that added the newsletter schedule."""
  created_ar_id: Int

  """Indicates whether the newsletter schedule is currently active."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """NewsLetter of Newsletter schedule."""
  fr_newsletters: NewsLetterEntity

  """Users of Newsletter schedule."""
  fr_users: UserEntity

  """Authorization roles of Newsletter schedule."""
  fr_authorization_roles: AuthorisationEntity

  """Users of Newsletter schedule."""
  fr_nl_user: [NewsLetterUserEntity!]

  """Status of Newsletter schedule."""
  fr_work_status: WorkStatusEntity

  """Approval status of Newsletter schedule."""
  fr_approval_wrkstatus: WorkStatusEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input NewsLetterSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterSoftDeleteInputWhere!]
}

input NewsLetterSoftDeleteInputWhere {
  """Unique ID of the newsletter, auto generated."""
  id: FindOperatorDto

  """Template id of the newsletter."""
  etmpl_id: FindOperatorDto

  """Categories for newsletter."""
  nlcat_id: FindOperatorDto

  """Third Party ID of the newsletter."""
  tppltf_id: FindOperatorDto

  """Title of the newsletter."""
  title: FindOperatorDto

  """Subject of the newsletter."""
  subject: FindOperatorDto

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: FindOperatorDto

  """The ID of the user who added the entry."""
  created_u_id: FindOperatorDto

  """The AR ID of the user who added the entry."""
  created_ar_id: FindOperatorDto

  """Indicates if the active or not in the newsletter."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email Templates of NewsLetter."""
  fr_email_templates: [EmailTemplateFindInputWhere!]

  """Third party platform of NewsLetter."""
  fr_nl_third_party_platform: [ThirdPartyPlatformFindInputWhere!]

  """Users of NewsLetter."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of NewsLetter."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Categories for this news letter."""
  fr_nl_category: [NewsLetterCategoryFindInputWhere!]

  """News letter schedule for this news letter."""
  fr_nl_schedule: [NewsLetterScheduleFindInputWhere!]

  """News letter tracking log for this news letter."""
  fr_nl_tracking_log: [NewsLetterScheduleFindInputWhere!]

  """News letter user for this news letter."""
  fr_nl_user: [NewsLetterScheduleFindInputWhere!]
}

type NewsLetterSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input NewsLetterSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterSoftRemoveInputWhere!]
}

input NewsLetterSoftRemoveInputWhere {
  """Unique ID of the newsletter, auto generated."""
  id: FindOperatorDto

  """Template id of the newsletter."""
  etmpl_id: FindOperatorDto

  """Categories for newsletter."""
  nlcat_id: FindOperatorDto

  """Third Party ID of the newsletter."""
  tppltf_id: FindOperatorDto

  """Title of the newsletter."""
  title: FindOperatorDto

  """Subject of the newsletter."""
  subject: FindOperatorDto

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: FindOperatorDto

  """The ID of the user who added the entry."""
  created_u_id: FindOperatorDto

  """The AR ID of the user who added the entry."""
  created_ar_id: FindOperatorDto

  """Indicates if the active or not in the newsletter."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email Templates of NewsLetter."""
  fr_email_templates: [EmailTemplateFindInputWhere!]

  """Third party platform of NewsLetter."""
  fr_nl_third_party_platform: [ThirdPartyPlatformFindInputWhere!]

  """Users of NewsLetter."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of NewsLetter."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Categories for this news letter."""
  fr_nl_category: [NewsLetterCategoryFindInputWhere!]

  """News letter schedule for this news letter."""
  fr_nl_schedule: [NewsLetterScheduleFindInputWhere!]

  """News letter tracking log for this news letter."""
  fr_nl_tracking_log: [NewsLetterScheduleFindInputWhere!]

  """News letter user for this news letter."""
  fr_nl_user: [NewsLetterScheduleFindInputWhere!]
}

type NewsLetterSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterEntity!]!
}

input NewsLetterTrackLogCreateInput {
  """Newsletter Id of the newsletter tracking log."""
  nl_id: Int!

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: Int!

  """Opens of the newsletter tracking log."""
  opens: Int!

  """Clicks of the newsletter tracking log."""
  clicks: Int!

  """Clicks of the newsletter tracking log."""
  bounces: Int!

  """Bounce type of the newsletter tracking log."""
  bounce_type: BounceTypeEnum!

  """Bounce reason of the newsletter tracking log."""
  bounce_reason: String

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: DateTime

  """Spam of the newsletter tracking log."""
  spam: DateTime

  """Device Id of the newsletter tracking log."""
  device_id: Int!

  """City Id of the newsletter tracking log."""
  city_id: Int!

  """IP of the newsletter tracking log."""
  ip: String!
}

type NewsLetterTrackLogCreateOutput {
  """Unique ID of the newsletter tracking log, auto generated."""
  id: Int

  """Newsletter Id of the newsletter tracking log."""
  nl_id: Int

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: Int

  """Opens of the newsletter tracking log."""
  opens: Int

  """Clicks of the newsletter tracking log."""
  clicks: Int

  """Clicks of the newsletter tracking log."""
  bounces: Int

  """Bounce type of the newsletter tracking log."""
  bounce_type: BounceTypeEnum

  """Bounce reason of the newsletter tracking log."""
  bounce_reason: String

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: DateTime

  """Spam of the newsletter tracking log."""
  spam: DateTime

  """Device Id of the newsletter tracking log."""
  device_id: Int

  """City Id of the newsletter tracking log."""
  city_id: Int

  """IP of the newsletter tracking log."""
  ip: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletters of NewsLetter Track Log."""
  fr_newsletters: NewsLetterEntity

  """Newsletters users of NewsLetter Track Log."""
  fr_nl_users: NewsLetterUserEntity

  """Device of NewsLetter Track Log."""
  fr_devices: DeviceEntity

  """City of NewsLetter Track Log."""
  fr_city: CityEntity
}

input NewsLetterTrackLogDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterTrackLogDeleteInputWhere!]
}

input NewsLetterTrackLogDeleteInputWhere {
  """Unique ID of the newsletter tracking log, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter tracking log."""
  nl_id: FindOperatorDto

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: FindOperatorDto

  """Opens of the newsletter tracking log."""
  opens: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  clicks: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  bounces: FindOperatorDto

  """Bounce type of the newsletter tracking log."""
  bounce_type: FindOperatorDto

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: FindOperatorDto

  """Spam of the newsletter tracking log."""
  spam: FindOperatorDto

  """Device Id of the newsletter tracking log."""
  device_id: FindOperatorDto

  """City Id of the newsletter tracking log."""
  city_id: FindOperatorDto

  """IP of the newsletter tracking log."""
  ip: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of NewsLetter Track Log."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters users of NewsLetter Track Log."""
  fr_nl_users: [NewsLetterUserFindInputWhere!]

  """Device of NewsLetter Track Log."""
  fr_devices: [DeviceFindInputWhere!]

  """City of NewsLetter Track Log."""
  fr_city: [CityFindInputWhere!]
}

type NewsLetterTrackLogDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type NewsLetterTrackLogEntity {
  """Unique ID of the newsletter tracking log, auto generated."""
  id: Int

  """Newsletter Id of the newsletter tracking log."""
  nl_id: Int

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: Int

  """Opens of the newsletter tracking log."""
  opens: Int

  """Clicks of the newsletter tracking log."""
  clicks: Int

  """Clicks of the newsletter tracking log."""
  bounces: Int

  """Bounce type of the newsletter tracking log."""
  bounce_type: BounceTypeEnum

  """Bounce reason of the newsletter tracking log."""
  bounce_reason: String

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: DateTime

  """Spam of the newsletter tracking log."""
  spam: DateTime

  """Device Id of the newsletter tracking log."""
  device_id: Int

  """City Id of the newsletter tracking log."""
  city_id: Int

  """IP of the newsletter tracking log."""
  ip: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletters of NewsLetter Track Log."""
  fr_newsletters: NewsLetterEntity

  """Newsletters users of NewsLetter Track Log."""
  fr_nl_users: NewsLetterUserEntity

  """Device of NewsLetter Track Log."""
  fr_devices: DeviceEntity

  """City of NewsLetter Track Log."""
  fr_city: CityEntity
}

input NewsLetterTrackLogFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterTrackLogFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: NewsLetterTrackLogFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: NewsLetterTrackLogFindInputSortOrder
}

input NewsLetterTrackLogFindInputGroupBy {
  nl_id: Boolean
  nlu_id: Boolean
  opens: Boolean
  clicks: Boolean
  bounces: Boolean
  bounce_type: Boolean
  unsubscribe: Boolean
  spam: Boolean
  device_id: Boolean
  city_id: Boolean
  ip: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input NewsLetterTrackLogFindInputSortOrder {
  id: RecordSortDirectionEnum
  nl_id: RecordSortDirectionEnum
  nlu_id: RecordSortDirectionEnum
  opens: RecordSortDirectionEnum
  clicks: RecordSortDirectionEnum
  bounces: RecordSortDirectionEnum
  bounce_type: RecordSortDirectionEnum
  unsubscribe: RecordSortDirectionEnum
  spam: RecordSortDirectionEnum
  device_id: RecordSortDirectionEnum
  city_id: RecordSortDirectionEnum
  ip: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input NewsLetterTrackLogFindInputWhere {
  """Unique ID of the newsletter tracking log, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter tracking log."""
  nl_id: FindOperatorDto

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: FindOperatorDto

  """Opens of the newsletter tracking log."""
  opens: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  clicks: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  bounces: FindOperatorDto

  """Bounce type of the newsletter tracking log."""
  bounce_type: FindOperatorDto

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: FindOperatorDto

  """Spam of the newsletter tracking log."""
  spam: FindOperatorDto

  """Device Id of the newsletter tracking log."""
  device_id: FindOperatorDto

  """City Id of the newsletter tracking log."""
  city_id: FindOperatorDto

  """IP of the newsletter tracking log."""
  ip: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of NewsLetter Track Log."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters users of NewsLetter Track Log."""
  fr_nl_users: [NewsLetterUserFindInputWhere!]

  """Device of NewsLetter Track Log."""
  fr_devices: [DeviceFindInputWhere!]

  """City of NewsLetter Track Log."""
  fr_city: [CityFindInputWhere!]
}

input NewsLetterTrackLogFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type NewsLetterTrackLogFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [NewsLetterTrackLogEntity!]!
}

input NewsLetterTrackLogRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterTrackLogRecoverInputWhere!]
}

input NewsLetterTrackLogRecoverInputWhere {
  """Unique ID of the newsletter tracking log, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter tracking log."""
  nl_id: FindOperatorDto

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: FindOperatorDto

  """Opens of the newsletter tracking log."""
  opens: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  clicks: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  bounces: FindOperatorDto

  """Bounce type of the newsletter tracking log."""
  bounce_type: FindOperatorDto

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: FindOperatorDto

  """Spam of the newsletter tracking log."""
  spam: FindOperatorDto

  """Device Id of the newsletter tracking log."""
  device_id: FindOperatorDto

  """City Id of the newsletter tracking log."""
  city_id: FindOperatorDto

  """IP of the newsletter tracking log."""
  ip: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of NewsLetter Track Log."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters users of NewsLetter Track Log."""
  fr_nl_users: [NewsLetterUserFindInputWhere!]

  """Device of NewsLetter Track Log."""
  fr_devices: [DeviceFindInputWhere!]

  """City of NewsLetter Track Log."""
  fr_city: [CityFindInputWhere!]
}

type NewsLetterTrackLogRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterTrackLogEntity!]!
}

input NewsLetterTrackLogRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterTrackLogRemoveInputWhere!]
}

input NewsLetterTrackLogRemoveInputWhere {
  """Unique ID of the newsletter tracking log, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter tracking log."""
  nl_id: FindOperatorDto

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: FindOperatorDto

  """Opens of the newsletter tracking log."""
  opens: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  clicks: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  bounces: FindOperatorDto

  """Bounce type of the newsletter tracking log."""
  bounce_type: FindOperatorDto

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: FindOperatorDto

  """Spam of the newsletter tracking log."""
  spam: FindOperatorDto

  """Device Id of the newsletter tracking log."""
  device_id: FindOperatorDto

  """City Id of the newsletter tracking log."""
  city_id: FindOperatorDto

  """IP of the newsletter tracking log."""
  ip: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of NewsLetter Track Log."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters users of NewsLetter Track Log."""
  fr_nl_users: [NewsLetterUserFindInputWhere!]

  """Device of NewsLetter Track Log."""
  fr_devices: [DeviceFindInputWhere!]

  """City of NewsLetter Track Log."""
  fr_city: [CityFindInputWhere!]
}

type NewsLetterTrackLogRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterTrackLogEntity!]!
}

input NewsLetterTrackLogRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterTrackLogRestoreInputWhere!]
}

input NewsLetterTrackLogRestoreInputWhere {
  """Unique ID of the newsletter tracking log, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter tracking log."""
  nl_id: FindOperatorDto

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: FindOperatorDto

  """Opens of the newsletter tracking log."""
  opens: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  clicks: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  bounces: FindOperatorDto

  """Bounce type of the newsletter tracking log."""
  bounce_type: FindOperatorDto

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: FindOperatorDto

  """Spam of the newsletter tracking log."""
  spam: FindOperatorDto

  """Device Id of the newsletter tracking log."""
  device_id: FindOperatorDto

  """City Id of the newsletter tracking log."""
  city_id: FindOperatorDto

  """IP of the newsletter tracking log."""
  ip: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of NewsLetter Track Log."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters users of NewsLetter Track Log."""
  fr_nl_users: [NewsLetterUserFindInputWhere!]

  """Device of NewsLetter Track Log."""
  fr_devices: [DeviceFindInputWhere!]

  """City of NewsLetter Track Log."""
  fr_city: [CityFindInputWhere!]
}

type NewsLetterTrackLogRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input NewsLetterTrackLogSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterTrackLogSoftDeleteInputWhere!]
}

input NewsLetterTrackLogSoftDeleteInputWhere {
  """Unique ID of the newsletter tracking log, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter tracking log."""
  nl_id: FindOperatorDto

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: FindOperatorDto

  """Opens of the newsletter tracking log."""
  opens: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  clicks: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  bounces: FindOperatorDto

  """Bounce type of the newsletter tracking log."""
  bounce_type: FindOperatorDto

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: FindOperatorDto

  """Spam of the newsletter tracking log."""
  spam: FindOperatorDto

  """Device Id of the newsletter tracking log."""
  device_id: FindOperatorDto

  """City Id of the newsletter tracking log."""
  city_id: FindOperatorDto

  """IP of the newsletter tracking log."""
  ip: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of NewsLetter Track Log."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters users of NewsLetter Track Log."""
  fr_nl_users: [NewsLetterUserFindInputWhere!]

  """Device of NewsLetter Track Log."""
  fr_devices: [DeviceFindInputWhere!]

  """City of NewsLetter Track Log."""
  fr_city: [CityFindInputWhere!]
}

type NewsLetterTrackLogSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input NewsLetterTrackLogSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterTrackLogSoftRemoveInputWhere!]
}

input NewsLetterTrackLogSoftRemoveInputWhere {
  """Unique ID of the newsletter tracking log, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter tracking log."""
  nl_id: FindOperatorDto

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: FindOperatorDto

  """Opens of the newsletter tracking log."""
  opens: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  clicks: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  bounces: FindOperatorDto

  """Bounce type of the newsletter tracking log."""
  bounce_type: FindOperatorDto

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: FindOperatorDto

  """Spam of the newsletter tracking log."""
  spam: FindOperatorDto

  """Device Id of the newsletter tracking log."""
  device_id: FindOperatorDto

  """City Id of the newsletter tracking log."""
  city_id: FindOperatorDto

  """IP of the newsletter tracking log."""
  ip: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of NewsLetter Track Log."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters users of NewsLetter Track Log."""
  fr_nl_users: [NewsLetterUserFindInputWhere!]

  """Device of NewsLetter Track Log."""
  fr_devices: [DeviceFindInputWhere!]

  """City of NewsLetter Track Log."""
  fr_city: [CityFindInputWhere!]
}

type NewsLetterTrackLogSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterTrackLogEntity!]!
}

input NewsLetterTrackLogUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterTrackLogUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: NewsLetterTrackLogUpdateInputSets!
}

input NewsLetterTrackLogUpdateInputSets {
  """Newsletter Id of the newsletter tracking log."""
  nl_id: Int

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: Int

  """Opens of the newsletter tracking log."""
  opens: Int

  """Clicks of the newsletter tracking log."""
  clicks: Int

  """Clicks of the newsletter tracking log."""
  bounces: Int

  """Bounce type of the newsletter tracking log."""
  bounce_type: BounceTypeEnum

  """Bounce reason of the newsletter tracking log."""
  bounce_reason: String

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: DateTime

  """Spam of the newsletter tracking log."""
  spam: DateTime

  """Device Id of the newsletter tracking log."""
  device_id: Int

  """City Id of the newsletter tracking log."""
  city_id: Int

  """IP of the newsletter tracking log."""
  ip: String
}

input NewsLetterTrackLogUpdateInputWhere {
  """Unique ID of the newsletter tracking log, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter tracking log."""
  nl_id: FindOperatorDto

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: FindOperatorDto

  """Opens of the newsletter tracking log."""
  opens: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  clicks: FindOperatorDto

  """Clicks of the newsletter tracking log."""
  bounces: FindOperatorDto

  """Bounce type of the newsletter tracking log."""
  bounce_type: FindOperatorDto

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: FindOperatorDto

  """Spam of the newsletter tracking log."""
  spam: FindOperatorDto

  """Device Id of the newsletter tracking log."""
  device_id: FindOperatorDto

  """City Id of the newsletter tracking log."""
  city_id: FindOperatorDto

  """IP of the newsletter tracking log."""
  ip: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of NewsLetter Track Log."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters users of NewsLetter Track Log."""
  fr_nl_users: [NewsLetterUserFindInputWhere!]

  """Device of NewsLetter Track Log."""
  fr_devices: [DeviceFindInputWhere!]

  """City of NewsLetter Track Log."""
  fr_city: [CityFindInputWhere!]
}

type NewsLetterTrackLogUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [NewsLetterTrackLogEntity!]!
}

input NewsLetterTrackLogUpsertInput {
  """Newsletter Id of the newsletter tracking log."""
  nl_id: Int!

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: Int!

  """Opens of the newsletter tracking log."""
  opens: Int!

  """Clicks of the newsletter tracking log."""
  clicks: Int!

  """Clicks of the newsletter tracking log."""
  bounces: Int!

  """Bounce type of the newsletter tracking log."""
  bounce_type: BounceTypeEnum!

  """Bounce reason of the newsletter tracking log."""
  bounce_reason: String

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: DateTime

  """Spam of the newsletter tracking log."""
  spam: DateTime

  """Device Id of the newsletter tracking log."""
  device_id: Int!

  """City Id of the newsletter tracking log."""
  city_id: Int!

  """IP of the newsletter tracking log."""
  ip: String!

  """Unique ID of the newsletter tracking log, auto generated. undefined"""
  id: Int
}

type NewsLetterTrackLogUpsertOutput {
  """Unique ID of the newsletter tracking log, auto generated."""
  id: Int

  """Newsletter Id of the newsletter tracking log."""
  nl_id: Int

  """Newsletter User Id of the newsletter tracking log."""
  nlu_id: Int

  """Opens of the newsletter tracking log."""
  opens: Int

  """Clicks of the newsletter tracking log."""
  clicks: Int

  """Clicks of the newsletter tracking log."""
  bounces: Int

  """Bounce type of the newsletter tracking log."""
  bounce_type: BounceTypeEnum

  """Bounce reason of the newsletter tracking log."""
  bounce_reason: String

  """Unsubscribe of the newsletter tracking log."""
  unsubscribe: DateTime

  """Spam of the newsletter tracking log."""
  spam: DateTime

  """Device Id of the newsletter tracking log."""
  device_id: Int

  """City Id of the newsletter tracking log."""
  city_id: Int

  """IP of the newsletter tracking log."""
  ip: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletters of NewsLetter Track Log."""
  fr_newsletters: NewsLetterEntity

  """Newsletters users of NewsLetter Track Log."""
  fr_nl_users: NewsLetterUserEntity

  """Device of NewsLetter Track Log."""
  fr_devices: DeviceEntity

  """City of NewsLetter Track Log."""
  fr_city: CityEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input NewsLetterUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: NewsLetterUpdateInputSets!
}

input NewsLetterUpdateInputSets {
  """Template id of the newsletter."""
  etmpl_id: Int

  """Categories for newsletter."""
  nlcat_id: Int

  """Third Party ID of the newsletter."""
  tppltf_id: Int

  """Title of the newsletter."""
  title: String

  """Subject of the newsletter."""
  subject: String

  """Content body of the newsletter."""
  content: String

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: YesNoEnum

  """The ID of the user who added the entry."""
  created_u_id: Int

  """The AR ID of the user who added the entry."""
  created_ar_id: Int

  """Indicates if the active or not in the newsletter."""
  active: DateTime
}

input NewsLetterUpdateInputWhere {
  """Unique ID of the newsletter, auto generated."""
  id: FindOperatorDto

  """Template id of the newsletter."""
  etmpl_id: FindOperatorDto

  """Categories for newsletter."""
  nlcat_id: FindOperatorDto

  """Third Party ID of the newsletter."""
  tppltf_id: FindOperatorDto

  """Title of the newsletter."""
  title: FindOperatorDto

  """Subject of the newsletter."""
  subject: FindOperatorDto

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: FindOperatorDto

  """The ID of the user who added the entry."""
  created_u_id: FindOperatorDto

  """The AR ID of the user who added the entry."""
  created_ar_id: FindOperatorDto

  """Indicates if the active or not in the newsletter."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Email Templates of NewsLetter."""
  fr_email_templates: [EmailTemplateFindInputWhere!]

  """Third party platform of NewsLetter."""
  fr_nl_third_party_platform: [ThirdPartyPlatformFindInputWhere!]

  """Users of NewsLetter."""
  fr_users: [UserFindInputWhere!]

  """Authorization roles of NewsLetter."""
  fr_authorization_roles: [UserAuthorisationFindInputWhere!]

  """Categories for this news letter."""
  fr_nl_category: [NewsLetterCategoryFindInputWhere!]

  """News letter schedule for this news letter."""
  fr_nl_schedule: [NewsLetterScheduleFindInputWhere!]

  """News letter tracking log for this news letter."""
  fr_nl_tracking_log: [NewsLetterScheduleFindInputWhere!]

  """News letter user for this news letter."""
  fr_nl_user: [NewsLetterScheduleFindInputWhere!]
}

type NewsLetterUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [NewsLetterEntity!]!
}

input NewsLetterUpsertInput {
  """Template id of the newsletter."""
  etmpl_id: Int!

  """Categories for newsletter."""
  nlcat_id: Int

  """Third Party ID of the newsletter."""
  tppltf_id: Int!

  """Title of the newsletter."""
  title: String!

  """Subject of the newsletter."""
  subject: String

  """Content body of the newsletter."""
  content: String

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: YesNoEnum!

  """The ID of the user who added the entry."""
  created_u_id: Int!

  """The AR ID of the user who added the entry."""
  created_ar_id: Int!

  """Indicates if the active or not in the newsletter."""
  active: DateTime

  """Unique ID of the newsletter, auto generated. undefined"""
  id: Int
}

type NewsLetterUpsertOutput {
  """Unique ID of the newsletter, auto generated."""
  id: Int

  """Template id of the newsletter."""
  etmpl_id: Int

  """Categories for newsletter."""
  nlcat_id: Int

  """Third Party ID of the newsletter."""
  tppltf_id: Int

  """Title of the newsletter."""
  title: String

  """Subject of the newsletter."""
  subject: String

  """Content body of the newsletter."""
  content: String

  """
  Indicates if the header and footer are included or not in the newsletter.
  """
  use_default: YesNoEnum

  """The ID of the user who added the entry."""
  created_u_id: Int

  """The AR ID of the user who added the entry."""
  created_ar_id: Int

  """Indicates if the active or not in the newsletter."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Email Templates of NewsLetter."""
  fr_email_templates: EmailTemplateEntity

  """Users of NewsLetter."""
  fr_users: UserEntity

  """Third party platform of NewsLetter."""
  fr_nl_third_party_platform: ThirdPartyPlatformEntity

  """Authorization roles of NewsLetter."""
  fr_authorization_roles: AuthorisationEntity

  """News letter schedule for this news letter."""
  fr_nl_schedule: [NewsLetterScheduleEntity!]

  """News letter tracking log for this news letter."""
  fr_nl_tracking_log: [NewsLetterTrackLogEntity!]

  """News letter user for this news letter."""
  fr_nl_user: [NewsLetterUserEntity!]

  """Categories for this news letter."""
  fr_nl_category: NewsLetterCategoryEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input NewsLetterUserCreateInput {
  """Newsletter Id of the newsletter user."""
  nl_id: Int!

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: Int!

  """User Id of the newsletter user."""
  u_id: Int!

  """Sent status of the newsletter user."""
  wrkstatus_id: Int!

  """Sent of the newsletter user."""
  sent: DateTime

  """Sent error of the newsletter user."""
  sent_error: String
}

type NewsLetterUserCreateOutput {
  """Unique ID of the newsletter user, auto generated."""
  id: Int

  """Newsletter Id of the newsletter user."""
  nl_id: Int

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: Int

  """User Id of the newsletter user."""
  u_id: Int

  """Sent status of the newsletter user."""
  wrkstatus_id: Int

  """Sent of the newsletter user."""
  sent: DateTime

  """Sent error of the newsletter user."""
  sent_error: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletters of newsletter user."""
  fr_newsletters: NewsLetterEntity

  """Newsletters Schedules of newsletter user."""
  fr_newsletter_schedules: NewsLetterScheduleEntity

  """Users of the newsletter user."""
  fr_users: UserEntity

  """Newsletter tracking log of the newsletter user."""
  fr_nl_tracking_log_user: [NewsLetterTrackLogEntity!]

  """Work status of the newsletter user."""
  fr_work_status: WorkStatusEntity
}

input NewsLetterUserDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterUserDeleteInputWhere!]
}

input NewsLetterUserDeleteInputWhere {
  """Unique ID of the newsletter user, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter user."""
  nl_id: FindOperatorDto

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: FindOperatorDto

  """User Id of the newsletter user."""
  u_id: FindOperatorDto

  """Sent status of the newsletter user."""
  wrkstatus_id: FindOperatorDto

  """Sent of the newsletter user."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of newsletter user."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters Schedules of newsletter user."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]

  """Users of the newsletter user."""
  fr_users: [UserFindInputWhere!]

  """Work status of the newsletter user."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Newsletter tracking log of the newsletter user."""
  fr_nl_tracking_log_user: [NewsLetterTrackLogFindInputWhere!]
}

type NewsLetterUserDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type NewsLetterUserEntity {
  """Unique ID of the newsletter user, auto generated."""
  id: Int

  """Newsletter Id of the newsletter user."""
  nl_id: Int

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: Int

  """User Id of the newsletter user."""
  u_id: Int

  """Sent status of the newsletter user."""
  wrkstatus_id: Int

  """Sent of the newsletter user."""
  sent: DateTime

  """Sent error of the newsletter user."""
  sent_error: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletters of newsletter user."""
  fr_newsletters: NewsLetterEntity

  """Newsletters Schedules of newsletter user."""
  fr_newsletter_schedules: NewsLetterScheduleEntity

  """Users of the newsletter user."""
  fr_users: UserEntity

  """Newsletter tracking log of the newsletter user."""
  fr_nl_tracking_log_user: [NewsLetterTrackLogEntity!]

  """Work status of the newsletter user."""
  fr_work_status: WorkStatusEntity
}

input NewsLetterUserFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterUserFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: NewsLetterUserFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: NewsLetterUserFindInputSortOrder
}

input NewsLetterUserFindInputGroupBy {
  nl_id: Boolean
  nlsched_id: Boolean
  u_id: Boolean
  wrkstatus_id: Boolean
  sent: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input NewsLetterUserFindInputSortOrder {
  id: RecordSortDirectionEnum
  nl_id: RecordSortDirectionEnum
  nlsched_id: RecordSortDirectionEnum
  u_id: RecordSortDirectionEnum
  wrkstatus_id: RecordSortDirectionEnum
  sent: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input NewsLetterUserFindInputWhere {
  """Unique ID of the newsletter user, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter user."""
  nl_id: FindOperatorDto

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: FindOperatorDto

  """User Id of the newsletter user."""
  u_id: FindOperatorDto

  """Sent status of the newsletter user."""
  wrkstatus_id: FindOperatorDto

  """Sent of the newsletter user."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of newsletter user."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters Schedules of newsletter user."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]

  """Users of the newsletter user."""
  fr_users: [UserFindInputWhere!]

  """Work status of the newsletter user."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Newsletter tracking log of the newsletter user."""
  fr_nl_tracking_log_user: [NewsLetterTrackLogFindInputWhere!]
}

input NewsLetterUserFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type NewsLetterUserFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [NewsLetterUserEntity!]!
}

input NewsLetterUserRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterUserRecoverInputWhere!]
}

input NewsLetterUserRecoverInputWhere {
  """Unique ID of the newsletter user, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter user."""
  nl_id: FindOperatorDto

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: FindOperatorDto

  """User Id of the newsletter user."""
  u_id: FindOperatorDto

  """Sent status of the newsletter user."""
  wrkstatus_id: FindOperatorDto

  """Sent of the newsletter user."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of newsletter user."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters Schedules of newsletter user."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]

  """Users of the newsletter user."""
  fr_users: [UserFindInputWhere!]

  """Work status of the newsletter user."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Newsletter tracking log of the newsletter user."""
  fr_nl_tracking_log_user: [NewsLetterTrackLogFindInputWhere!]
}

type NewsLetterUserRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterUserEntity!]!
}

input NewsLetterUserRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterUserRemoveInputWhere!]
}

input NewsLetterUserRemoveInputWhere {
  """Unique ID of the newsletter user, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter user."""
  nl_id: FindOperatorDto

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: FindOperatorDto

  """User Id of the newsletter user."""
  u_id: FindOperatorDto

  """Sent status of the newsletter user."""
  wrkstatus_id: FindOperatorDto

  """Sent of the newsletter user."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of newsletter user."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters Schedules of newsletter user."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]

  """Users of the newsletter user."""
  fr_users: [UserFindInputWhere!]

  """Work status of the newsletter user."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Newsletter tracking log of the newsletter user."""
  fr_nl_tracking_log_user: [NewsLetterTrackLogFindInputWhere!]
}

type NewsLetterUserRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterUserEntity!]!
}

input NewsLetterUserRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterUserRestoreInputWhere!]
}

input NewsLetterUserRestoreInputWhere {
  """Unique ID of the newsletter user, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter user."""
  nl_id: FindOperatorDto

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: FindOperatorDto

  """User Id of the newsletter user."""
  u_id: FindOperatorDto

  """Sent status of the newsletter user."""
  wrkstatus_id: FindOperatorDto

  """Sent of the newsletter user."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of newsletter user."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters Schedules of newsletter user."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]

  """Users of the newsletter user."""
  fr_users: [UserFindInputWhere!]

  """Work status of the newsletter user."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Newsletter tracking log of the newsletter user."""
  fr_nl_tracking_log_user: [NewsLetterTrackLogFindInputWhere!]
}

type NewsLetterUserRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input NewsLetterUserSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterUserSoftDeleteInputWhere!]
}

input NewsLetterUserSoftDeleteInputWhere {
  """Unique ID of the newsletter user, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter user."""
  nl_id: FindOperatorDto

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: FindOperatorDto

  """User Id of the newsletter user."""
  u_id: FindOperatorDto

  """Sent status of the newsletter user."""
  wrkstatus_id: FindOperatorDto

  """Sent of the newsletter user."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of newsletter user."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters Schedules of newsletter user."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]

  """Users of the newsletter user."""
  fr_users: [UserFindInputWhere!]

  """Work status of the newsletter user."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Newsletter tracking log of the newsletter user."""
  fr_nl_tracking_log_user: [NewsLetterTrackLogFindInputWhere!]
}

type NewsLetterUserSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input NewsLetterUserSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterUserSoftRemoveInputWhere!]
}

input NewsLetterUserSoftRemoveInputWhere {
  """Unique ID of the newsletter user, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter user."""
  nl_id: FindOperatorDto

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: FindOperatorDto

  """User Id of the newsletter user."""
  u_id: FindOperatorDto

  """Sent status of the newsletter user."""
  wrkstatus_id: FindOperatorDto

  """Sent of the newsletter user."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of newsletter user."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters Schedules of newsletter user."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]

  """Users of the newsletter user."""
  fr_users: [UserFindInputWhere!]

  """Work status of the newsletter user."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Newsletter tracking log of the newsletter user."""
  fr_nl_tracking_log_user: [NewsLetterTrackLogFindInputWhere!]
}

type NewsLetterUserSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [NewsLetterUserEntity!]!
}

input NewsLetterUserUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [NewsLetterUserUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: NewsLetterUserUpdateInputSets!
}

input NewsLetterUserUpdateInputSets {
  """Newsletter Id of the newsletter user."""
  nl_id: Int

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: Int

  """User Id of the newsletter user."""
  u_id: Int

  """Sent status of the newsletter user."""
  wrkstatus_id: Int

  """Sent of the newsletter user."""
  sent: DateTime

  """Sent error of the newsletter user."""
  sent_error: String
}

input NewsLetterUserUpdateInputWhere {
  """Unique ID of the newsletter user, auto generated."""
  id: FindOperatorDto

  """Newsletter Id of the newsletter user."""
  nl_id: FindOperatorDto

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: FindOperatorDto

  """User Id of the newsletter user."""
  u_id: FindOperatorDto

  """Sent status of the newsletter user."""
  wrkstatus_id: FindOperatorDto

  """Sent of the newsletter user."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of newsletter user."""
  fr_newsletters: [NewsLetterFindInputWhere!]

  """Newsletters Schedules of newsletter user."""
  fr_newsletter_schedules: [NewsLetterScheduleFindInputWhere!]

  """Users of the newsletter user."""
  fr_users: [UserFindInputWhere!]

  """Work status of the newsletter user."""
  fr_work_status: [WorkStatusFindInputWhere!]

  """Newsletter tracking log of the newsletter user."""
  fr_nl_tracking_log_user: [NewsLetterTrackLogFindInputWhere!]
}

type NewsLetterUserUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [NewsLetterUserEntity!]!
}

input NewsLetterUserUpsertInput {
  """Newsletter Id of the newsletter user."""
  nl_id: Int!

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: Int!

  """User Id of the newsletter user."""
  u_id: Int!

  """Sent status of the newsletter user."""
  wrkstatus_id: Int!

  """Sent of the newsletter user."""
  sent: DateTime

  """Sent error of the newsletter user."""
  sent_error: String

  """Unique ID of the newsletter user, auto generated. undefined"""
  id: Int
}

type NewsLetterUserUpsertOutput {
  """Unique ID of the newsletter user, auto generated."""
  id: Int

  """Newsletter Id of the newsletter user."""
  nl_id: Int

  """Newsletter schedule Id of the newsletter user."""
  nlsched_id: Int

  """User Id of the newsletter user."""
  u_id: Int

  """Sent status of the newsletter user."""
  wrkstatus_id: Int

  """Sent of the newsletter user."""
  sent: DateTime

  """Sent error of the newsletter user."""
  sent_error: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletters of newsletter user."""
  fr_newsletters: NewsLetterEntity

  """Newsletters Schedules of newsletter user."""
  fr_newsletter_schedules: NewsLetterScheduleEntity

  """Users of the newsletter user."""
  fr_users: UserEntity

  """Newsletter tracking log of the newsletter user."""
  fr_nl_tracking_log_user: [NewsLetterTrackLogEntity!]

  """Work status of the newsletter user."""
  fr_work_status: WorkStatusEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""Used at various place for Simple | External Link."""
enum pgTypeEnum {
  """Simple."""
  SIMPLE

  """External link."""
  EXTERNALLINK
}

"""Used at various place for Top | Menu | Footer value."""
enum positionEnum {
  """Top."""
  TOP

  """Menu."""
  MENU

  """Footer."""
  FOOTER
}

input ProcessedSearchByAddressCreateInput {
  """MLSP ID"""
  mlsp_id: Int!

  """Mls num of the processed search by address"""
  mls_num: String!

  """Property type of the processed search by address"""
  property_type: String!

  """Property status of the processed search by address"""
  property_status: String!

  """Address of the processed search by address"""
  address: String!
}

type ProcessedSearchByAddressCreateOutput {
  """Unique ID of the processed search by address, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by address"""
  mls_num: String

  """Property type of the processed search by address"""
  property_type: String

  """Property status of the processed search by address"""
  property_status: String

  """Address of the processed search by address"""
  address: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input ProcessedSearchByAddressDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByAddressDeleteInputWhere!]
}

input ProcessedSearchByAddressDeleteInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """Property status of the processed search by address"""
  property_status: FindOperatorDto

  """Address of the processed search by address"""
  address: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByAddressDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type ProcessedSearchByAddressEntity {
  """Unique ID of the processed search by address, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by address"""
  mls_num: String

  """Property type of the processed search by address"""
  property_type: String

  """Property status of the processed search by address"""
  property_status: String

  """Address of the processed search by address"""
  address: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input ProcessedSearchByAddressFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByAddressFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ProcessedSearchByAddressFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ProcessedSearchByAddressFindInputSortOrder
}

input ProcessedSearchByAddressFindInputGroupBy {
  mlsp_id: Boolean
  mls_num: Boolean
  property_type: Boolean
  property_status: Boolean
  address: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ProcessedSearchByAddressFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  property_type: RecordSortDirectionEnum
  property_status: RecordSortDirectionEnum
  address: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ProcessedSearchByAddressFindInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """Property status of the processed search by address"""
  property_status: FindOperatorDto

  """Address of the processed search by address"""
  address: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input ProcessedSearchByAddressFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type ProcessedSearchByAddressFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ProcessedSearchByAddressEntity!]!
}

input ProcessedSearchByAddressRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByAddressRecoverInputWhere!]
}

input ProcessedSearchByAddressRecoverInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """Property status of the processed search by address"""
  property_status: FindOperatorDto

  """Address of the processed search by address"""
  address: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByAddressRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByAddressEntity!]!
}

input ProcessedSearchByAddressRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByAddressRemoveInputWhere!]
}

input ProcessedSearchByAddressRemoveInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """Property status of the processed search by address"""
  property_status: FindOperatorDto

  """Address of the processed search by address"""
  address: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByAddressRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByAddressEntity!]!
}

input ProcessedSearchByAddressRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByAddressRestoreInputWhere!]
}

input ProcessedSearchByAddressRestoreInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """Property status of the processed search by address"""
  property_status: FindOperatorDto

  """Address of the processed search by address"""
  address: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByAddressRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByAddressSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByAddressSoftDeleteInputWhere!]
}

input ProcessedSearchByAddressSoftDeleteInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """Property status of the processed search by address"""
  property_status: FindOperatorDto

  """Address of the processed search by address"""
  address: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByAddressSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByAddressSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByAddressSoftRemoveInputWhere!]
}

input ProcessedSearchByAddressSoftRemoveInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """Property status of the processed search by address"""
  property_status: FindOperatorDto

  """Address of the processed search by address"""
  address: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByAddressSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByAddressEntity!]!
}

input ProcessedSearchByAddressUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByAddressUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ProcessedSearchByAddressUpdateInputSets!
}

input ProcessedSearchByAddressUpdateInputSets {
  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by address"""
  mls_num: String

  """Property type of the processed search by address"""
  property_type: String

  """Property status of the processed search by address"""
  property_status: String

  """Address of the processed search by address"""
  address: String
}

input ProcessedSearchByAddressUpdateInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """Property status of the processed search by address"""
  property_status: FindOperatorDto

  """Address of the processed search by address"""
  address: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByAddressUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ProcessedSearchByAddressEntity!]!
}

input ProcessedSearchByAddressUpsertInput {
  """MLSP ID"""
  mlsp_id: Int!

  """Mls num of the processed search by address"""
  mls_num: String!

  """Property type of the processed search by address"""
  property_type: String!

  """Property status of the processed search by address"""
  property_status: String!

  """Address of the processed search by address"""
  address: String!

  """
  Unique ID of the processed search by address, auto generated. undefined
  """
  id: Int
}

type ProcessedSearchByAddressUpsertOutput {
  """Unique ID of the processed search by address, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by address"""
  mls_num: String

  """Property type of the processed search by address"""
  property_type: String

  """Property status of the processed search by address"""
  property_status: String

  """Address of the processed search by address"""
  address: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input ProcessedSearchByCityCreateInput {
  """MLSP ID"""
  mlsp_id: Int!

  """Mls num of the processed search by address"""
  mls_num: String!

  """Property type of the processed search by address"""
  property_type: String!

  """City state of the processed search by address"""
  city_state: String!

  """City of the processed search by address"""
  city: String!

  """State of the processed search by address"""
  state: String!
}

type ProcessedSearchByCityCreateOutput {
  """Unique ID of the processed search by address, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by address"""
  mls_num: String

  """Property type of the processed search by address"""
  property_type: String

  """City state of the processed search by address"""
  city_state: String

  """City of the processed search by address"""
  city: String

  """State of the processed search by address"""
  state: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by city."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input ProcessedSearchByCityDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCityDeleteInputWhere!]
}

input ProcessedSearchByCityDeleteInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """City state of the processed search by address"""
  city_state: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by city."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByCityDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type ProcessedSearchByCityEntity {
  """Unique ID of the processed search by address, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by address"""
  mls_num: String

  """Property type of the processed search by address"""
  property_type: String

  """City state of the processed search by address"""
  city_state: String

  """City of the processed search by address"""
  city: String

  """State of the processed search by address"""
  state: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by city."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input ProcessedSearchByCityFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCityFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ProcessedSearchByCityFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ProcessedSearchByCityFindInputSortOrder
}

input ProcessedSearchByCityFindInputGroupBy {
  mlsp_id: Boolean
  mls_num: Boolean
  property_type: Boolean
  city_state: Boolean
  city: Boolean
  state: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ProcessedSearchByCityFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  property_type: RecordSortDirectionEnum
  city_state: RecordSortDirectionEnum
  city: RecordSortDirectionEnum
  state: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ProcessedSearchByCityFindInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """City state of the processed search by address"""
  city_state: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by city."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input ProcessedSearchByCityFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type ProcessedSearchByCityFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ProcessedSearchByCityEntity!]!
}

input ProcessedSearchByCityRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCityRecoverInputWhere!]
}

input ProcessedSearchByCityRecoverInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """City state of the processed search by address"""
  city_state: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by city."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByCityRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByCityEntity!]!
}

input ProcessedSearchByCityRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCityRemoveInputWhere!]
}

input ProcessedSearchByCityRemoveInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """City state of the processed search by address"""
  city_state: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by city."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByCityRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByCityEntity!]!
}

input ProcessedSearchByCityRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCityRestoreInputWhere!]
}

input ProcessedSearchByCityRestoreInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """City state of the processed search by address"""
  city_state: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by city."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByCityRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByCitySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCitySoftDeleteInputWhere!]
}

input ProcessedSearchByCitySoftDeleteInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """City state of the processed search by address"""
  city_state: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by city."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByCitySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByCitySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCitySoftRemoveInputWhere!]
}

input ProcessedSearchByCitySoftRemoveInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """City state of the processed search by address"""
  city_state: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by city."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByCitySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByCityEntity!]!
}

input ProcessedSearchByCityUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCityUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ProcessedSearchByCityUpdateInputSets!
}

input ProcessedSearchByCityUpdateInputSets {
  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by address"""
  mls_num: String

  """Property type of the processed search by address"""
  property_type: String

  """City state of the processed search by address"""
  city_state: String

  """City of the processed search by address"""
  city: String

  """State of the processed search by address"""
  state: String
}

input ProcessedSearchByCityUpdateInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """Property type of the processed search by address"""
  property_type: FindOperatorDto

  """City state of the processed search by address"""
  city_state: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by city."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByCityUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ProcessedSearchByCityEntity!]!
}

input ProcessedSearchByCityUpsertInput {
  """MLSP ID"""
  mlsp_id: Int!

  """Mls num of the processed search by address"""
  mls_num: String!

  """Property type of the processed search by address"""
  property_type: String!

  """City state of the processed search by address"""
  city_state: String!

  """City of the processed search by address"""
  city: String!

  """State of the processed search by address"""
  state: String!

  """
  Unique ID of the processed search by address, auto generated. undefined
  """
  id: Int
}

type ProcessedSearchByCityUpsertOutput {
  """Unique ID of the processed search by address, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by address"""
  mls_num: String

  """Property type of the processed search by address"""
  property_type: String

  """City state of the processed search by address"""
  city_state: String

  """City of the processed search by address"""
  city: String

  """State of the processed search by address"""
  state: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by city."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input ProcessedSearchByCountyCreateInput {
  """Mls num of the processed search by address"""
  mls_num: String!

  """County of the processed search by address"""
  county: String!

  """City of the processed search by address"""
  city: String!

  """State of the processed search by address"""
  state: String!
}

type ProcessedSearchByCountyCreateOutput {
  """Unique ID of the processed search by address, auto generated."""
  id: Int

  """Mls num of the processed search by address"""
  mls_num: String

  """County of the processed search by address"""
  county: String

  """City of the processed search by address"""
  city: String

  """State of the processed search by address"""
  state: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ProcessedSearchByCountyDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCountyDeleteInputWhere!]
}

input ProcessedSearchByCountyDeleteInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """County of the processed search by address"""
  county: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByCountyDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type ProcessedSearchByCountyEntity {
  """Unique ID of the processed search by address, auto generated."""
  id: Int

  """Mls num of the processed search by address"""
  mls_num: String

  """County of the processed search by address"""
  county: String

  """City of the processed search by address"""
  city: String

  """State of the processed search by address"""
  state: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ProcessedSearchByCountyFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCountyFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ProcessedSearchByCountyFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ProcessedSearchByCountyFindInputSortOrder
}

input ProcessedSearchByCountyFindInputGroupBy {
  mls_num: Boolean
  county: Boolean
  city: Boolean
  state: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ProcessedSearchByCountyFindInputSortOrder {
  id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  county: RecordSortDirectionEnum
  city: RecordSortDirectionEnum
  state: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ProcessedSearchByCountyFindInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """County of the processed search by address"""
  county: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

input ProcessedSearchByCountyFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type ProcessedSearchByCountyFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ProcessedSearchByCountyEntity!]!
}

input ProcessedSearchByCountyRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCountyRecoverInputWhere!]
}

input ProcessedSearchByCountyRecoverInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """County of the processed search by address"""
  county: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByCountyRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByCountyEntity!]!
}

input ProcessedSearchByCountyRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCountyRemoveInputWhere!]
}

input ProcessedSearchByCountyRemoveInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """County of the processed search by address"""
  county: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByCountyRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByCountyEntity!]!
}

input ProcessedSearchByCountyRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCountyRestoreInputWhere!]
}

input ProcessedSearchByCountyRestoreInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """County of the processed search by address"""
  county: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByCountyRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByCountySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCountySoftDeleteInputWhere!]
}

input ProcessedSearchByCountySoftDeleteInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """County of the processed search by address"""
  county: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByCountySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByCountySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCountySoftRemoveInputWhere!]
}

input ProcessedSearchByCountySoftRemoveInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """County of the processed search by address"""
  county: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByCountySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByCountyEntity!]!
}

input ProcessedSearchByCountyUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByCountyUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ProcessedSearchByCountyUpdateInputSets!
}

input ProcessedSearchByCountyUpdateInputSets {
  """Mls num of the processed search by address"""
  mls_num: String

  """County of the processed search by address"""
  county: String

  """City of the processed search by address"""
  city: String

  """State of the processed search by address"""
  state: String
}

input ProcessedSearchByCountyUpdateInputWhere {
  """Unique ID of the processed search by address, auto generated."""
  id: FindOperatorDto

  """Mls num of the processed search by address"""
  mls_num: FindOperatorDto

  """County of the processed search by address"""
  county: FindOperatorDto

  """City of the processed search by address"""
  city: FindOperatorDto

  """State of the processed search by address"""
  state: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByCountyUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ProcessedSearchByCountyEntity!]!
}

input ProcessedSearchByCountyUpsertInput {
  """Mls num of the processed search by address"""
  mls_num: String!

  """County of the processed search by address"""
  county: String!

  """City of the processed search by address"""
  city: String!

  """State of the processed search by address"""
  state: String!

  """
  Unique ID of the processed search by address, auto generated. undefined
  """
  id: Int
}

type ProcessedSearchByCountyUpsertOutput {
  """Unique ID of the processed search by address, auto generated."""
  id: Int

  """Mls num of the processed search by address"""
  mls_num: String

  """County of the processed search by address"""
  county: String

  """City of the processed search by address"""
  city: String

  """State of the processed search by address"""
  state: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input ProcessedSearchByMapSearchCreateInput {
  """Mls num of the processed search by mapsearch"""
  mls_num: String!

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: Int!

  """Listing key of the processed search by mapsearch"""
  listing_key: String!

  """Agent id of the processed search by mapsearch"""
  agent_id: String!

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: String

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: String

  """Office id of the processed search by mapsearch"""
  office_id: String!

  """Co office id of the processed search by mapsearch"""
  co_office_id: String

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: String

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: String

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: String

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: String

  """Property type of the processed search by mapsearch"""
  property_type: String!

  """Property style of the processed search by mapsearch"""
  property_style: String

  """Category of the processed search by mapsearch"""
  category: String!

  """Property status of the processed search by mapsearch"""
  property_status: String!

  """Subtype of the processed search by mapsearch"""
  subtype: String

  """Baths full of the processed search by mapsearch"""
  baths_full: Int!

  """Baths half of the processed search by mapsearch"""
  baths_half: Int!

  """Baths of the processed search by mapsearch"""
  baths: Int!

  """Beds of the processed search by mapsearch"""
  beds: Int!

  """List price of the processed search by mapsearch"""
  list_price: Float

  """Original list price of the processed search by mapsearch"""
  original_list_price: Float

  """Sold price of the processed search by mapsearch"""
  sold_price: Float

  """Sold date of the processed search by mapsearch"""
  sold_date: DateTime

  """Sqft of the processed search by mapsearch"""
  sqft: Float

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: Int

  """Total photos of the processed search by mapsearch"""
  total_photos: Int

  """Main photo of the processed search by mapsearch"""
  main_photo: Int

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: String

  """Display address of the processed search by mapsearch"""
  display_address: String!

  """Listing date of the processed search by mapsearch"""
  listing_date: DateTime!

  """Last update date of the processed search by mapsearch"""
  last_update_date: DateTime

  """Elementary school of the processed search by mapsearch"""
  elementary_school: String

  """High school of the processed search by mapsearch"""
  high_school: String

  """Middle school of the processed search by mapsearch"""
  middle_school: String

  """Price diff of the processed search by mapsearch"""
  price_diff: Float!

  """System name of the processed search by mapsearch"""
  system_name: String!

  """Address of the processed search by mapsearch"""
  address: String!

  """Area of the processed search by mapsearch"""
  area: String

  """Subdivision of the processed search by mapsearch"""
  subdivision: String

  """Unit no of the processed search by mapsearch"""
  unit_no: String

  """Street number of the processed search by mapsearch"""
  street_number: String!

  """Street direction of the processed search by mapsearch"""
  street_direction: String!

  """Street dir prefix of the processed search by mapsearch"""
  street_dir_prefix: String!

  """Street name of the processed search by mapsearch"""
  street_name: String!

  """Street suffix of the processed search by mapsearch"""
  street_suffix: String!

  """Street dir suffix of the processed search by mapsearch"""
  street_dir_suffix: String!

  """City name of the processed search by mapsearch"""
  city_name: String!

  """State of the processed search by mapsearch"""
  state: String!

  """County of the processed search by mapsearch"""
  county: String!

  """Zipcode of the processed search by mapsearch"""
  zipcode: String!

  """Latitude of the processed search by mapsearch"""
  latitude: Float

  """Longitude of the processed search by mapsearch"""
  longitude: Float

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: Float

  """Is hoa of the processed search by mapsearch"""
  is_hoa: String

  """Is new of the processed search by mapsearch"""
  is_new: String

  """Pool desc of the processed search by mapsearch"""
  pool_desc: String

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: String

  """Furnished of the processed search by mapsearch"""
  furnished: String

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: String

  """Waterfront desc of the processed search by mapsearch"""
  waterfront_desc: String

  """Horse yn of the processed search by mapsearch"""
  horse_yn: String!

  """Horse amenities of the processed search by mapsearch"""
  horse_amenities: String

  """Security safety of the processed search by mapsearch"""
  security_safety: String

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: String!

  """Membership of the processed search by mapsearch"""
  membership: String

  """Membership fee of the processed search by mapsearch"""
  membership_fee: Float

  """Virtual tour url of the processed search by mapsearch"""
  virtual_tour_url: String

  """Description of the processed search by mapsearch"""
  description: String

  """Exterior features of the processed search by mapsearch"""
  exterior_features: String

  """Building features of the processed search by mapsearch"""
  building_features: String

  """Construction of the processed search by mapsearch"""
  construction: String

  """Sewer of the processed search by mapsearch"""
  sewer: String

  """Water of the processed search by mapsearch"""
  water: String

  """Zoning of the processed search by mapsearch"""
  zoning: String

  """Legal of the processed search by mapsearch"""
  legal: String

  """Fireplace features of the processed search by mapsearch"""
  fireplace_features: String

  """Amenities of the processed search by mapsearch"""
  amenities: String

  """Cooling of the processed search by mapsearch"""
  cooling: String

  """Appliances of the processed search by mapsearch"""
  appliances: String

  """Flooring of the processed search by mapsearch"""
  flooring: String

  """Heating of the processed search by mapsearch"""
  heating: String

  """Interior features of the processed search by mapsearch"""
  interior_features: String

  """Roof of the processed search by mapsearch"""
  roof: String

  """Spa features of the processed search by mapsearch"""
  spa_features: String

  """Community features of the processed search by mapsearch"""
  community_features: String

  """Parking features of the processed search by mapsearch"""
  parking_features: String

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: String!

  """Dom of the processed search by mapsearch"""
  dom: Int

  """Office name of the processed search by mapsearch"""
  office_name: String
}

type ProcessedSearchByMapSearchCreateOutput {
  """Id of the processed search by mapsearch"""
  id: Int

  """Mls num of the processed search by mapsearch"""
  mls_num: String

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: Int

  """Listing key of the processed search by mapsearch"""
  listing_key: String

  """Agent id of the processed search by mapsearch"""
  agent_id: String

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: String

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: String

  """Office id of the processed search by mapsearch"""
  office_id: String

  """Co office id of the processed search by mapsearch"""
  co_office_id: String

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: String

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: String

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: String

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: String

  """Property type of the processed search by mapsearch"""
  property_type: String

  """Property style of the processed search by mapsearch"""
  property_style: String

  """Category of the processed search by mapsearch"""
  category: String

  """Property status of the processed search by mapsearch"""
  property_status: String

  """Subtype of the processed search by mapsearch"""
  subtype: String

  """Baths full of the processed search by mapsearch"""
  baths_full: Int

  """Baths half of the processed search by mapsearch"""
  baths_half: Int

  """Baths of the processed search by mapsearch"""
  baths: Int

  """Beds of the processed search by mapsearch"""
  beds: Int

  """List price of the processed search by mapsearch"""
  list_price: Float

  """Original list price of the processed search by mapsearch"""
  original_list_price: Float

  """Sold price of the processed search by mapsearch"""
  sold_price: Float

  """Sold date of the processed search by mapsearch"""
  sold_date: DateTime

  """Sqft of the processed search by mapsearch"""
  sqft: Float

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: Int

  """Total photos of the processed search by mapsearch"""
  total_photos: Int

  """Main photo of the processed search by mapsearch"""
  main_photo: Int

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: String

  """Display address of the processed search by mapsearch"""
  display_address: String

  """Listing date of the processed search by mapsearch"""
  listing_date: DateTime

  """Last update date of the processed search by mapsearch"""
  last_update_date: DateTime

  """Elementary school of the processed search by mapsearch"""
  elementary_school: String

  """High school of the processed search by mapsearch"""
  high_school: String

  """Middle school of the processed search by mapsearch"""
  middle_school: String

  """Price diff of the processed search by mapsearch"""
  price_diff: Float

  """System name of the processed search by mapsearch"""
  system_name: String

  """Address of the processed search by mapsearch"""
  address: String

  """Area of the processed search by mapsearch"""
  area: String

  """Subdivision of the processed search by mapsearch"""
  subdivision: String

  """Unit no of the processed search by mapsearch"""
  unit_no: String

  """Street number of the processed search by mapsearch"""
  street_number: String

  """Street direction of the processed search by mapsearch"""
  street_direction: String

  """Street dir prefix of the processed search by mapsearch"""
  street_dir_prefix: String

  """Street name of the processed search by mapsearch"""
  street_name: String

  """Street suffix of the processed search by mapsearch"""
  street_suffix: String

  """Street dir suffix of the processed search by mapsearch"""
  street_dir_suffix: String

  """City name of the processed search by mapsearch"""
  city_name: String

  """State of the processed search by mapsearch"""
  state: String

  """County of the processed search by mapsearch"""
  county: String

  """Zipcode of the processed search by mapsearch"""
  zipcode: String

  """Latitude of the processed search by mapsearch"""
  latitude: Float

  """Longitude of the processed search by mapsearch"""
  longitude: Float

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: Float

  """Is hoa of the processed search by mapsearch"""
  is_hoa: String

  """Is new of the processed search by mapsearch"""
  is_new: String

  """Pool desc of the processed search by mapsearch"""
  pool_desc: String

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: String

  """Furnished of the processed search by mapsearch"""
  furnished: String

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: String

  """Waterfront desc of the processed search by mapsearch"""
  waterfront_desc: String

  """Horse yn of the processed search by mapsearch"""
  horse_yn: String

  """Horse amenities of the processed search by mapsearch"""
  horse_amenities: String

  """Security safety of the processed search by mapsearch"""
  security_safety: String

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: String

  """Membership of the processed search by mapsearch"""
  membership: String

  """Membership fee of the processed search by mapsearch"""
  membership_fee: Float

  """Virtual tour url of the processed search by mapsearch"""
  virtual_tour_url: String

  """Description of the processed search by mapsearch"""
  description: String

  """Exterior features of the processed search by mapsearch"""
  exterior_features: String

  """Building features of the processed search by mapsearch"""
  building_features: String

  """Construction of the processed search by mapsearch"""
  construction: String

  """Sewer of the processed search by mapsearch"""
  sewer: String

  """Water of the processed search by mapsearch"""
  water: String

  """Zoning of the processed search by mapsearch"""
  zoning: String

  """Legal of the processed search by mapsearch"""
  legal: String

  """Fireplace features of the processed search by mapsearch"""
  fireplace_features: String

  """Amenities of the processed search by mapsearch"""
  amenities: String

  """Cooling of the processed search by mapsearch"""
  cooling: String

  """Appliances of the processed search by mapsearch"""
  appliances: String

  """Flooring of the processed search by mapsearch"""
  flooring: String

  """Heating of the processed search by mapsearch"""
  heating: String

  """Interior features of the processed search by mapsearch"""
  interior_features: String

  """Roof of the processed search by mapsearch"""
  roof: String

  """Spa features of the processed search by mapsearch"""
  spa_features: String

  """Community features of the processed search by mapsearch"""
  community_features: String

  """Parking features of the processed search by mapsearch"""
  parking_features: String

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: String!

  """Dom of the processed search by mapsearch"""
  dom: Int

  """Office name of the processed search by mapsearch"""
  office_name: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ProcessedSearchByMapSearchDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMapSearchDeleteInputWhere!]
}

input ProcessedSearchByMapSearchDeleteInputWhere {
  """Id of the processed search by mapsearch"""
  id: FindOperatorDto

  """Mls num of the processed search by mapsearch"""
  mls_num: FindOperatorDto

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: FindOperatorDto

  """Listing key of the processed search by mapsearch"""
  listing_key: FindOperatorDto

  """Agent id of the processed search by mapsearch"""
  agent_id: FindOperatorDto

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: FindOperatorDto

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: FindOperatorDto

  """Office id of the processed search by mapsearch"""
  office_id: FindOperatorDto

  """Co office id of the processed search by mapsearch"""
  co_office_id: FindOperatorDto

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: FindOperatorDto

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: FindOperatorDto

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: FindOperatorDto

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: FindOperatorDto

  """Property type of the processed search by mapsearch"""
  property_type: FindOperatorDto

  """Category of the processed search by mapsearch"""
  category: FindOperatorDto

  """Property status of the processed search by mapsearch"""
  property_status: FindOperatorDto

  """Subtype of the processed search by mapsearch"""
  subtype: FindOperatorDto

  """Baths full of the processed search by mapsearch"""
  baths_full: FindOperatorDto

  """Baths half of the processed search by mapsearch"""
  baths_half: FindOperatorDto

  """Baths of the processed search by mapsearch"""
  baths: FindOperatorDto

  """Beds of the processed search by mapsearch"""
  beds: FindOperatorDto

  """List price of the processed search by mapsearch"""
  list_price: FindOperatorDto

  """Sold price of the processed search by mapsearch"""
  sold_price: FindOperatorDto

  """Sqft of the processed search by mapsearch"""
  sqft: FindOperatorDto

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: FindOperatorDto

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: FindOperatorDto

  """Display address of the processed search by mapsearch"""
  display_address: FindOperatorDto

  """Elementary school of the processed search by mapsearch"""
  elementary_school: FindOperatorDto

  """High school of the processed search by mapsearch"""
  high_school: FindOperatorDto

  """Middle school of the processed search by mapsearch"""
  middle_school: FindOperatorDto

  """System name of the processed search by mapsearch"""
  system_name: FindOperatorDto

  """Address of the processed search by mapsearch"""
  address: FindOperatorDto

  """Area of the processed search by mapsearch"""
  area: FindOperatorDto

  """Subdivision of the processed search by mapsearch"""
  subdivision: FindOperatorDto

  """Street number of the processed search by mapsearch"""
  street_number: FindOperatorDto

  """Street direction of the processed search by mapsearch"""
  street_direction: FindOperatorDto

  """Street name of the processed search by mapsearch"""
  street_name: FindOperatorDto

  """Street suffix of the processed search by mapsearch"""
  street_suffix: FindOperatorDto

  """City name of the processed search by mapsearch"""
  city_name: FindOperatorDto

  """Zipcode of the processed search by mapsearch"""
  zipcode: FindOperatorDto

  """Latitude of the processed search by mapsearch"""
  latitude: FindOperatorDto

  """Longitude of the processed search by mapsearch"""
  longitude: FindOperatorDto

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: FindOperatorDto

  """Is hoa of the processed search by mapsearch"""
  is_hoa: FindOperatorDto

  """Is new of the processed search by mapsearch"""
  is_new: FindOperatorDto

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: FindOperatorDto

  """Furnished of the processed search by mapsearch"""
  furnished: FindOperatorDto

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: FindOperatorDto

  """Horse yn of the processed search by mapsearch"""
  horse_yn: FindOperatorDto

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: FindOperatorDto

  """Membership of the processed search by mapsearch"""
  membership: FindOperatorDto

  """Membership fee of the processed search by mapsearch"""
  membership_fee: FindOperatorDto

  """Building features of the processed search by mapsearch"""
  building_features: FindOperatorDto

  """Water of the processed search by mapsearch"""
  water: FindOperatorDto

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: FindOperatorDto

  """Office name of the processed search by mapsearch"""
  office_name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mapsearch."""
  fr_mlsp_id: RetsMlsProviderFindInputWhere
}

type ProcessedSearchByMapSearchDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type ProcessedSearchByMapSearchEntity {
  """Id of the processed search by mapsearch"""
  id: Int

  """Mls num of the processed search by mapsearch"""
  mls_num: String

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: Int

  """Listing key of the processed search by mapsearch"""
  listing_key: String

  """Agent id of the processed search by mapsearch"""
  agent_id: String

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: String

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: String

  """Office id of the processed search by mapsearch"""
  office_id: String

  """Co office id of the processed search by mapsearch"""
  co_office_id: String

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: String

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: String

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: String

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: String

  """Property type of the processed search by mapsearch"""
  property_type: String

  """Property style of the processed search by mapsearch"""
  property_style: String

  """Category of the processed search by mapsearch"""
  category: String

  """Property status of the processed search by mapsearch"""
  property_status: String

  """Subtype of the processed search by mapsearch"""
  subtype: String

  """Baths full of the processed search by mapsearch"""
  baths_full: Int

  """Baths half of the processed search by mapsearch"""
  baths_half: Int

  """Baths of the processed search by mapsearch"""
  baths: Int

  """Beds of the processed search by mapsearch"""
  beds: Int

  """List price of the processed search by mapsearch"""
  list_price: Float

  """Original list price of the processed search by mapsearch"""
  original_list_price: Float

  """Sold price of the processed search by mapsearch"""
  sold_price: Float

  """Sold date of the processed search by mapsearch"""
  sold_date: DateTime

  """Sqft of the processed search by mapsearch"""
  sqft: Float

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: Int

  """Total photos of the processed search by mapsearch"""
  total_photos: Int

  """Main photo of the processed search by mapsearch"""
  main_photo: Int

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: String

  """Display address of the processed search by mapsearch"""
  display_address: String

  """Listing date of the processed search by mapsearch"""
  listing_date: DateTime

  """Last update date of the processed search by mapsearch"""
  last_update_date: DateTime

  """Elementary school of the processed search by mapsearch"""
  elementary_school: String

  """High school of the processed search by mapsearch"""
  high_school: String

  """Middle school of the processed search by mapsearch"""
  middle_school: String

  """Price diff of the processed search by mapsearch"""
  price_diff: Float

  """System name of the processed search by mapsearch"""
  system_name: String

  """Address of the processed search by mapsearch"""
  address: String

  """Area of the processed search by mapsearch"""
  area: String

  """Subdivision of the processed search by mapsearch"""
  subdivision: String

  """Unit no of the processed search by mapsearch"""
  unit_no: String

  """Street number of the processed search by mapsearch"""
  street_number: String

  """Street direction of the processed search by mapsearch"""
  street_direction: String

  """Street dir prefix of the processed search by mapsearch"""
  street_dir_prefix: String

  """Street name of the processed search by mapsearch"""
  street_name: String

  """Street suffix of the processed search by mapsearch"""
  street_suffix: String

  """Street dir suffix of the processed search by mapsearch"""
  street_dir_suffix: String

  """City name of the processed search by mapsearch"""
  city_name: String

  """State of the processed search by mapsearch"""
  state: String

  """County of the processed search by mapsearch"""
  county: String

  """Zipcode of the processed search by mapsearch"""
  zipcode: String

  """Latitude of the processed search by mapsearch"""
  latitude: Float

  """Longitude of the processed search by mapsearch"""
  longitude: Float

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: Float

  """Is hoa of the processed search by mapsearch"""
  is_hoa: String

  """Is new of the processed search by mapsearch"""
  is_new: String

  """Pool desc of the processed search by mapsearch"""
  pool_desc: String

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: String

  """Furnished of the processed search by mapsearch"""
  furnished: String

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: String

  """Waterfront desc of the processed search by mapsearch"""
  waterfront_desc: String

  """Horse yn of the processed search by mapsearch"""
  horse_yn: String

  """Horse amenities of the processed search by mapsearch"""
  horse_amenities: String

  """Security safety of the processed search by mapsearch"""
  security_safety: String

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: String

  """Membership of the processed search by mapsearch"""
  membership: String

  """Membership fee of the processed search by mapsearch"""
  membership_fee: Float

  """Virtual tour url of the processed search by mapsearch"""
  virtual_tour_url: String

  """Description of the processed search by mapsearch"""
  description: String

  """Exterior features of the processed search by mapsearch"""
  exterior_features: String

  """Building features of the processed search by mapsearch"""
  building_features: String

  """Construction of the processed search by mapsearch"""
  construction: String

  """Sewer of the processed search by mapsearch"""
  sewer: String

  """Water of the processed search by mapsearch"""
  water: String

  """Zoning of the processed search by mapsearch"""
  zoning: String

  """Legal of the processed search by mapsearch"""
  legal: String

  """Fireplace features of the processed search by mapsearch"""
  fireplace_features: String

  """Amenities of the processed search by mapsearch"""
  amenities: String

  """Cooling of the processed search by mapsearch"""
  cooling: String

  """Appliances of the processed search by mapsearch"""
  appliances: String

  """Flooring of the processed search by mapsearch"""
  flooring: String

  """Heating of the processed search by mapsearch"""
  heating: String

  """Interior features of the processed search by mapsearch"""
  interior_features: String

  """Roof of the processed search by mapsearch"""
  roof: String

  """Spa features of the processed search by mapsearch"""
  spa_features: String

  """Community features of the processed search by mapsearch"""
  community_features: String

  """Parking features of the processed search by mapsearch"""
  parking_features: String

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: String!

  """Dom of the processed search by mapsearch"""
  dom: Int

  """Office name of the processed search by mapsearch"""
  office_name: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ProcessedSearchByMapSearchFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMapSearchFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ProcessedSearchByMapSearchFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ProcessedSearchByMapSearchFindInputSortOrder
}

input ProcessedSearchByMapSearchFindInputGroupBy {
  mls_num: Boolean
  mlsp_id: Boolean
  listing_key: Boolean
  agent_id: Boolean
  agent_short_id: Boolean
  co_agent_id: Boolean
  office_id: Boolean
  co_office_id: Boolean
  co_agent_short_id: Boolean
  sell_agent_short_id: Boolean
  buy_agent_id: Boolean
  co_buy_agent_id: Boolean
  property_type: Boolean
  category: Boolean
  property_status: Boolean
  subtype: Boolean
  baths_full: Boolean
  baths_half: Boolean
  baths: Boolean
  beds: Boolean
  list_price: Boolean
  sold_price: Boolean
  sqft: Boolean
  yearbuilt: Boolean
  main_photo_url: Boolean
  display_address: Boolean
  elementary_school: Boolean
  high_school: Boolean
  middle_school: Boolean
  system_name: Boolean
  address: Boolean
  area: Boolean
  subdivision: Boolean
  street_number: Boolean
  street_direction: Boolean
  street_name: Boolean
  street_suffix: Boolean
  city_name: Boolean
  state: Boolean
  county: Boolean
  zipcode: Boolean
  latitude: Boolean
  longitude: Boolean
  lotsize_sqft: Boolean
  is_hoa: Boolean
  is_new: Boolean
  pets_allowed: Boolean
  furnished: Boolean
  is_waterfront: Boolean
  horse_yn: Boolean
  membership_required_yn: Boolean
  membership: Boolean
  membership_fee: Boolean
  building_features: Boolean
  water: Boolean
  mls_is_pic_url_supported: Boolean
  office_name: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ProcessedSearchByMapSearchFindInputSortOrder {
  id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  listing_key: RecordSortDirectionEnum
  agent_id: RecordSortDirectionEnum
  agent_short_id: RecordSortDirectionEnum
  co_agent_id: RecordSortDirectionEnum
  office_id: RecordSortDirectionEnum
  co_office_id: RecordSortDirectionEnum
  co_agent_short_id: RecordSortDirectionEnum
  sell_agent_short_id: RecordSortDirectionEnum
  buy_agent_id: RecordSortDirectionEnum
  co_buy_agent_id: RecordSortDirectionEnum
  property_type: RecordSortDirectionEnum
  category: RecordSortDirectionEnum
  property_status: RecordSortDirectionEnum
  subtype: RecordSortDirectionEnum
  baths_full: RecordSortDirectionEnum
  baths_half: RecordSortDirectionEnum
  baths: RecordSortDirectionEnum
  beds: RecordSortDirectionEnum
  list_price: RecordSortDirectionEnum
  sold_price: RecordSortDirectionEnum
  sqft: RecordSortDirectionEnum
  yearbuilt: RecordSortDirectionEnum
  main_photo_url: RecordSortDirectionEnum
  display_address: RecordSortDirectionEnum
  elementary_school: RecordSortDirectionEnum
  high_school: RecordSortDirectionEnum
  middle_school: RecordSortDirectionEnum
  system_name: RecordSortDirectionEnum
  address: RecordSortDirectionEnum
  area: RecordSortDirectionEnum
  subdivision: RecordSortDirectionEnum
  street_number: RecordSortDirectionEnum
  street_direction: RecordSortDirectionEnum
  street_name: RecordSortDirectionEnum
  street_suffix: RecordSortDirectionEnum
  city_name: RecordSortDirectionEnum
  zipcode: RecordSortDirectionEnum
  latitude: RecordSortDirectionEnum
  longitude: RecordSortDirectionEnum
  lotsize_sqft: RecordSortDirectionEnum
  is_hoa: RecordSortDirectionEnum
  is_new: RecordSortDirectionEnum
  pets_allowed: RecordSortDirectionEnum
  furnished: RecordSortDirectionEnum
  is_waterfront: RecordSortDirectionEnum
  horse_yn: RecordSortDirectionEnum
  membership_required_yn: RecordSortDirectionEnum
  membership: RecordSortDirectionEnum
  membership_fee: RecordSortDirectionEnum
  building_features: RecordSortDirectionEnum
  water: RecordSortDirectionEnum
  mls_is_pic_url_supported: RecordSortDirectionEnum
  office_name: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ProcessedSearchByMapSearchFindInputWhere {
  """Id of the processed search by mapsearch"""
  id: FindOperatorDto

  """Mls num of the processed search by mapsearch"""
  mls_num: FindOperatorDto

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: FindOperatorDto

  """Listing key of the processed search by mapsearch"""
  listing_key: FindOperatorDto

  """Agent id of the processed search by mapsearch"""
  agent_id: FindOperatorDto

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: FindOperatorDto

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: FindOperatorDto

  """Office id of the processed search by mapsearch"""
  office_id: FindOperatorDto

  """Co office id of the processed search by mapsearch"""
  co_office_id: FindOperatorDto

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: FindOperatorDto

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: FindOperatorDto

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: FindOperatorDto

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: FindOperatorDto

  """Property type of the processed search by mapsearch"""
  property_type: FindOperatorDto

  """Category of the processed search by mapsearch"""
  category: FindOperatorDto

  """Property status of the processed search by mapsearch"""
  property_status: FindOperatorDto

  """Subtype of the processed search by mapsearch"""
  subtype: FindOperatorDto

  """Baths full of the processed search by mapsearch"""
  baths_full: FindOperatorDto

  """Baths half of the processed search by mapsearch"""
  baths_half: FindOperatorDto

  """Baths of the processed search by mapsearch"""
  baths: FindOperatorDto

  """Beds of the processed search by mapsearch"""
  beds: FindOperatorDto

  """List price of the processed search by mapsearch"""
  list_price: FindOperatorDto

  """Sold price of the processed search by mapsearch"""
  sold_price: FindOperatorDto

  """Sqft of the processed search by mapsearch"""
  sqft: FindOperatorDto

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: FindOperatorDto

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: FindOperatorDto

  """Display address of the processed search by mapsearch"""
  display_address: FindOperatorDto

  """Elementary school of the processed search by mapsearch"""
  elementary_school: FindOperatorDto

  """High school of the processed search by mapsearch"""
  high_school: FindOperatorDto

  """Middle school of the processed search by mapsearch"""
  middle_school: FindOperatorDto

  """System name of the processed search by mapsearch"""
  system_name: FindOperatorDto

  """Address of the processed search by mapsearch"""
  address: FindOperatorDto

  """Area of the processed search by mapsearch"""
  area: FindOperatorDto

  """Subdivision of the processed search by mapsearch"""
  subdivision: FindOperatorDto

  """Street number of the processed search by mapsearch"""
  street_number: FindOperatorDto

  """Street direction of the processed search by mapsearch"""
  street_direction: FindOperatorDto

  """Street name of the processed search by mapsearch"""
  street_name: FindOperatorDto

  """Street suffix of the processed search by mapsearch"""
  street_suffix: FindOperatorDto

  """City name of the processed search by mapsearch"""
  city_name: FindOperatorDto

  """Zipcode of the processed search by mapsearch"""
  zipcode: FindOperatorDto

  """Latitude of the processed search by mapsearch"""
  latitude: FindOperatorDto

  """Longitude of the processed search by mapsearch"""
  longitude: FindOperatorDto

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: FindOperatorDto

  """Is hoa of the processed search by mapsearch"""
  is_hoa: FindOperatorDto

  """Is new of the processed search by mapsearch"""
  is_new: FindOperatorDto

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: FindOperatorDto

  """Furnished of the processed search by mapsearch"""
  furnished: FindOperatorDto

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: FindOperatorDto

  """Horse yn of the processed search by mapsearch"""
  horse_yn: FindOperatorDto

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: FindOperatorDto

  """Membership of the processed search by mapsearch"""
  membership: FindOperatorDto

  """Membership fee of the processed search by mapsearch"""
  membership_fee: FindOperatorDto

  """Building features of the processed search by mapsearch"""
  building_features: FindOperatorDto

  """Water of the processed search by mapsearch"""
  water: FindOperatorDto

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: FindOperatorDto

  """Office name of the processed search by mapsearch"""
  office_name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mapsearch."""
  fr_mlsp_id: RetsMlsProviderFindInputWhere
}

input ProcessedSearchByMapSearchFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type ProcessedSearchByMapSearchFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ProcessedSearchByMapSearchEntity!]!
}

input ProcessedSearchByMapSearchRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMapSearchRecoverInputWhere!]
}

input ProcessedSearchByMapSearchRecoverInputWhere {
  """Id of the processed search by mapsearch"""
  id: FindOperatorDto

  """Mls num of the processed search by mapsearch"""
  mls_num: FindOperatorDto

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: FindOperatorDto

  """Listing key of the processed search by mapsearch"""
  listing_key: FindOperatorDto

  """Agent id of the processed search by mapsearch"""
  agent_id: FindOperatorDto

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: FindOperatorDto

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: FindOperatorDto

  """Office id of the processed search by mapsearch"""
  office_id: FindOperatorDto

  """Co office id of the processed search by mapsearch"""
  co_office_id: FindOperatorDto

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: FindOperatorDto

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: FindOperatorDto

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: FindOperatorDto

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: FindOperatorDto

  """Property type of the processed search by mapsearch"""
  property_type: FindOperatorDto

  """Category of the processed search by mapsearch"""
  category: FindOperatorDto

  """Property status of the processed search by mapsearch"""
  property_status: FindOperatorDto

  """Subtype of the processed search by mapsearch"""
  subtype: FindOperatorDto

  """Baths full of the processed search by mapsearch"""
  baths_full: FindOperatorDto

  """Baths half of the processed search by mapsearch"""
  baths_half: FindOperatorDto

  """Baths of the processed search by mapsearch"""
  baths: FindOperatorDto

  """Beds of the processed search by mapsearch"""
  beds: FindOperatorDto

  """List price of the processed search by mapsearch"""
  list_price: FindOperatorDto

  """Sold price of the processed search by mapsearch"""
  sold_price: FindOperatorDto

  """Sqft of the processed search by mapsearch"""
  sqft: FindOperatorDto

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: FindOperatorDto

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: FindOperatorDto

  """Display address of the processed search by mapsearch"""
  display_address: FindOperatorDto

  """Elementary school of the processed search by mapsearch"""
  elementary_school: FindOperatorDto

  """High school of the processed search by mapsearch"""
  high_school: FindOperatorDto

  """Middle school of the processed search by mapsearch"""
  middle_school: FindOperatorDto

  """System name of the processed search by mapsearch"""
  system_name: FindOperatorDto

  """Address of the processed search by mapsearch"""
  address: FindOperatorDto

  """Area of the processed search by mapsearch"""
  area: FindOperatorDto

  """Subdivision of the processed search by mapsearch"""
  subdivision: FindOperatorDto

  """Street number of the processed search by mapsearch"""
  street_number: FindOperatorDto

  """Street direction of the processed search by mapsearch"""
  street_direction: FindOperatorDto

  """Street name of the processed search by mapsearch"""
  street_name: FindOperatorDto

  """Street suffix of the processed search by mapsearch"""
  street_suffix: FindOperatorDto

  """City name of the processed search by mapsearch"""
  city_name: FindOperatorDto

  """Zipcode of the processed search by mapsearch"""
  zipcode: FindOperatorDto

  """Latitude of the processed search by mapsearch"""
  latitude: FindOperatorDto

  """Longitude of the processed search by mapsearch"""
  longitude: FindOperatorDto

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: FindOperatorDto

  """Is hoa of the processed search by mapsearch"""
  is_hoa: FindOperatorDto

  """Is new of the processed search by mapsearch"""
  is_new: FindOperatorDto

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: FindOperatorDto

  """Furnished of the processed search by mapsearch"""
  furnished: FindOperatorDto

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: FindOperatorDto

  """Horse yn of the processed search by mapsearch"""
  horse_yn: FindOperatorDto

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: FindOperatorDto

  """Membership of the processed search by mapsearch"""
  membership: FindOperatorDto

  """Membership fee of the processed search by mapsearch"""
  membership_fee: FindOperatorDto

  """Building features of the processed search by mapsearch"""
  building_features: FindOperatorDto

  """Water of the processed search by mapsearch"""
  water: FindOperatorDto

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: FindOperatorDto

  """Office name of the processed search by mapsearch"""
  office_name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mapsearch."""
  fr_mlsp_id: RetsMlsProviderFindInputWhere
}

type ProcessedSearchByMapSearchRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByMapSearchEntity!]!
}

input ProcessedSearchByMapSearchRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMapSearchRemoveInputWhere!]
}

input ProcessedSearchByMapSearchRemoveInputWhere {
  """Id of the processed search by mapsearch"""
  id: FindOperatorDto

  """Mls num of the processed search by mapsearch"""
  mls_num: FindOperatorDto

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: FindOperatorDto

  """Listing key of the processed search by mapsearch"""
  listing_key: FindOperatorDto

  """Agent id of the processed search by mapsearch"""
  agent_id: FindOperatorDto

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: FindOperatorDto

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: FindOperatorDto

  """Office id of the processed search by mapsearch"""
  office_id: FindOperatorDto

  """Co office id of the processed search by mapsearch"""
  co_office_id: FindOperatorDto

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: FindOperatorDto

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: FindOperatorDto

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: FindOperatorDto

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: FindOperatorDto

  """Property type of the processed search by mapsearch"""
  property_type: FindOperatorDto

  """Category of the processed search by mapsearch"""
  category: FindOperatorDto

  """Property status of the processed search by mapsearch"""
  property_status: FindOperatorDto

  """Subtype of the processed search by mapsearch"""
  subtype: FindOperatorDto

  """Baths full of the processed search by mapsearch"""
  baths_full: FindOperatorDto

  """Baths half of the processed search by mapsearch"""
  baths_half: FindOperatorDto

  """Baths of the processed search by mapsearch"""
  baths: FindOperatorDto

  """Beds of the processed search by mapsearch"""
  beds: FindOperatorDto

  """List price of the processed search by mapsearch"""
  list_price: FindOperatorDto

  """Sold price of the processed search by mapsearch"""
  sold_price: FindOperatorDto

  """Sqft of the processed search by mapsearch"""
  sqft: FindOperatorDto

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: FindOperatorDto

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: FindOperatorDto

  """Display address of the processed search by mapsearch"""
  display_address: FindOperatorDto

  """Elementary school of the processed search by mapsearch"""
  elementary_school: FindOperatorDto

  """High school of the processed search by mapsearch"""
  high_school: FindOperatorDto

  """Middle school of the processed search by mapsearch"""
  middle_school: FindOperatorDto

  """System name of the processed search by mapsearch"""
  system_name: FindOperatorDto

  """Address of the processed search by mapsearch"""
  address: FindOperatorDto

  """Area of the processed search by mapsearch"""
  area: FindOperatorDto

  """Subdivision of the processed search by mapsearch"""
  subdivision: FindOperatorDto

  """Street number of the processed search by mapsearch"""
  street_number: FindOperatorDto

  """Street direction of the processed search by mapsearch"""
  street_direction: FindOperatorDto

  """Street name of the processed search by mapsearch"""
  street_name: FindOperatorDto

  """Street suffix of the processed search by mapsearch"""
  street_suffix: FindOperatorDto

  """City name of the processed search by mapsearch"""
  city_name: FindOperatorDto

  """Zipcode of the processed search by mapsearch"""
  zipcode: FindOperatorDto

  """Latitude of the processed search by mapsearch"""
  latitude: FindOperatorDto

  """Longitude of the processed search by mapsearch"""
  longitude: FindOperatorDto

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: FindOperatorDto

  """Is hoa of the processed search by mapsearch"""
  is_hoa: FindOperatorDto

  """Is new of the processed search by mapsearch"""
  is_new: FindOperatorDto

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: FindOperatorDto

  """Furnished of the processed search by mapsearch"""
  furnished: FindOperatorDto

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: FindOperatorDto

  """Horse yn of the processed search by mapsearch"""
  horse_yn: FindOperatorDto

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: FindOperatorDto

  """Membership of the processed search by mapsearch"""
  membership: FindOperatorDto

  """Membership fee of the processed search by mapsearch"""
  membership_fee: FindOperatorDto

  """Building features of the processed search by mapsearch"""
  building_features: FindOperatorDto

  """Water of the processed search by mapsearch"""
  water: FindOperatorDto

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: FindOperatorDto

  """Office name of the processed search by mapsearch"""
  office_name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mapsearch."""
  fr_mlsp_id: RetsMlsProviderFindInputWhere
}

type ProcessedSearchByMapSearchRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByMapSearchEntity!]!
}

input ProcessedSearchByMapSearchRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMapSearchRestoreInputWhere!]
}

input ProcessedSearchByMapSearchRestoreInputWhere {
  """Id of the processed search by mapsearch"""
  id: FindOperatorDto

  """Mls num of the processed search by mapsearch"""
  mls_num: FindOperatorDto

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: FindOperatorDto

  """Listing key of the processed search by mapsearch"""
  listing_key: FindOperatorDto

  """Agent id of the processed search by mapsearch"""
  agent_id: FindOperatorDto

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: FindOperatorDto

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: FindOperatorDto

  """Office id of the processed search by mapsearch"""
  office_id: FindOperatorDto

  """Co office id of the processed search by mapsearch"""
  co_office_id: FindOperatorDto

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: FindOperatorDto

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: FindOperatorDto

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: FindOperatorDto

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: FindOperatorDto

  """Property type of the processed search by mapsearch"""
  property_type: FindOperatorDto

  """Category of the processed search by mapsearch"""
  category: FindOperatorDto

  """Property status of the processed search by mapsearch"""
  property_status: FindOperatorDto

  """Subtype of the processed search by mapsearch"""
  subtype: FindOperatorDto

  """Baths full of the processed search by mapsearch"""
  baths_full: FindOperatorDto

  """Baths half of the processed search by mapsearch"""
  baths_half: FindOperatorDto

  """Baths of the processed search by mapsearch"""
  baths: FindOperatorDto

  """Beds of the processed search by mapsearch"""
  beds: FindOperatorDto

  """List price of the processed search by mapsearch"""
  list_price: FindOperatorDto

  """Sold price of the processed search by mapsearch"""
  sold_price: FindOperatorDto

  """Sqft of the processed search by mapsearch"""
  sqft: FindOperatorDto

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: FindOperatorDto

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: FindOperatorDto

  """Display address of the processed search by mapsearch"""
  display_address: FindOperatorDto

  """Elementary school of the processed search by mapsearch"""
  elementary_school: FindOperatorDto

  """High school of the processed search by mapsearch"""
  high_school: FindOperatorDto

  """Middle school of the processed search by mapsearch"""
  middle_school: FindOperatorDto

  """System name of the processed search by mapsearch"""
  system_name: FindOperatorDto

  """Address of the processed search by mapsearch"""
  address: FindOperatorDto

  """Area of the processed search by mapsearch"""
  area: FindOperatorDto

  """Subdivision of the processed search by mapsearch"""
  subdivision: FindOperatorDto

  """Street number of the processed search by mapsearch"""
  street_number: FindOperatorDto

  """Street direction of the processed search by mapsearch"""
  street_direction: FindOperatorDto

  """Street name of the processed search by mapsearch"""
  street_name: FindOperatorDto

  """Street suffix of the processed search by mapsearch"""
  street_suffix: FindOperatorDto

  """City name of the processed search by mapsearch"""
  city_name: FindOperatorDto

  """Zipcode of the processed search by mapsearch"""
  zipcode: FindOperatorDto

  """Latitude of the processed search by mapsearch"""
  latitude: FindOperatorDto

  """Longitude of the processed search by mapsearch"""
  longitude: FindOperatorDto

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: FindOperatorDto

  """Is hoa of the processed search by mapsearch"""
  is_hoa: FindOperatorDto

  """Is new of the processed search by mapsearch"""
  is_new: FindOperatorDto

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: FindOperatorDto

  """Furnished of the processed search by mapsearch"""
  furnished: FindOperatorDto

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: FindOperatorDto

  """Horse yn of the processed search by mapsearch"""
  horse_yn: FindOperatorDto

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: FindOperatorDto

  """Membership of the processed search by mapsearch"""
  membership: FindOperatorDto

  """Membership fee of the processed search by mapsearch"""
  membership_fee: FindOperatorDto

  """Building features of the processed search by mapsearch"""
  building_features: FindOperatorDto

  """Water of the processed search by mapsearch"""
  water: FindOperatorDto

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: FindOperatorDto

  """Office name of the processed search by mapsearch"""
  office_name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mapsearch."""
  fr_mlsp_id: RetsMlsProviderFindInputWhere
}

type ProcessedSearchByMapSearchRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByMapSearchSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMapSearchSoftDeleteInputWhere!]
}

input ProcessedSearchByMapSearchSoftDeleteInputWhere {
  """Id of the processed search by mapsearch"""
  id: FindOperatorDto

  """Mls num of the processed search by mapsearch"""
  mls_num: FindOperatorDto

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: FindOperatorDto

  """Listing key of the processed search by mapsearch"""
  listing_key: FindOperatorDto

  """Agent id of the processed search by mapsearch"""
  agent_id: FindOperatorDto

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: FindOperatorDto

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: FindOperatorDto

  """Office id of the processed search by mapsearch"""
  office_id: FindOperatorDto

  """Co office id of the processed search by mapsearch"""
  co_office_id: FindOperatorDto

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: FindOperatorDto

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: FindOperatorDto

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: FindOperatorDto

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: FindOperatorDto

  """Property type of the processed search by mapsearch"""
  property_type: FindOperatorDto

  """Category of the processed search by mapsearch"""
  category: FindOperatorDto

  """Property status of the processed search by mapsearch"""
  property_status: FindOperatorDto

  """Subtype of the processed search by mapsearch"""
  subtype: FindOperatorDto

  """Baths full of the processed search by mapsearch"""
  baths_full: FindOperatorDto

  """Baths half of the processed search by mapsearch"""
  baths_half: FindOperatorDto

  """Baths of the processed search by mapsearch"""
  baths: FindOperatorDto

  """Beds of the processed search by mapsearch"""
  beds: FindOperatorDto

  """List price of the processed search by mapsearch"""
  list_price: FindOperatorDto

  """Sold price of the processed search by mapsearch"""
  sold_price: FindOperatorDto

  """Sqft of the processed search by mapsearch"""
  sqft: FindOperatorDto

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: FindOperatorDto

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: FindOperatorDto

  """Display address of the processed search by mapsearch"""
  display_address: FindOperatorDto

  """Elementary school of the processed search by mapsearch"""
  elementary_school: FindOperatorDto

  """High school of the processed search by mapsearch"""
  high_school: FindOperatorDto

  """Middle school of the processed search by mapsearch"""
  middle_school: FindOperatorDto

  """System name of the processed search by mapsearch"""
  system_name: FindOperatorDto

  """Address of the processed search by mapsearch"""
  address: FindOperatorDto

  """Area of the processed search by mapsearch"""
  area: FindOperatorDto

  """Subdivision of the processed search by mapsearch"""
  subdivision: FindOperatorDto

  """Street number of the processed search by mapsearch"""
  street_number: FindOperatorDto

  """Street direction of the processed search by mapsearch"""
  street_direction: FindOperatorDto

  """Street name of the processed search by mapsearch"""
  street_name: FindOperatorDto

  """Street suffix of the processed search by mapsearch"""
  street_suffix: FindOperatorDto

  """City name of the processed search by mapsearch"""
  city_name: FindOperatorDto

  """Zipcode of the processed search by mapsearch"""
  zipcode: FindOperatorDto

  """Latitude of the processed search by mapsearch"""
  latitude: FindOperatorDto

  """Longitude of the processed search by mapsearch"""
  longitude: FindOperatorDto

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: FindOperatorDto

  """Is hoa of the processed search by mapsearch"""
  is_hoa: FindOperatorDto

  """Is new of the processed search by mapsearch"""
  is_new: FindOperatorDto

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: FindOperatorDto

  """Furnished of the processed search by mapsearch"""
  furnished: FindOperatorDto

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: FindOperatorDto

  """Horse yn of the processed search by mapsearch"""
  horse_yn: FindOperatorDto

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: FindOperatorDto

  """Membership of the processed search by mapsearch"""
  membership: FindOperatorDto

  """Membership fee of the processed search by mapsearch"""
  membership_fee: FindOperatorDto

  """Building features of the processed search by mapsearch"""
  building_features: FindOperatorDto

  """Water of the processed search by mapsearch"""
  water: FindOperatorDto

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: FindOperatorDto

  """Office name of the processed search by mapsearch"""
  office_name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mapsearch."""
  fr_mlsp_id: RetsMlsProviderFindInputWhere
}

type ProcessedSearchByMapSearchSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByMapSearchSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMapSearchSoftRemoveInputWhere!]
}

input ProcessedSearchByMapSearchSoftRemoveInputWhere {
  """Id of the processed search by mapsearch"""
  id: FindOperatorDto

  """Mls num of the processed search by mapsearch"""
  mls_num: FindOperatorDto

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: FindOperatorDto

  """Listing key of the processed search by mapsearch"""
  listing_key: FindOperatorDto

  """Agent id of the processed search by mapsearch"""
  agent_id: FindOperatorDto

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: FindOperatorDto

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: FindOperatorDto

  """Office id of the processed search by mapsearch"""
  office_id: FindOperatorDto

  """Co office id of the processed search by mapsearch"""
  co_office_id: FindOperatorDto

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: FindOperatorDto

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: FindOperatorDto

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: FindOperatorDto

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: FindOperatorDto

  """Property type of the processed search by mapsearch"""
  property_type: FindOperatorDto

  """Category of the processed search by mapsearch"""
  category: FindOperatorDto

  """Property status of the processed search by mapsearch"""
  property_status: FindOperatorDto

  """Subtype of the processed search by mapsearch"""
  subtype: FindOperatorDto

  """Baths full of the processed search by mapsearch"""
  baths_full: FindOperatorDto

  """Baths half of the processed search by mapsearch"""
  baths_half: FindOperatorDto

  """Baths of the processed search by mapsearch"""
  baths: FindOperatorDto

  """Beds of the processed search by mapsearch"""
  beds: FindOperatorDto

  """List price of the processed search by mapsearch"""
  list_price: FindOperatorDto

  """Sold price of the processed search by mapsearch"""
  sold_price: FindOperatorDto

  """Sqft of the processed search by mapsearch"""
  sqft: FindOperatorDto

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: FindOperatorDto

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: FindOperatorDto

  """Display address of the processed search by mapsearch"""
  display_address: FindOperatorDto

  """Elementary school of the processed search by mapsearch"""
  elementary_school: FindOperatorDto

  """High school of the processed search by mapsearch"""
  high_school: FindOperatorDto

  """Middle school of the processed search by mapsearch"""
  middle_school: FindOperatorDto

  """System name of the processed search by mapsearch"""
  system_name: FindOperatorDto

  """Address of the processed search by mapsearch"""
  address: FindOperatorDto

  """Area of the processed search by mapsearch"""
  area: FindOperatorDto

  """Subdivision of the processed search by mapsearch"""
  subdivision: FindOperatorDto

  """Street number of the processed search by mapsearch"""
  street_number: FindOperatorDto

  """Street direction of the processed search by mapsearch"""
  street_direction: FindOperatorDto

  """Street name of the processed search by mapsearch"""
  street_name: FindOperatorDto

  """Street suffix of the processed search by mapsearch"""
  street_suffix: FindOperatorDto

  """City name of the processed search by mapsearch"""
  city_name: FindOperatorDto

  """Zipcode of the processed search by mapsearch"""
  zipcode: FindOperatorDto

  """Latitude of the processed search by mapsearch"""
  latitude: FindOperatorDto

  """Longitude of the processed search by mapsearch"""
  longitude: FindOperatorDto

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: FindOperatorDto

  """Is hoa of the processed search by mapsearch"""
  is_hoa: FindOperatorDto

  """Is new of the processed search by mapsearch"""
  is_new: FindOperatorDto

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: FindOperatorDto

  """Furnished of the processed search by mapsearch"""
  furnished: FindOperatorDto

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: FindOperatorDto

  """Horse yn of the processed search by mapsearch"""
  horse_yn: FindOperatorDto

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: FindOperatorDto

  """Membership of the processed search by mapsearch"""
  membership: FindOperatorDto

  """Membership fee of the processed search by mapsearch"""
  membership_fee: FindOperatorDto

  """Building features of the processed search by mapsearch"""
  building_features: FindOperatorDto

  """Water of the processed search by mapsearch"""
  water: FindOperatorDto

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: FindOperatorDto

  """Office name of the processed search by mapsearch"""
  office_name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mapsearch."""
  fr_mlsp_id: RetsMlsProviderFindInputWhere
}

type ProcessedSearchByMapSearchSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByMapSearchEntity!]!
}

input ProcessedSearchByMapSearchUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMapSearchUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ProcessedSearchByMapSearchUpdateInputSets!
}

input ProcessedSearchByMapSearchUpdateInputSets {
  """Mls num of the processed search by mapsearch"""
  mls_num: String

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: Int

  """Listing key of the processed search by mapsearch"""
  listing_key: String

  """Agent id of the processed search by mapsearch"""
  agent_id: String

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: String

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: String

  """Office id of the processed search by mapsearch"""
  office_id: String

  """Co office id of the processed search by mapsearch"""
  co_office_id: String

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: String

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: String

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: String

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: String

  """Property type of the processed search by mapsearch"""
  property_type: String

  """Property style of the processed search by mapsearch"""
  property_style: String

  """Category of the processed search by mapsearch"""
  category: String

  """Property status of the processed search by mapsearch"""
  property_status: String

  """Subtype of the processed search by mapsearch"""
  subtype: String

  """Baths full of the processed search by mapsearch"""
  baths_full: Int

  """Baths half of the processed search by mapsearch"""
  baths_half: Int

  """Baths of the processed search by mapsearch"""
  baths: Int

  """Beds of the processed search by mapsearch"""
  beds: Int

  """List price of the processed search by mapsearch"""
  list_price: Float

  """Original list price of the processed search by mapsearch"""
  original_list_price: Float

  """Sold price of the processed search by mapsearch"""
  sold_price: Float

  """Sold date of the processed search by mapsearch"""
  sold_date: DateTime

  """Sqft of the processed search by mapsearch"""
  sqft: Float

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: Int

  """Total photos of the processed search by mapsearch"""
  total_photos: Int

  """Main photo of the processed search by mapsearch"""
  main_photo: Int

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: String

  """Display address of the processed search by mapsearch"""
  display_address: String

  """Listing date of the processed search by mapsearch"""
  listing_date: DateTime

  """Last update date of the processed search by mapsearch"""
  last_update_date: DateTime

  """Elementary school of the processed search by mapsearch"""
  elementary_school: String

  """High school of the processed search by mapsearch"""
  high_school: String

  """Middle school of the processed search by mapsearch"""
  middle_school: String

  """Price diff of the processed search by mapsearch"""
  price_diff: Float

  """System name of the processed search by mapsearch"""
  system_name: String

  """Address of the processed search by mapsearch"""
  address: String

  """Area of the processed search by mapsearch"""
  area: String

  """Subdivision of the processed search by mapsearch"""
  subdivision: String

  """Unit no of the processed search by mapsearch"""
  unit_no: String

  """Street number of the processed search by mapsearch"""
  street_number: String

  """Street direction of the processed search by mapsearch"""
  street_direction: String

  """Street dir prefix of the processed search by mapsearch"""
  street_dir_prefix: String

  """Street name of the processed search by mapsearch"""
  street_name: String

  """Street suffix of the processed search by mapsearch"""
  street_suffix: String

  """Street dir suffix of the processed search by mapsearch"""
  street_dir_suffix: String

  """City name of the processed search by mapsearch"""
  city_name: String

  """State of the processed search by mapsearch"""
  state: String

  """County of the processed search by mapsearch"""
  county: String

  """Zipcode of the processed search by mapsearch"""
  zipcode: String

  """Latitude of the processed search by mapsearch"""
  latitude: Float

  """Longitude of the processed search by mapsearch"""
  longitude: Float

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: Float

  """Is hoa of the processed search by mapsearch"""
  is_hoa: String

  """Is new of the processed search by mapsearch"""
  is_new: String

  """Pool desc of the processed search by mapsearch"""
  pool_desc: String

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: String

  """Furnished of the processed search by mapsearch"""
  furnished: String

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: String

  """Waterfront desc of the processed search by mapsearch"""
  waterfront_desc: String

  """Horse yn of the processed search by mapsearch"""
  horse_yn: String

  """Horse amenities of the processed search by mapsearch"""
  horse_amenities: String

  """Security safety of the processed search by mapsearch"""
  security_safety: String

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: String

  """Membership of the processed search by mapsearch"""
  membership: String

  """Membership fee of the processed search by mapsearch"""
  membership_fee: Float

  """Virtual tour url of the processed search by mapsearch"""
  virtual_tour_url: String

  """Description of the processed search by mapsearch"""
  description: String

  """Exterior features of the processed search by mapsearch"""
  exterior_features: String

  """Building features of the processed search by mapsearch"""
  building_features: String

  """Construction of the processed search by mapsearch"""
  construction: String

  """Sewer of the processed search by mapsearch"""
  sewer: String

  """Water of the processed search by mapsearch"""
  water: String

  """Zoning of the processed search by mapsearch"""
  zoning: String

  """Legal of the processed search by mapsearch"""
  legal: String

  """Fireplace features of the processed search by mapsearch"""
  fireplace_features: String

  """Amenities of the processed search by mapsearch"""
  amenities: String

  """Cooling of the processed search by mapsearch"""
  cooling: String

  """Appliances of the processed search by mapsearch"""
  appliances: String

  """Flooring of the processed search by mapsearch"""
  flooring: String

  """Heating of the processed search by mapsearch"""
  heating: String

  """Interior features of the processed search by mapsearch"""
  interior_features: String

  """Roof of the processed search by mapsearch"""
  roof: String

  """Spa features of the processed search by mapsearch"""
  spa_features: String

  """Community features of the processed search by mapsearch"""
  community_features: String

  """Parking features of the processed search by mapsearch"""
  parking_features: String

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: String

  """Dom of the processed search by mapsearch"""
  dom: Int

  """Office name of the processed search by mapsearch"""
  office_name: String
}

input ProcessedSearchByMapSearchUpdateInputWhere {
  """Id of the processed search by mapsearch"""
  id: FindOperatorDto

  """Mls num of the processed search by mapsearch"""
  mls_num: FindOperatorDto

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: FindOperatorDto

  """Listing key of the processed search by mapsearch"""
  listing_key: FindOperatorDto

  """Agent id of the processed search by mapsearch"""
  agent_id: FindOperatorDto

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: FindOperatorDto

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: FindOperatorDto

  """Office id of the processed search by mapsearch"""
  office_id: FindOperatorDto

  """Co office id of the processed search by mapsearch"""
  co_office_id: FindOperatorDto

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: FindOperatorDto

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: FindOperatorDto

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: FindOperatorDto

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: FindOperatorDto

  """Property type of the processed search by mapsearch"""
  property_type: FindOperatorDto

  """Category of the processed search by mapsearch"""
  category: FindOperatorDto

  """Property status of the processed search by mapsearch"""
  property_status: FindOperatorDto

  """Subtype of the processed search by mapsearch"""
  subtype: FindOperatorDto

  """Baths full of the processed search by mapsearch"""
  baths_full: FindOperatorDto

  """Baths half of the processed search by mapsearch"""
  baths_half: FindOperatorDto

  """Baths of the processed search by mapsearch"""
  baths: FindOperatorDto

  """Beds of the processed search by mapsearch"""
  beds: FindOperatorDto

  """List price of the processed search by mapsearch"""
  list_price: FindOperatorDto

  """Sold price of the processed search by mapsearch"""
  sold_price: FindOperatorDto

  """Sqft of the processed search by mapsearch"""
  sqft: FindOperatorDto

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: FindOperatorDto

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: FindOperatorDto

  """Display address of the processed search by mapsearch"""
  display_address: FindOperatorDto

  """Elementary school of the processed search by mapsearch"""
  elementary_school: FindOperatorDto

  """High school of the processed search by mapsearch"""
  high_school: FindOperatorDto

  """Middle school of the processed search by mapsearch"""
  middle_school: FindOperatorDto

  """System name of the processed search by mapsearch"""
  system_name: FindOperatorDto

  """Address of the processed search by mapsearch"""
  address: FindOperatorDto

  """Area of the processed search by mapsearch"""
  area: FindOperatorDto

  """Subdivision of the processed search by mapsearch"""
  subdivision: FindOperatorDto

  """Street number of the processed search by mapsearch"""
  street_number: FindOperatorDto

  """Street direction of the processed search by mapsearch"""
  street_direction: FindOperatorDto

  """Street name of the processed search by mapsearch"""
  street_name: FindOperatorDto

  """Street suffix of the processed search by mapsearch"""
  street_suffix: FindOperatorDto

  """City name of the processed search by mapsearch"""
  city_name: FindOperatorDto

  """Zipcode of the processed search by mapsearch"""
  zipcode: FindOperatorDto

  """Latitude of the processed search by mapsearch"""
  latitude: FindOperatorDto

  """Longitude of the processed search by mapsearch"""
  longitude: FindOperatorDto

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: FindOperatorDto

  """Is hoa of the processed search by mapsearch"""
  is_hoa: FindOperatorDto

  """Is new of the processed search by mapsearch"""
  is_new: FindOperatorDto

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: FindOperatorDto

  """Furnished of the processed search by mapsearch"""
  furnished: FindOperatorDto

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: FindOperatorDto

  """Horse yn of the processed search by mapsearch"""
  horse_yn: FindOperatorDto

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: FindOperatorDto

  """Membership of the processed search by mapsearch"""
  membership: FindOperatorDto

  """Membership fee of the processed search by mapsearch"""
  membership_fee: FindOperatorDto

  """Building features of the processed search by mapsearch"""
  building_features: FindOperatorDto

  """Water of the processed search by mapsearch"""
  water: FindOperatorDto

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: FindOperatorDto

  """Office name of the processed search by mapsearch"""
  office_name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mapsearch."""
  fr_mlsp_id: RetsMlsProviderFindInputWhere
}

type ProcessedSearchByMapSearchUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ProcessedSearchByMapSearchEntity!]!
}

input ProcessedSearchByMapSearchUpsertInput {
  """Mls num of the processed search by mapsearch"""
  mls_num: String!

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: Int!

  """Listing key of the processed search by mapsearch"""
  listing_key: String!

  """Agent id of the processed search by mapsearch"""
  agent_id: String!

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: String

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: String

  """Office id of the processed search by mapsearch"""
  office_id: String!

  """Co office id of the processed search by mapsearch"""
  co_office_id: String

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: String

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: String

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: String

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: String

  """Property type of the processed search by mapsearch"""
  property_type: String!

  """Property style of the processed search by mapsearch"""
  property_style: String

  """Category of the processed search by mapsearch"""
  category: String!

  """Property status of the processed search by mapsearch"""
  property_status: String!

  """Subtype of the processed search by mapsearch"""
  subtype: String

  """Baths full of the processed search by mapsearch"""
  baths_full: Int!

  """Baths half of the processed search by mapsearch"""
  baths_half: Int!

  """Baths of the processed search by mapsearch"""
  baths: Int!

  """Beds of the processed search by mapsearch"""
  beds: Int!

  """List price of the processed search by mapsearch"""
  list_price: Float

  """Original list price of the processed search by mapsearch"""
  original_list_price: Float

  """Sold price of the processed search by mapsearch"""
  sold_price: Float

  """Sold date of the processed search by mapsearch"""
  sold_date: DateTime

  """Sqft of the processed search by mapsearch"""
  sqft: Float

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: Int

  """Total photos of the processed search by mapsearch"""
  total_photos: Int

  """Main photo of the processed search by mapsearch"""
  main_photo: Int

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: String

  """Display address of the processed search by mapsearch"""
  display_address: String!

  """Listing date of the processed search by mapsearch"""
  listing_date: DateTime!

  """Last update date of the processed search by mapsearch"""
  last_update_date: DateTime

  """Elementary school of the processed search by mapsearch"""
  elementary_school: String

  """High school of the processed search by mapsearch"""
  high_school: String

  """Middle school of the processed search by mapsearch"""
  middle_school: String

  """Price diff of the processed search by mapsearch"""
  price_diff: Float!

  """System name of the processed search by mapsearch"""
  system_name: String!

  """Address of the processed search by mapsearch"""
  address: String!

  """Area of the processed search by mapsearch"""
  area: String

  """Subdivision of the processed search by mapsearch"""
  subdivision: String

  """Unit no of the processed search by mapsearch"""
  unit_no: String

  """Street number of the processed search by mapsearch"""
  street_number: String!

  """Street direction of the processed search by mapsearch"""
  street_direction: String!

  """Street dir prefix of the processed search by mapsearch"""
  street_dir_prefix: String!

  """Street name of the processed search by mapsearch"""
  street_name: String!

  """Street suffix of the processed search by mapsearch"""
  street_suffix: String!

  """Street dir suffix of the processed search by mapsearch"""
  street_dir_suffix: String!

  """City name of the processed search by mapsearch"""
  city_name: String!

  """State of the processed search by mapsearch"""
  state: String!

  """County of the processed search by mapsearch"""
  county: String!

  """Zipcode of the processed search by mapsearch"""
  zipcode: String!

  """Latitude of the processed search by mapsearch"""
  latitude: Float

  """Longitude of the processed search by mapsearch"""
  longitude: Float

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: Float

  """Is hoa of the processed search by mapsearch"""
  is_hoa: String

  """Is new of the processed search by mapsearch"""
  is_new: String

  """Pool desc of the processed search by mapsearch"""
  pool_desc: String

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: String

  """Furnished of the processed search by mapsearch"""
  furnished: String

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: String

  """Waterfront desc of the processed search by mapsearch"""
  waterfront_desc: String

  """Horse yn of the processed search by mapsearch"""
  horse_yn: String!

  """Horse amenities of the processed search by mapsearch"""
  horse_amenities: String

  """Security safety of the processed search by mapsearch"""
  security_safety: String

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: String!

  """Membership of the processed search by mapsearch"""
  membership: String

  """Membership fee of the processed search by mapsearch"""
  membership_fee: Float

  """Virtual tour url of the processed search by mapsearch"""
  virtual_tour_url: String

  """Description of the processed search by mapsearch"""
  description: String

  """Exterior features of the processed search by mapsearch"""
  exterior_features: String

  """Building features of the processed search by mapsearch"""
  building_features: String

  """Construction of the processed search by mapsearch"""
  construction: String

  """Sewer of the processed search by mapsearch"""
  sewer: String

  """Water of the processed search by mapsearch"""
  water: String

  """Zoning of the processed search by mapsearch"""
  zoning: String

  """Legal of the processed search by mapsearch"""
  legal: String

  """Fireplace features of the processed search by mapsearch"""
  fireplace_features: String

  """Amenities of the processed search by mapsearch"""
  amenities: String

  """Cooling of the processed search by mapsearch"""
  cooling: String

  """Appliances of the processed search by mapsearch"""
  appliances: String

  """Flooring of the processed search by mapsearch"""
  flooring: String

  """Heating of the processed search by mapsearch"""
  heating: String

  """Interior features of the processed search by mapsearch"""
  interior_features: String

  """Roof of the processed search by mapsearch"""
  roof: String

  """Spa features of the processed search by mapsearch"""
  spa_features: String

  """Community features of the processed search by mapsearch"""
  community_features: String

  """Parking features of the processed search by mapsearch"""
  parking_features: String

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: String!

  """Dom of the processed search by mapsearch"""
  dom: Int

  """Office name of the processed search by mapsearch"""
  office_name: String

  """Id of the processed search by mapsearch undefined"""
  id: Int
}

type ProcessedSearchByMapSearchUpsertOutput {
  """Id of the processed search by mapsearch"""
  id: Int

  """Mls num of the processed search by mapsearch"""
  mls_num: String

  """Mlsp id of the processed search by mapsearch"""
  mlsp_id: Int

  """Listing key of the processed search by mapsearch"""
  listing_key: String

  """Agent id of the processed search by mapsearch"""
  agent_id: String

  """Agent short id of the processed search by mapsearch"""
  agent_short_id: String

  """Co agent id of the processed search by mapsearch"""
  co_agent_id: String

  """Office id of the processed search by mapsearch"""
  office_id: String

  """Co office id of the processed search by mapsearch"""
  co_office_id: String

  """Co agent short id of the processed search by mapsearch"""
  co_agent_short_id: String

  """Sell agent short id of the processed search by mapsearch"""
  sell_agent_short_id: String

  """Buy agent id of the processed search by mapsearch"""
  buy_agent_id: String

  """Co buy agent id of the processed search by mapsearch"""
  co_buy_agent_id: String

  """Property type of the processed search by mapsearch"""
  property_type: String

  """Property style of the processed search by mapsearch"""
  property_style: String

  """Category of the processed search by mapsearch"""
  category: String

  """Property status of the processed search by mapsearch"""
  property_status: String

  """Subtype of the processed search by mapsearch"""
  subtype: String

  """Baths full of the processed search by mapsearch"""
  baths_full: Int

  """Baths half of the processed search by mapsearch"""
  baths_half: Int

  """Baths of the processed search by mapsearch"""
  baths: Int

  """Beds of the processed search by mapsearch"""
  beds: Int

  """List price of the processed search by mapsearch"""
  list_price: Float

  """Original list price of the processed search by mapsearch"""
  original_list_price: Float

  """Sold price of the processed search by mapsearch"""
  sold_price: Float

  """Sold date of the processed search by mapsearch"""
  sold_date: DateTime

  """Sqft of the processed search by mapsearch"""
  sqft: Float

  """Yearbuilt of the processed search by mapsearch"""
  yearbuilt: Int

  """Total photos of the processed search by mapsearch"""
  total_photos: Int

  """Main photo of the processed search by mapsearch"""
  main_photo: Int

  """Main photo url of the processed search by mapsearch"""
  main_photo_url: String

  """Display address of the processed search by mapsearch"""
  display_address: String

  """Listing date of the processed search by mapsearch"""
  listing_date: DateTime

  """Last update date of the processed search by mapsearch"""
  last_update_date: DateTime

  """Elementary school of the processed search by mapsearch"""
  elementary_school: String

  """High school of the processed search by mapsearch"""
  high_school: String

  """Middle school of the processed search by mapsearch"""
  middle_school: String

  """Price diff of the processed search by mapsearch"""
  price_diff: Float

  """System name of the processed search by mapsearch"""
  system_name: String

  """Address of the processed search by mapsearch"""
  address: String

  """Area of the processed search by mapsearch"""
  area: String

  """Subdivision of the processed search by mapsearch"""
  subdivision: String

  """Unit no of the processed search by mapsearch"""
  unit_no: String

  """Street number of the processed search by mapsearch"""
  street_number: String

  """Street direction of the processed search by mapsearch"""
  street_direction: String

  """Street dir prefix of the processed search by mapsearch"""
  street_dir_prefix: String

  """Street name of the processed search by mapsearch"""
  street_name: String

  """Street suffix of the processed search by mapsearch"""
  street_suffix: String

  """Street dir suffix of the processed search by mapsearch"""
  street_dir_suffix: String

  """City name of the processed search by mapsearch"""
  city_name: String

  """State of the processed search by mapsearch"""
  state: String

  """County of the processed search by mapsearch"""
  county: String

  """Zipcode of the processed search by mapsearch"""
  zipcode: String

  """Latitude of the processed search by mapsearch"""
  latitude: Float

  """Longitude of the processed search by mapsearch"""
  longitude: Float

  """Lotsize sqft of the processed search by mapsearch"""
  lotsize_sqft: Float

  """Is hoa of the processed search by mapsearch"""
  is_hoa: String

  """Is new of the processed search by mapsearch"""
  is_new: String

  """Pool desc of the processed search by mapsearch"""
  pool_desc: String

  """Pets allowed of the processed search by mapsearch"""
  pets_allowed: String

  """Furnished of the processed search by mapsearch"""
  furnished: String

  """Is waterfront of the processed search by mapsearch"""
  is_waterfront: String

  """Waterfront desc of the processed search by mapsearch"""
  waterfront_desc: String

  """Horse yn of the processed search by mapsearch"""
  horse_yn: String

  """Horse amenities of the processed search by mapsearch"""
  horse_amenities: String

  """Security safety of the processed search by mapsearch"""
  security_safety: String

  """Membership required yn of the processed search by mapsearch"""
  membership_required_yn: String

  """Membership of the processed search by mapsearch"""
  membership: String

  """Membership fee of the processed search by mapsearch"""
  membership_fee: Float

  """Virtual tour url of the processed search by mapsearch"""
  virtual_tour_url: String

  """Description of the processed search by mapsearch"""
  description: String

  """Exterior features of the processed search by mapsearch"""
  exterior_features: String

  """Building features of the processed search by mapsearch"""
  building_features: String

  """Construction of the processed search by mapsearch"""
  construction: String

  """Sewer of the processed search by mapsearch"""
  sewer: String

  """Water of the processed search by mapsearch"""
  water: String

  """Zoning of the processed search by mapsearch"""
  zoning: String

  """Legal of the processed search by mapsearch"""
  legal: String

  """Fireplace features of the processed search by mapsearch"""
  fireplace_features: String

  """Amenities of the processed search by mapsearch"""
  amenities: String

  """Cooling of the processed search by mapsearch"""
  cooling: String

  """Appliances of the processed search by mapsearch"""
  appliances: String

  """Flooring of the processed search by mapsearch"""
  flooring: String

  """Heating of the processed search by mapsearch"""
  heating: String

  """Interior features of the processed search by mapsearch"""
  interior_features: String

  """Roof of the processed search by mapsearch"""
  roof: String

  """Spa features of the processed search by mapsearch"""
  spa_features: String

  """Community features of the processed search by mapsearch"""
  community_features: String

  """Parking features of the processed search by mapsearch"""
  parking_features: String

  """Mls is pic url supported of the processed search by mapsearch"""
  mls_is_pic_url_supported: String!

  """Dom of the processed search by mapsearch"""
  dom: Int

  """Office name of the processed search by mapsearch"""
  office_name: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input ProcessedSearchByMlsCreateInput {
  """MLSP ID"""
  mlsp_id: Int!

  """Mls num of the processed search by mls"""
  mls_num: String!

  """Property type of the processed search by mls"""
  property_type: String!

  """Property state of the processed search by mls"""
  property_status: String!
}

type ProcessedSearchByMlsCreateOutput {
  """Unique ID of the processed search by mls, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by mls"""
  mls_num: String

  """Property type of the processed search by mls"""
  property_type: String

  """Property state of the processed search by mls"""
  property_status: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by mls."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input ProcessedSearchByMlsDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMlsDeleteInputWhere!]
}

input ProcessedSearchByMlsDeleteInputWhere {
  """Unique ID of the processed search by mls, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by mls"""
  mls_num: FindOperatorDto

  """Property type of the processed search by mls"""
  property_type: FindOperatorDto

  """Property state of the processed search by mls"""
  property_status: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mls."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByMlsDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type ProcessedSearchByMlsEntity {
  """Unique ID of the processed search by mls, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by mls"""
  mls_num: String

  """Property type of the processed search by mls"""
  property_type: String

  """Property state of the processed search by mls"""
  property_status: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by mls."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input ProcessedSearchByMlsFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMlsFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ProcessedSearchByMlsFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ProcessedSearchByMlsFindInputSortOrder
}

input ProcessedSearchByMlsFindInputGroupBy {
  mlsp_id: Boolean
  mls_num: Boolean
  property_type: Boolean
  property_status: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ProcessedSearchByMlsFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  property_type: RecordSortDirectionEnum
  property_status: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ProcessedSearchByMlsFindInputWhere {
  """Unique ID of the processed search by mls, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by mls"""
  mls_num: FindOperatorDto

  """Property type of the processed search by mls"""
  property_type: FindOperatorDto

  """Property state of the processed search by mls"""
  property_status: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mls."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input ProcessedSearchByMlsFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type ProcessedSearchByMlsFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ProcessedSearchByMlsEntity!]!
}

input ProcessedSearchByMlsRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMlsRecoverInputWhere!]
}

input ProcessedSearchByMlsRecoverInputWhere {
  """Unique ID of the processed search by mls, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by mls"""
  mls_num: FindOperatorDto

  """Property type of the processed search by mls"""
  property_type: FindOperatorDto

  """Property state of the processed search by mls"""
  property_status: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mls."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByMlsRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByMlsEntity!]!
}

input ProcessedSearchByMlsRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMlsRemoveInputWhere!]
}

input ProcessedSearchByMlsRemoveInputWhere {
  """Unique ID of the processed search by mls, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by mls"""
  mls_num: FindOperatorDto

  """Property type of the processed search by mls"""
  property_type: FindOperatorDto

  """Property state of the processed search by mls"""
  property_status: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mls."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByMlsRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByMlsEntity!]!
}

input ProcessedSearchByMlsRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMlsRestoreInputWhere!]
}

input ProcessedSearchByMlsRestoreInputWhere {
  """Unique ID of the processed search by mls, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by mls"""
  mls_num: FindOperatorDto

  """Property type of the processed search by mls"""
  property_type: FindOperatorDto

  """Property state of the processed search by mls"""
  property_status: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mls."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByMlsRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByMlsSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMlsSoftDeleteInputWhere!]
}

input ProcessedSearchByMlsSoftDeleteInputWhere {
  """Unique ID of the processed search by mls, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by mls"""
  mls_num: FindOperatorDto

  """Property type of the processed search by mls"""
  property_type: FindOperatorDto

  """Property state of the processed search by mls"""
  property_status: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mls."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByMlsSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByMlsSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMlsSoftRemoveInputWhere!]
}

input ProcessedSearchByMlsSoftRemoveInputWhere {
  """Unique ID of the processed search by mls, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by mls"""
  mls_num: FindOperatorDto

  """Property type of the processed search by mls"""
  property_type: FindOperatorDto

  """Property state of the processed search by mls"""
  property_status: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mls."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByMlsSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByMlsEntity!]!
}

input ProcessedSearchByMlsUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByMlsUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ProcessedSearchByMlsUpdateInputSets!
}

input ProcessedSearchByMlsUpdateInputSets {
  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by mls"""
  mls_num: String

  """Property type of the processed search by mls"""
  property_type: String

  """Property state of the processed search by mls"""
  property_status: String
}

input ProcessedSearchByMlsUpdateInputWhere {
  """Unique ID of the processed search by mls, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by mls"""
  mls_num: FindOperatorDto

  """Property type of the processed search by mls"""
  property_type: FindOperatorDto

  """Property state of the processed search by mls"""
  property_status: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by mls."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByMlsUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ProcessedSearchByMlsEntity!]!
}

input ProcessedSearchByMlsUpsertInput {
  """MLSP ID"""
  mlsp_id: Int!

  """Mls num of the processed search by mls"""
  mls_num: String!

  """Property type of the processed search by mls"""
  property_type: String!

  """Property state of the processed search by mls"""
  property_status: String!

  """Unique ID of the processed search by mls, auto generated. undefined"""
  id: Int
}

type ProcessedSearchByMlsUpsertOutput {
  """Unique ID of the processed search by mls, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by mls"""
  mls_num: String

  """Property type of the processed search by mls"""
  property_type: String

  """Property state of the processed search by mls"""
  property_status: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by mls."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input ProcessedSearchByNeighbourhoodCreateInput {
  """Unit no"""
  unit_no: String!

  """Property type of the processed search by neighbourhood"""
  property_type: String!

  """Sub type of the processed search by neighbourhood"""
  subtype: String!

  """Subdivision of the processed search by neighbourhood"""
  subdivision: String!
}

type ProcessedSearchByNeighbourhoodCreateOutput {
  """Unique ID of the processed search by neighbourhood, auto generated."""
  id: Int

  """Unit no"""
  unit_no: String

  """Property type of the processed search by neighbourhood"""
  property_type: String

  """Sub type of the processed search by neighbourhood"""
  subtype: String

  """Subdivision of the processed search by neighbourhood"""
  subdivision: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ProcessedSearchByNeighbourhoodDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByNeighbourhoodDeleteInputWhere!]
}

input ProcessedSearchByNeighbourhoodDeleteInputWhere {
  """Unique ID of the processed search by neighbourhood, auto generated."""
  id: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Property type of the processed search by neighbourhood"""
  property_type: FindOperatorDto

  """Sub type of the processed search by neighbourhood"""
  subtype: FindOperatorDto

  """Subdivision of the processed search by neighbourhood"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByNeighbourhoodDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type ProcessedSearchByNeighbourhoodEntity {
  """Unique ID of the processed search by neighbourhood, auto generated."""
  id: Int

  """Unit no"""
  unit_no: String

  """Property type of the processed search by neighbourhood"""
  property_type: String

  """Sub type of the processed search by neighbourhood"""
  subtype: String

  """Subdivision of the processed search by neighbourhood"""
  subdivision: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input ProcessedSearchByNeighbourhoodFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByNeighbourhoodFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ProcessedSearchByNeighbourhoodFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ProcessedSearchByNeighbourhoodFindInputSortOrder
}

input ProcessedSearchByNeighbourhoodFindInputGroupBy {
  unit_no: Boolean
  property_type: Boolean
  subtype: Boolean
  subdivision: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ProcessedSearchByNeighbourhoodFindInputSortOrder {
  id: RecordSortDirectionEnum
  unit_no: RecordSortDirectionEnum
  property_type: RecordSortDirectionEnum
  subtype: RecordSortDirectionEnum
  subdivision: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ProcessedSearchByNeighbourhoodFindInputWhere {
  """Unique ID of the processed search by neighbourhood, auto generated."""
  id: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Property type of the processed search by neighbourhood"""
  property_type: FindOperatorDto

  """Sub type of the processed search by neighbourhood"""
  subtype: FindOperatorDto

  """Subdivision of the processed search by neighbourhood"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

input ProcessedSearchByNeighbourhoodFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type ProcessedSearchByNeighbourhoodFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ProcessedSearchByNeighbourhoodEntity!]!
}

input ProcessedSearchByNeighbourhoodRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByNeighbourhoodRecoverInputWhere!]
}

input ProcessedSearchByNeighbourhoodRecoverInputWhere {
  """Unique ID of the processed search by neighbourhood, auto generated."""
  id: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Property type of the processed search by neighbourhood"""
  property_type: FindOperatorDto

  """Sub type of the processed search by neighbourhood"""
  subtype: FindOperatorDto

  """Subdivision of the processed search by neighbourhood"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByNeighbourhoodRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByNeighbourhoodEntity!]!
}

input ProcessedSearchByNeighbourhoodRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByNeighbourhoodRemoveInputWhere!]
}

input ProcessedSearchByNeighbourhoodRemoveInputWhere {
  """Unique ID of the processed search by neighbourhood, auto generated."""
  id: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Property type of the processed search by neighbourhood"""
  property_type: FindOperatorDto

  """Sub type of the processed search by neighbourhood"""
  subtype: FindOperatorDto

  """Subdivision of the processed search by neighbourhood"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByNeighbourhoodRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByNeighbourhoodEntity!]!
}

input ProcessedSearchByNeighbourhoodRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByNeighbourhoodRestoreInputWhere!]
}

input ProcessedSearchByNeighbourhoodRestoreInputWhere {
  """Unique ID of the processed search by neighbourhood, auto generated."""
  id: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Property type of the processed search by neighbourhood"""
  property_type: FindOperatorDto

  """Sub type of the processed search by neighbourhood"""
  subtype: FindOperatorDto

  """Subdivision of the processed search by neighbourhood"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByNeighbourhoodRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByNeighbourhoodSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByNeighbourhoodSoftDeleteInputWhere!]
}

input ProcessedSearchByNeighbourhoodSoftDeleteInputWhere {
  """Unique ID of the processed search by neighbourhood, auto generated."""
  id: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Property type of the processed search by neighbourhood"""
  property_type: FindOperatorDto

  """Sub type of the processed search by neighbourhood"""
  subtype: FindOperatorDto

  """Subdivision of the processed search by neighbourhood"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByNeighbourhoodSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByNeighbourhoodSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByNeighbourhoodSoftRemoveInputWhere!]
}

input ProcessedSearchByNeighbourhoodSoftRemoveInputWhere {
  """Unique ID of the processed search by neighbourhood, auto generated."""
  id: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Property type of the processed search by neighbourhood"""
  property_type: FindOperatorDto

  """Sub type of the processed search by neighbourhood"""
  subtype: FindOperatorDto

  """Subdivision of the processed search by neighbourhood"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByNeighbourhoodSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByNeighbourhoodEntity!]!
}

input ProcessedSearchByNeighbourhoodUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByNeighbourhoodUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ProcessedSearchByNeighbourhoodUpdateInputSets!
}

input ProcessedSearchByNeighbourhoodUpdateInputSets {
  """Unit no"""
  unit_no: String

  """Property type of the processed search by neighbourhood"""
  property_type: String

  """Sub type of the processed search by neighbourhood"""
  subtype: String

  """Subdivision of the processed search by neighbourhood"""
  subdivision: String
}

input ProcessedSearchByNeighbourhoodUpdateInputWhere {
  """Unique ID of the processed search by neighbourhood, auto generated."""
  id: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Property type of the processed search by neighbourhood"""
  property_type: FindOperatorDto

  """Sub type of the processed search by neighbourhood"""
  subtype: FindOperatorDto

  """Subdivision of the processed search by neighbourhood"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type ProcessedSearchByNeighbourhoodUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ProcessedSearchByNeighbourhoodEntity!]!
}

input ProcessedSearchByNeighbourhoodUpsertInput {
  """Unit no"""
  unit_no: String!

  """Property type of the processed search by neighbourhood"""
  property_type: String!

  """Sub type of the processed search by neighbourhood"""
  subtype: String!

  """Subdivision of the processed search by neighbourhood"""
  subdivision: String!

  """
  Unique ID of the processed search by neighbourhood, auto generated. undefined
  """
  id: Int
}

type ProcessedSearchByNeighbourhoodUpsertOutput {
  """Unique ID of the processed search by neighbourhood, auto generated."""
  id: Int

  """Unit no"""
  unit_no: String

  """Property type of the processed search by neighbourhood"""
  property_type: String

  """Sub type of the processed search by neighbourhood"""
  subtype: String

  """Subdivision of the processed search by neighbourhood"""
  subdivision: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input ProcessedSearchBySubdivisionCreateInput {
  """MLSP ID"""
  mlsp_id: Int!

  """Mls num of the processed search by subdivision"""
  mls_num: String!

  """Property type of the processed search by subdivision"""
  property_type: String!

  """Subdivision of the processed search by subdivision"""
  subdivision: String!
}

type ProcessedSearchBySubdivisionCreateOutput {
  """Unique ID of the processed search by subdivision, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by subdivision"""
  mls_num: String

  """Property type of the processed search by subdivision"""
  property_type: String

  """Subdivision of the processed search by subdivision"""
  subdivision: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by subdivision."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input ProcessedSearchBySubdivisionDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchBySubdivisionDeleteInputWhere!]
}

input ProcessedSearchBySubdivisionDeleteInputWhere {
  """Unique ID of the processed search by subdivision, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by subdivision"""
  mls_num: FindOperatorDto

  """Property type of the processed search by subdivision"""
  property_type: FindOperatorDto

  """Subdivision of the processed search by subdivision"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by subdivision."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchBySubdivisionDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type ProcessedSearchBySubdivisionEntity {
  """Unique ID of the processed search by subdivision, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by subdivision"""
  mls_num: String

  """Property type of the processed search by subdivision"""
  property_type: String

  """Subdivision of the processed search by subdivision"""
  subdivision: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by subdivision."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input ProcessedSearchBySubdivisionFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchBySubdivisionFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ProcessedSearchBySubdivisionFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ProcessedSearchBySubdivisionFindInputSortOrder
}

input ProcessedSearchBySubdivisionFindInputGroupBy {
  mlsp_id: Boolean
  mls_num: Boolean
  property_type: Boolean
  subdivision: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ProcessedSearchBySubdivisionFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  property_type: RecordSortDirectionEnum
  subdivision: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ProcessedSearchBySubdivisionFindInputWhere {
  """Unique ID of the processed search by subdivision, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by subdivision"""
  mls_num: FindOperatorDto

  """Property type of the processed search by subdivision"""
  property_type: FindOperatorDto

  """Subdivision of the processed search by subdivision"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by subdivision."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input ProcessedSearchBySubdivisionFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type ProcessedSearchBySubdivisionFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ProcessedSearchBySubdivisionEntity!]!
}

input ProcessedSearchBySubdivisionRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchBySubdivisionRecoverInputWhere!]
}

input ProcessedSearchBySubdivisionRecoverInputWhere {
  """Unique ID of the processed search by subdivision, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by subdivision"""
  mls_num: FindOperatorDto

  """Property type of the processed search by subdivision"""
  property_type: FindOperatorDto

  """Subdivision of the processed search by subdivision"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by subdivision."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchBySubdivisionRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchBySubdivisionEntity!]!
}

input ProcessedSearchBySubdivisionRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchBySubdivisionRemoveInputWhere!]
}

input ProcessedSearchBySubdivisionRemoveInputWhere {
  """Unique ID of the processed search by subdivision, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by subdivision"""
  mls_num: FindOperatorDto

  """Property type of the processed search by subdivision"""
  property_type: FindOperatorDto

  """Subdivision of the processed search by subdivision"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by subdivision."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchBySubdivisionRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchBySubdivisionEntity!]!
}

input ProcessedSearchBySubdivisionRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchBySubdivisionRestoreInputWhere!]
}

input ProcessedSearchBySubdivisionRestoreInputWhere {
  """Unique ID of the processed search by subdivision, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by subdivision"""
  mls_num: FindOperatorDto

  """Property type of the processed search by subdivision"""
  property_type: FindOperatorDto

  """Subdivision of the processed search by subdivision"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by subdivision."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchBySubdivisionRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchBySubdivisionSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchBySubdivisionSoftDeleteInputWhere!]
}

input ProcessedSearchBySubdivisionSoftDeleteInputWhere {
  """Unique ID of the processed search by subdivision, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by subdivision"""
  mls_num: FindOperatorDto

  """Property type of the processed search by subdivision"""
  property_type: FindOperatorDto

  """Subdivision of the processed search by subdivision"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by subdivision."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchBySubdivisionSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchBySubdivisionSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchBySubdivisionSoftRemoveInputWhere!]
}

input ProcessedSearchBySubdivisionSoftRemoveInputWhere {
  """Unique ID of the processed search by subdivision, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by subdivision"""
  mls_num: FindOperatorDto

  """Property type of the processed search by subdivision"""
  property_type: FindOperatorDto

  """Subdivision of the processed search by subdivision"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by subdivision."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchBySubdivisionSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchBySubdivisionEntity!]!
}

input ProcessedSearchBySubdivisionUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchBySubdivisionUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ProcessedSearchBySubdivisionUpdateInputSets!
}

input ProcessedSearchBySubdivisionUpdateInputSets {
  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by subdivision"""
  mls_num: String

  """Property type of the processed search by subdivision"""
  property_type: String

  """Subdivision of the processed search by subdivision"""
  subdivision: String
}

input ProcessedSearchBySubdivisionUpdateInputWhere {
  """Unique ID of the processed search by subdivision, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by subdivision"""
  mls_num: FindOperatorDto

  """Property type of the processed search by subdivision"""
  property_type: FindOperatorDto

  """Subdivision of the processed search by subdivision"""
  subdivision: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by subdivision."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchBySubdivisionUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ProcessedSearchBySubdivisionEntity!]!
}

input ProcessedSearchBySubdivisionUpsertInput {
  """MLSP ID"""
  mlsp_id: Int!

  """Mls num of the processed search by subdivision"""
  mls_num: String!

  """Property type of the processed search by subdivision"""
  property_type: String!

  """Subdivision of the processed search by subdivision"""
  subdivision: String!

  """
  Unique ID of the processed search by subdivision, auto generated. undefined
  """
  id: Int
}

type ProcessedSearchBySubdivisionUpsertOutput {
  """Unique ID of the processed search by subdivision, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by subdivision"""
  mls_num: String

  """Property type of the processed search by subdivision"""
  property_type: String

  """Subdivision of the processed search by subdivision"""
  subdivision: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by subdivision."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input ProcessedSearchByZipcodeCreateInput {
  """MLSP ID"""
  mlsp_id: Int!

  """Mls num of the processed search by zipcode"""
  mls_num: String!

  """Property type of the processed search by zipcode"""
  property_type: String!

  """zipcode of the processed search by zipcode"""
  zipcode: String!
}

type ProcessedSearchByZipcodeCreateOutput {
  """Unique ID of the processed search by zipcode, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by zipcode"""
  mls_num: String

  """Property type of the processed search by zipcode"""
  property_type: String

  """zipcode of the processed search by zipcode"""
  zipcode: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by zipcode."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input ProcessedSearchByZipcodeDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByZipcodeDeleteInputWhere!]
}

input ProcessedSearchByZipcodeDeleteInputWhere {
  """Unique ID of the processed search by zipcode, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by zipcode"""
  mls_num: FindOperatorDto

  """Property type of the processed search by zipcode"""
  property_type: FindOperatorDto

  """zipcode of the processed search by zipcode"""
  zipcode: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by zipcode."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByZipcodeDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type ProcessedSearchByZipcodeEntity {
  """Unique ID of the processed search by zipcode, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by zipcode"""
  mls_num: String

  """Property type of the processed search by zipcode"""
  property_type: String

  """zipcode of the processed search by zipcode"""
  zipcode: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by zipcode."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input ProcessedSearchByZipcodeFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByZipcodeFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ProcessedSearchByZipcodeFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ProcessedSearchByZipcodeFindInputSortOrder
}

input ProcessedSearchByZipcodeFindInputGroupBy {
  mlsp_id: Boolean
  mls_num: Boolean
  property_type: Boolean
  zipcode: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ProcessedSearchByZipcodeFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  property_type: RecordSortDirectionEnum
  zipcode: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ProcessedSearchByZipcodeFindInputWhere {
  """Unique ID of the processed search by zipcode, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by zipcode"""
  mls_num: FindOperatorDto

  """Property type of the processed search by zipcode"""
  property_type: FindOperatorDto

  """zipcode of the processed search by zipcode"""
  zipcode: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by zipcode."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input ProcessedSearchByZipcodeFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type ProcessedSearchByZipcodeFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ProcessedSearchByZipcodeEntity!]!
}

input ProcessedSearchByZipcodeRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByZipcodeRecoverInputWhere!]
}

input ProcessedSearchByZipcodeRecoverInputWhere {
  """Unique ID of the processed search by zipcode, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by zipcode"""
  mls_num: FindOperatorDto

  """Property type of the processed search by zipcode"""
  property_type: FindOperatorDto

  """zipcode of the processed search by zipcode"""
  zipcode: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by zipcode."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByZipcodeRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByZipcodeEntity!]!
}

input ProcessedSearchByZipcodeRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByZipcodeRemoveInputWhere!]
}

input ProcessedSearchByZipcodeRemoveInputWhere {
  """Unique ID of the processed search by zipcode, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by zipcode"""
  mls_num: FindOperatorDto

  """Property type of the processed search by zipcode"""
  property_type: FindOperatorDto

  """zipcode of the processed search by zipcode"""
  zipcode: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by zipcode."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByZipcodeRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByZipcodeEntity!]!
}

input ProcessedSearchByZipcodeRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByZipcodeRestoreInputWhere!]
}

input ProcessedSearchByZipcodeRestoreInputWhere {
  """Unique ID of the processed search by zipcode, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by zipcode"""
  mls_num: FindOperatorDto

  """Property type of the processed search by zipcode"""
  property_type: FindOperatorDto

  """zipcode of the processed search by zipcode"""
  zipcode: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by zipcode."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByZipcodeRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByZipcodeSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByZipcodeSoftDeleteInputWhere!]
}

input ProcessedSearchByZipcodeSoftDeleteInputWhere {
  """Unique ID of the processed search by zipcode, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by zipcode"""
  mls_num: FindOperatorDto

  """Property type of the processed search by zipcode"""
  property_type: FindOperatorDto

  """zipcode of the processed search by zipcode"""
  zipcode: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by zipcode."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByZipcodeSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ProcessedSearchByZipcodeSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByZipcodeSoftRemoveInputWhere!]
}

input ProcessedSearchByZipcodeSoftRemoveInputWhere {
  """Unique ID of the processed search by zipcode, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by zipcode"""
  mls_num: FindOperatorDto

  """Property type of the processed search by zipcode"""
  property_type: FindOperatorDto

  """zipcode of the processed search by zipcode"""
  zipcode: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by zipcode."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByZipcodeSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ProcessedSearchByZipcodeEntity!]!
}

input ProcessedSearchByZipcodeUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ProcessedSearchByZipcodeUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ProcessedSearchByZipcodeUpdateInputSets!
}

input ProcessedSearchByZipcodeUpdateInputSets {
  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by zipcode"""
  mls_num: String

  """Property type of the processed search by zipcode"""
  property_type: String

  """zipcode of the processed search by zipcode"""
  zipcode: String
}

input ProcessedSearchByZipcodeUpdateInputWhere {
  """Unique ID of the processed search by zipcode, auto generated."""
  id: FindOperatorDto

  """MLSP ID"""
  mlsp_id: FindOperatorDto

  """Mls num of the processed search by zipcode"""
  mls_num: FindOperatorDto

  """Property type of the processed search by zipcode"""
  property_type: FindOperatorDto

  """zipcode of the processed search by zipcode"""
  zipcode: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the processed search by zipcode."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type ProcessedSearchByZipcodeUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ProcessedSearchByZipcodeEntity!]!
}

input ProcessedSearchByZipcodeUpsertInput {
  """MLSP ID"""
  mlsp_id: Int!

  """Mls num of the processed search by zipcode"""
  mls_num: String!

  """Property type of the processed search by zipcode"""
  property_type: String!

  """zipcode of the processed search by zipcode"""
  zipcode: String!

  """
  Unique ID of the processed search by zipcode, auto generated. undefined
  """
  id: Int
}

type ProcessedSearchByZipcodeUpsertOutput {
  """Unique ID of the processed search by zipcode, auto generated."""
  id: Int

  """MLSP ID"""
  mlsp_id: Int

  """Mls num of the processed search by zipcode"""
  mls_num: String

  """Property type of the processed search by zipcode"""
  property_type: String

  """zipcode of the processed search by zipcode"""
  zipcode: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the processed search by zipcode."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

type Query {
  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsListingOpenHouseFind(filter: RetsListingOpenHouseFindInput!): RetsListingOpenHouseFindOutput!

  """RetsListingOpenHouseFindOneById"""
  RetsListingOpenHouseFindOneById(input: RetsListingOpenHouseFindOneByIdInput!): RetsListingOpenHouseEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsListingFind(filter: RetsListingFindInput!): RetsListingFindOutput!

  """RetsListingFindOneById"""
  RetsListingFindOneById(input: RetsListingFindOneByIdInput!): RetsListingEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsListingAdditionalInfoFind(filter: RetsListingAdditionalInfoFindInput!): RetsListingAdditionalInfoFindOutput!

  """RetsListingAdditionalInfoFindOneById"""
  RetsListingAdditionalInfoFindOneById(input: RetsListingAdditionalInfoFindOneByIdInput!): RetsListingAdditionalInfoEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsListingAgentFind(filter: RetsListingAgentFindInput!): RetsListingAgentFindOutput!

  """RetsListingAgentFindOneById"""
  RetsListingAgentFindOneById(input: RetsListingAgentFindOneByIdInput!): RetsListingAgentEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsListingOfficeFind(filter: RetsListingOfficeFindInput!): RetsListingOfficeFindOutput!

  """RetsListingOfficeFindOneById"""
  RetsListingOfficeFindOneById(input: RetsListingOfficeFindOneByIdInput!): RetsListingOfficeEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsListingPhotosFind(filter: RetsListingPhotosFindInput!): RetsListingPhotosFindOutput!

  """RetsListingPhotosFindOneById"""
  RetsListingPhotosFindOneById(input: RetsListingPhotosFindOneByIdInput!): RetsListingPhotosEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsListingMetadataFind(filter: RetsListingMetadataFindInput!): RetsListingMetadataFindOutput!

  """RetsListingMetadataFindOneById"""
  RetsListingMetadataFindOneById(input: RetsListingMetadataFindOneByIdInput!): RetsListingMetadataEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsListingRoomFind(filter: RetsListingRoomFindInput!): RetsListingRoomFindOutput!

  """RetsListingRoomFindOneById"""
  RetsListingRoomFindOneById(input: RetsListingRoomFindOneByIdInput!): RetsListingRoomEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsListingUnitFind(filter: RetsListingUnitFindInput!): RetsListingUnitFindOutput!

  """RetsListingUnitFindOneById"""
  RetsListingUnitFindOneById(input: RetsListingUnitFindOneByIdInput!): RetsListingUnitEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsListingVirtualToursFind(filter: RetsListingVirtualToursFindInput!): RetsListingVirtualToursFindOutput!

  """RetsListingVirtualToursFindOneById"""
  RetsListingVirtualToursFindOneById(input: RetsListingVirtualToursFindOneByIdInput!): RetsListingVirtualToursEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsMlsProviderFind(filter: RetsMlsProviderFindInput!): RetsMlsProviderFindOutput!

  """RetsMlsProviderFindOneById"""
  RetsMlsProviderFindOneById(input: RetsMlsProviderFindOneByIdInput!): RetsMlsProviderEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RetsMlsProviderConfigFind(filter: RetsMlsProviderConfigFindInput!): RetsMlsProviderConfigFindOutput!

  """RetsMlsProviderConfigFindOneById"""
  RetsMlsProviderConfigFindOneById(input: RetsMlsProviderConfigFindOneByIdInput!): RetsMlsProviderConfigEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserFavouritePropertyFind(filter: UserFavouritePropertyFindInput!): UserFavouritePropertyFindOutput!

  """UserFavouritePropertyFindOneById"""
  UserFavouritePropertyFindOneById(input: UserFavouritePropertyFindOneByIdInput!): UserFavouritePropertyEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserSavedSearchFind(filter: UserSavedSearchFindInput!): UserSavedSearchFindOutput!

  """UserSavedSearchFindOneById"""
  UserSavedSearchFindOneById(input: UserSavedSearchFindOneByIdInput!): UserSavedSearchEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ProcessedSearchByAddressFind(filter: ProcessedSearchByAddressFindInput!): ProcessedSearchByAddressFindOutput!

  """ProcessedSearchByAddressFindOneById"""
  ProcessedSearchByAddressFindOneById(input: ProcessedSearchByAddressFindOneByIdInput!): ProcessedSearchByAddressEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ProcessedSearchByCityFind(filter: ProcessedSearchByCityFindInput!): ProcessedSearchByCityFindOutput!

  """ProcessedSearchByCityFindOneById"""
  ProcessedSearchByCityFindOneById(input: ProcessedSearchByCityFindOneByIdInput!): ProcessedSearchByCityEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ProcessedSearchByCountyFind(filter: ProcessedSearchByCountyFindInput!): ProcessedSearchByCountyFindOutput!

  """ProcessedSearchByCountyFindOneById"""
  ProcessedSearchByCountyFindOneById(input: ProcessedSearchByCountyFindOneByIdInput!): ProcessedSearchByCountyEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ProcessedSearchByMapSearchFind(filter: ProcessedSearchByMapSearchFindInput!): ProcessedSearchByMapSearchFindOutput!

  """ProcessedSearchByMapSearchFindOneById"""
  ProcessedSearchByMapSearchFindOneById(input: ProcessedSearchByMapSearchFindOneByIdInput!): ProcessedSearchByMapSearchEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ProcessedSearchByMlsFind(filter: ProcessedSearchByMlsFindInput!): ProcessedSearchByMlsFindOutput!

  """ProcessedSearchByMlsFindOneById"""
  ProcessedSearchByMlsFindOneById(input: ProcessedSearchByMlsFindOneByIdInput!): ProcessedSearchByMlsEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ProcessedSearchByNeighbourhoodFind(filter: ProcessedSearchByNeighbourhoodFindInput!): ProcessedSearchByNeighbourhoodFindOutput!

  """ProcessedSearchByNeighbourhoodFindOneById"""
  ProcessedSearchByNeighbourhoodFindOneById(input: ProcessedSearchByNeighbourhoodFindOneByIdInput!): ProcessedSearchByNeighbourhoodEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ProcessedSearchBySubdivisionFind(filter: ProcessedSearchBySubdivisionFindInput!): ProcessedSearchBySubdivisionFindOutput!

  """ProcessedSearchBySubdivisionFindOneById"""
  ProcessedSearchBySubdivisionFindOneById(input: ProcessedSearchBySubdivisionFindOneByIdInput!): ProcessedSearchBySubdivisionEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ProcessedSearchByZipcodeFind(filter: ProcessedSearchByZipcodeFindInput!): ProcessedSearchByZipcodeFindOutput!

  """ProcessedSearchByZipcodeFindOneById"""
  ProcessedSearchByZipcodeFindOneById(input: ProcessedSearchByZipcodeFindOneByIdInput!): ProcessedSearchByZipcodeEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ApiEndpointAuthFind(filter: ApiEndpointAuthFindInput!): ApiEndpointAuthFindOutput!

  """ApiEndpointAuthFindOneById"""
  ApiEndpointAuthFindOneById(input: ApiEndpointAuthFindOneByIdInput!): ApiEndpointAuthFindOutputRows!

  """Testing query"""
  HelloGraph: String!

  """Get the current user info using JWT access token."""
  GraphWhoAmI: GraphSignupOutput!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  RegionFind(filter: RegionFindInput!): RegionFindOutput!

  """RegionFindOneById"""
  RegionFindOneById(input: RegionFindOneByIdInput!): RegionEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  SubregionFind(filter: SubregionFindInput!): SubregionFindOutput!

  """SubregionFindOneById"""
  SubregionFindOneById(input: SubregionFindOneByIdInput!): SubregionEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  CountryFind(filter: CountryFindInput!): CountryFindOutput!

  """CountryFindOneById"""
  CountryFindOneById(input: CountryFindOneByIdInput!): CountryEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  StateFind(filter: StateFindInput!): StateFindOutput!

  """StateFindOneById"""
  StateFindOneById(input: StateFindOneByIdInput!): StateEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  CityFind(filter: CityFindInput!): CityFindOutput!

  """CityFindOneById"""
  CityFindOneById(input: CityFindOneByIdInput!): CityEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  LanguageFind(filter: LanguageFindInput!): LanguageFindOutput!

  """LanguageFindOneById"""
  LanguageFindOneById(input: LanguageFindOneByIdInput!): LanguageEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  CountryLanguageFind(filter: CountryLanguageFindInput!): CountryLanguageFindOutput!

  """CountryLanguageFindOneById"""
  CountryLanguageFindOneById(input: CountryLanguageFindOneByIdInput!): CountryLanguageEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  TimezoneFind(filter: TimezoneFindInput!): TimezoneFindOutput!

  """TimezoneFindOneById"""
  TimezoneFindOneById(input: TimezoneFindOneByIdInput!): TimezoneEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  CountryTimezoneFind(filter: CountryTimezoneFindInput!): CountryTimezoneFindOutput!

  """CountryTimezoneFindOneById"""
  CountryTimezoneFindOneById(input: CountryTimezoneFindOneByIdInput!): CountryTimezoneEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ThirdPartyPlatformFind(filter: ThirdPartyPlatformFindInput!): ThirdPartyPlatformFindOutput!

  """ThirdPartyPlatformFindOneById"""
  ThirdPartyPlatformFindOneById(input: ThirdPartyPlatformFindOneByIdInput!): ThirdPartyPlatformEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  AuthorisationFind(filter: AuthorisationFindInput!): AuthorisationFindOutput!

  """AuthorisationFindOneById"""
  AuthorisationFindOneById(input: AuthorisationFindOneByIdInput!): AuthorisationEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  DeviceFind(filter: DeviceFindInput!): DeviceFindOutput!

  """DeviceFindOneById"""
  DeviceFindOneById(input: DeviceFindOneByIdInput!): DeviceEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  IdentityCardTypeFind(filter: IdentityCardTypeFindInput!): IdentityCardTypeFindOutput!

  """IdentityCardTypeFindOneById"""
  IdentityCardTypeFindOneById(input: IdentityCardTypeFindOneByIdInput!): IdentityCardTypeEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  FormFieldFind(filter: FormFieldFindInput!): FormFieldFindOutput!

  """FormFieldFindOneById"""
  FormFieldFindOneById(input: FormFieldFindOneByIdInput!): FormFieldEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  AlertDurationFind(filter: AlertDurationFindInput!): AlertDurationFindOutput!

  """AlertDurationFindOneById"""
  AlertDurationFindOneById(input: AlertDurationFindOneByIdInput!): AlertDurationEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  WorkStatusFind(filter: WorkStatusFindInput!): WorkStatusFindOutput!

  """WorkStatusFindOneById"""
  WorkStatusFindOneById(input: WorkStatusFindOneByIdInput!): WorkStatusEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  SettingTypeFind(filter: SettingTypeFindInput!): SettingTypeFindOutput!

  """SettingTypeFindOneById"""
  SettingTypeFindOneById(input: SettingTypeFindOneByIdInput!): SettingTypeEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  SettingCategoryFind(filter: SettingCategoryFindInput!): SettingCategoryFindOutput!

  """SettingCategoryFindOneById"""
  SettingCategoryFindOneById(input: SettingCategoryFindOneByIdInput!): SettingCategoryEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  StaticDataFind(filter: StaticDataFindInput!): StaticDataFindOutput!

  """StaticDataFindOneById"""
  StaticDataFindOneById(input: StaticDataFindOneByIdInput!): StaticDataEntity!

  """Static data json object used in various settings."""
  StaticDataJson: JSON!

  """Static data json object used in various settings from local storage."""
  StaticDataJsonFromLocalStorage: JSON!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  StaticDataValueFind(filter: StaticDataValueFindInput!): StaticDataValueFindOutput!

  """StaticDataValueFindOneById"""
  StaticDataValueFindOneById(input: StaticDataValueFindOneByIdInput!): StaticDataValueEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  SettingPreferenceFind(filter: SettingPreferenceFindInput!): SettingPreferenceFindOutput!

  """SettingPreferenceFindOneById"""
  SettingPreferenceFindOneById(input: SettingPreferenceFindOneByIdInput!): SettingPreferenceEntity!

  """Setting preference json object used to get various dynamic settings"""
  SettingPreferenceJson(input: SettingPreferenceJsonInput!): JSON!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  SettingFind(filter: SettingFindInput!): SettingFindOutput!

  """SettingFindOneById"""
  SettingFindOneById(input: SettingFindOneByIdInput!): SettingEntity!

  """Setting  json object used to get availabe dynamic settings."""
  SettingJson(input: SettingJsonInput!): JSON!

  """
  Setting json object used to get availabe dynamic settings from local storage.
  """
  SettingJsonFromLocalStorage(input: SettingJsonInput!): JSON!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserFind(filter: UserFindInput!): UserFindOutput!

  """UserFindOneById"""
  UserFindOneById(input: UserFindOneByIdInput!): UserEntity!

  """Get the current user info fron session."""
  AppWhoAmI: AppSigninOutput!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserAuthenticationFind(filter: UserAuthenticationFindInput!): UserAuthenticationFindOutput!

  """UserAuthenticationFindOneById"""
  UserAuthenticationFindOneById(input: UserAuthenticationFindOneByIdInput!): UserAuthenticationFindOutputRows!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  QueueTypeFind(filter: QueueTypeFindInput!): QueueTypeFindOutput!

  """QueueTypeFindOneById"""
  QueueTypeFindOneById(input: QueueTypeFindOneByIdInput!): QueueTypeEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  QueueSmsFind(filter: QueueSmsFindInput!): QueueSmsFindOutput!

  """QueueSmsFindOneById"""
  QueueSmsFindOneById(input: QueueSmsFindOneByIdInput!): QueueSmsEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  QueueEmailFind(filter: QueueEmailFindInput!): QueueEmailFindOutput!

  """QueueEmailFindOneById"""
  QueueEmailFindOneById(input: QueueEmailFindOneByIdInput!): QueueEmailEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  QueueWhatsappFind(filter: QueueWhatsappFindInput!): QueueWhatsappFindOutput!

  """QueueWhatsappFindOneById"""
  QueueWhatsappFindOneById(input: QueueWhatsappFindOneByIdInput!): QueueWhatsappEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  EmailTemplateFind(filter: EmailTemplateFindInput!): EmailTemplateFindOutput!

  """EmailTemplateFindOneById"""
  EmailTemplateFindOneById(input: EmailTemplateFindOneByIdInput!): EmailTemplateEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  EmailTemplateCategoryFind(filter: EmailTemplateCategoryFindInput!): EmailTemplateCategoryFindOutput!

  """EmailTemplateCategoryFindOneById"""
  EmailTemplateCategoryFindOneById(input: EmailTemplateCategoryFindOneByIdInput!): EmailTemplateCategoryEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  SessionFind(filter: SessionFindInput!): SessionFindOutput!

  """SessionFindOneById"""
  SessionFindOneById(input: SessionFindOneByIdInput!): SessionEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  SessionMetaFind(filter: SessionMetaFindInput!): SessionMetaFindOutput!

  """SessionMetaFindOneById"""
  SessionMetaFindOneById(input: SessionMetaFindOneByIdInput!): SessionMetaEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserAuthorisationFind(filter: UserAuthorisationFindInput!): UserAuthorisationFindOutput!

  """UserAuthorisationFindOneById"""
  UserAuthorisationFindOneById(input: UserAuthorisationFindOneByIdInput!): UserAuthorisationEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserDeviceFind(filter: UserDeviceFindInput!): UserDeviceFindOutput!

  """UserDeviceFindOneById"""
  UserDeviceFindOneById(input: UserDeviceFindOneByIdInput!): UserDeviceEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserCorporateInfoFind(filter: UserCorporateInfoFindInput!): UserCorporateInfoFindOutput!

  """UserCorporateInfoFindOneById"""
  UserCorporateInfoFindOneById(input: UserCorporateInfoFindOneByIdInput!): UserCorporateInfoEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserPersonalInfoFind(filter: UserPersonalInfoFindInput!): UserPersonalInfoFindOutput!

  """UserPersonalInfoFindOneById"""
  UserPersonalInfoFindOneById(input: UserPersonalInfoFindOneByIdInput!): UserPersonalInfoEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserAddressFind(filter: UserAddressFindInput!): UserAddressFindOutput!

  """UserAddressFindOneById"""
  UserAddressFindOneById(input: UserAddressFindOneByIdInput!): UserAddressEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserIdentityCardFind(filter: UserIdentityCardFindInput!): UserIdentityCardFindOutput!

  """UserIdentityCardFindOneById"""
  UserIdentityCardFindOneById(input: UserIdentityCardFindOneByIdInput!): UserIdentityCardEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserHierarchyFind(filter: UserHierarchyFindInput!): UserHierarchyFindOutput!

  """UserHierarchyFindOneById"""
  UserHierarchyFindOneById(input: UserHierarchyFindOneByIdInput!): UserHierarchyEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserFileFind(filter: UserFileFindInput!): UserFileFindOutput!

  """UserFileFindOneById"""
  UserFileFindOneById(input: UserFileFindOneByIdInput!): UserFileEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserFavFind(filter: UserFavFindInput!): UserFavFindOutput!

  """UserFavFindOneById"""
  UserFavFindOneById(input: UserFavFindOneByIdInput!): UserFavEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserFavCategoryFind(filter: UserFavCategoryFindInput!): UserFavCategoryFindOutput!

  """UserFavCategoryFindOneById"""
  UserFavCategoryFindOneById(input: UserFavCategoryFindOneByIdInput!): UserFavCategoryEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  AcademicFieldFind(filter: AcademicFieldFindInput!): AcademicFieldFindOutput!

  """AcademicFieldFindOneById"""
  AcademicFieldFindOneById(input: AcademicFieldFindOneByIdInput!): AcademicFieldEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  AcademicDegreeFind(filter: AcademicDegreeFindInput!): AcademicDegreeFindOutput!

  """AcademicDegreeFindOneById"""
  AcademicDegreeFindOneById(input: AcademicDegreeFindOneByIdInput!): AcademicDegreeEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  WebhookResponseFind(filter: WebhookResponseFindInput!): WebhookResponseFindOutput!

  """WebhookResponseFindOneById"""
  WebhookResponseFindOneById(input: WebhookResponseFindOneByIdInput!): WebhookResponseEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  WebhookResponseDataFind(filter: WebhookResponseDataFindInput!): WebhookResponseDataFindOutput!

  """WebhookResponseDataFindOneById"""
  WebhookResponseDataFindOneById(input: WebhookResponseDataFindOneByIdInput!): WebhookResponseDataEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  LeadFind(filter: LeadFindInput!): LeadFindOutput!

  """LeadFindOneById"""
  LeadFindOneById(input: LeadFindOneByIdInput!): LeadEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ConnectionSourceFind(filter: ConnectionSourceFindInput!): ConnectionSourceFindOutput!

  """ConnectionSourceFindOneById"""
  ConnectionSourceFindOneById(input: ConnectionSourceFindOneByIdInput!): ConnectionSourceEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  ConnectionSourceCategoriesFind(filter: ConnectionSourceCategoriesFindInput!): ConnectionSourceCategoriesFindOutput!

  """ConnectionSourceCategoriesFindOneById"""
  ConnectionSourceCategoriesFindOneById(input: ConnectionSourceCategoriesFindOneByIdInput!): ConnectionSourceCategoriesEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  LeadFollowupFind(filter: LeadFollowupFindInput!): LeadFollowupFindOutput!

  """LeadFollowupFindOneById"""
  LeadFollowupFindOneById(input: LeadFollowupFindOneByIdInput!): LeadFollowupEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  LeadFollowupStatusFind(filter: LeadFollowupStatusFindInput!): LeadFollowupStatusFindOutput!

  """LeadFollowupStatusFindOneById"""
  LeadFollowupStatusFindOneById(input: LeadFollowupStatusFindOneByIdInput!): LeadFollowupStatusEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  LeadFollowupViaFind(filter: LeadFollowupViaFindInput!): LeadFollowupViaFindOutput!

  """LeadFollowupViaFindOneById"""
  LeadFollowupViaFindOneById(input: LeadFollowupViaFindOneByIdInput!): LeadFollowupViaEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  LeadPotentialFind(filter: LeadPotentialFindInput!): LeadPotentialFindOutput!

  """LeadPotentialFindOneById"""
  LeadPotentialFindOneById(input: LeadPotentialFindOneByIdInput!): LeadPotentialEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  WebPageMasterFind(filter: WebPageMasterFindInput!): WebPageMasterFindOutput!

  """WebPageMasterFindOneById"""
  WebPageMasterFindOneById(input: WebPageMasterFindOneByIdInput!): WebPageMasterEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  WebPageHierarchyFind(filter: WebPageHierarchyFindInput!): WebPageHierarchyFindOutput!

  """WebPageHierarchyFindOneById"""
  WebPageHierarchyFindOneById(input: WebPageHierarchyFindOneByIdInput!): WebPageHierarchyEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  NewsLetterFind(filter: NewsLetterFindInput!): NewsLetterFindOutput!

  """NewsLetterFindOneById"""
  NewsLetterFindOneById(input: NewsLetterFindOneByIdInput!): NewsLetterEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  NewsLetterScheduleFind(filter: NewsLetterScheduleFindInput!): NewsLetterScheduleFindOutput!

  """NewsLetterScheduleFindOneById"""
  NewsLetterScheduleFindOneById(input: NewsLetterScheduleFindOneByIdInput!): NewsLetterScheduleEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  NewsLetterTrackLogFind(filter: NewsLetterTrackLogFindInput!): NewsLetterTrackLogFindOutput!

  """NewsLetterTrackLogFindOneById"""
  NewsLetterTrackLogFindOneById(input: NewsLetterTrackLogFindOneByIdInput!): NewsLetterTrackLogEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  NewsLetterUserFind(filter: NewsLetterUserFindInput!): NewsLetterUserFindOutput!

  """NewsLetterUserFindOneById"""
  NewsLetterUserFindOneById(input: NewsLetterUserFindOneByIdInput!): NewsLetterUserEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  NewsLetterCategoryFind(filter: NewsLetterCategoryFindInput!): NewsLetterCategoryFindOutput!

  """NewsLetterCategoryFindOneById"""
  NewsLetterCategoryFindOneById(input: NewsLetterCategoryFindOneByIdInput!): NewsLetterCategoryEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  UserNewsLetterSubscriptionFind(filter: UserNewsLetterSubscriptionFindInput!): UserNewsLetterSubscriptionFindOutput!

  """UserNewsLetterSubscriptionFindOneById"""
  UserNewsLetterSubscriptionFindOneById(input: UserNewsLetterSubscriptionFindOneByIdInput!): UserNewsLetterSubscriptionEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  FaqFind(filter: FaqFindInput!): FaqFindOutput!

  """FaqFindOneById"""
  FaqFindOneById(input: FaqFindOneByIdInput!): FaqEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  FaqCategoryFind(filter: FaqCategoryFindInput!): FaqCategoryFindOutput!

  """FaqCategoryFindOneById"""
  FaqCategoryFindOneById(input: FaqCategoryFindOneByIdInput!): FaqCategoryEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  MeasurementUnitFind(filter: MeasurementUnitFindInput!): MeasurementUnitFindOutput!

  """MeasurementUnitFindOneById"""
  MeasurementUnitFindOneById(input: MeasurementUnitFindOneByIdInput!): MeasurementUnitEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  MeasurementCategoryFind(filter: MeasurementCategoryFindInput!): MeasurementCategoryFindOutput!

  """MeasurementCategoryFindOneById"""
  MeasurementCategoryFindOneById(input: MeasurementCategoryFindOneByIdInput!): MeasurementCategoryEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  BusinessPrimaryCategoryFind(filter: BusinessPrimaryCategoryFindInput!): BusinessPrimaryCategoryFindOutput!

  """BusinessPrimaryCategoryFindOneById"""
  BusinessPrimaryCategoryFindOneById(input: BusinessPrimaryCategoryFindOneByIdInput!): BusinessPrimaryCategoryEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  BusinessSecondaryCategoryFind(filter: BusinessSecondaryCategoryFindInput!): BusinessSecondaryCategoryFindOutput!

  """BusinessSecondaryCategoryFindOneById"""
  BusinessSecondaryCategoryFindOneById(input: BusinessSecondaryCategoryFindOneByIdInput!): BusinessSecondaryCategoryEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  BusinessFind(filter: BusinessFindInput!): BusinessFindOutput!

  """BusinessFindOneById"""
  BusinessFindOneById(input: BusinessFindOneByIdInput!): BusinessEntity!

  """
  Start finding records in entity. This is easy, quick and simple way for majority of search operation.
  """
  CrawlerLeadFind(filter: CrawlerLeadFindInput!): CrawlerLeadFindOutput!

  """CrawlerLeadFindOneById"""
  CrawlerLeadFindOneById(input: CrawlerLeadFindOneByIdInput!): CrawlerLeadEntity!
}

input QueueEmailCreateInput {
  """Reference ID of the queueemail."""
  ref_id: String!

  """Reference type of the queueemail."""
  ref_type: String!

  """Queue type ID of the queueemail."""
  quetype_id: Int!

  """From user ID of the queueemail."""
  from_u_id: Int

  """To user ID of the queueemail."""
  to_u_id: Int

  """Who response ID of the queueemail."""
  whresp_id: Int

  """User Id of the queueemail added by."""
  created_u_id: Int

  """Authorisation role id of the user."""
  created_ar_id: Int

  """From email of the queueemail."""
  from_email: String

  """To email of the queueemail."""
  to_email: String

  """CC email of the queueemail."""
  cc: String

  """CC Other email of the queueemail."""
  ccother: String

  """BCC email of the queueemail."""
  bcc: String

  """Subject of the queueemail."""
  subject: String

  """Body of the queueemail."""
  body: String

  """Whether the queueemail is sent or not."""
  sent: DateTime

  """Raw json data of the queue process."""
  raw_data: JSON
}

type QueueEmailCreateOutput {
  """Unique ID of the queueemail, auto generated."""
  id: Int

  """From user ID of the queueemail."""
  from_u_id: Int

  """To user ID of the queueemail."""
  to_u_id: Int

  """Queue type ID of the queueemail."""
  quetype_id: Int

  """Who response ID of the queueemail."""
  whresp_id: Int

  """Reference ID of the queueemail."""
  ref_id: String

  """Reference type of the queueemail."""
  ref_type: String

  """User Id of the queueemail added by."""
  created_u_id: Int

  """Authorisation role id of the user."""
  created_ar_id: Int

  """From email of the queueemail."""
  from_email: String

  """To email of the queueemail."""
  to_email: String

  """CC email of the queueemail."""
  cc: String

  """CC Other email of the queueemail."""
  ccother: String

  """BCC email of the queueemail."""
  bcc: String

  """Subject of the queueemail."""
  subject: String

  """Body of the queueemail."""
  body: String

  """Raw json data of the queue process."""
  raw_data: JSON

  """Whether the queueemail is sent or not."""
  sent: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the queueemail"""
  fr_from_user: UserEntity

  """To user of the queueemail"""
  fr_to_user: UserEntity

  """Queue type of the queueemail"""
  fr_queue_type: QueueTypeEntity

  """User id of the queueemail added by"""
  fr_created_user: UserEntity
}

input QueueEmailDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueEmailDeleteInputWhere!]
}

input QueueEmailDeleteInputWhere {
  """Unique ID of the queueemail, auto generated."""
  id: FindOperatorDto

  """From user ID of the queueemail."""
  from_u_id: FindOperatorDto

  """To user ID of the queueemail."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queueemail."""
  quetype_id: FindOperatorDto

  """Who response ID of the queueemail."""
  whresp_id: FindOperatorDto

  """Reference ID of the queueemail."""
  ref_id: FindOperatorDto

  """Reference type of the queueemail."""
  ref_type: FindOperatorDto

  """User Id of the queueemail added by."""
  created_u_id: FindOperatorDto

  """Authorisation role id of the user."""
  created_ar_id: FindOperatorDto

  """From email of the queueemail."""
  from_email: FindOperatorDto

  """To email of the queueemail."""
  to_email: FindOperatorDto

  """Subject of the queueemail."""
  subject: FindOperatorDto

  """Whether the queueemail is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queueemail"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queueemail"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queueemail"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type QueueEmailDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type QueueEmailEntity {
  """Unique ID of the queueemail, auto generated."""
  id: Int

  """From user ID of the queueemail."""
  from_u_id: Int

  """To user ID of the queueemail."""
  to_u_id: Int

  """Queue type ID of the queueemail."""
  quetype_id: Int

  """Who response ID of the queueemail."""
  whresp_id: Int

  """Reference ID of the queueemail."""
  ref_id: String

  """Reference type of the queueemail."""
  ref_type: String

  """User Id of the queueemail added by."""
  created_u_id: Int

  """Authorisation role id of the user."""
  created_ar_id: Int

  """From email of the queueemail."""
  from_email: String

  """To email of the queueemail."""
  to_email: String

  """CC email of the queueemail."""
  cc: String

  """CC Other email of the queueemail."""
  ccother: String

  """BCC email of the queueemail."""
  bcc: String

  """Subject of the queueemail."""
  subject: String

  """Body of the queueemail."""
  body: String

  """Raw json data of the queue process."""
  raw_data: JSON

  """Whether the queueemail is sent or not."""
  sent: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the queueemail"""
  fr_from_user: UserEntity

  """To user of the queueemail"""
  fr_to_user: UserEntity

  """Queue type of the queueemail"""
  fr_queue_type: QueueTypeEntity

  """User id of the queueemail added by"""
  fr_created_user: UserEntity
}

input QueueEmailFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueEmailFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: QueueEmailFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: QueueEmailFindInputSortOrder
}

input QueueEmailFindInputGroupBy {
  from_u_id: Boolean
  to_u_id: Boolean
  quetype_id: Boolean
  ref_id: Boolean
  ref_type: Boolean
  from_email: Boolean
  to_email: Boolean
  created_u_id: Boolean
  created_ar_id: Boolean
  sent: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input QueueEmailFindInputSortOrder {
  id: RecordSortDirectionEnum
  from_u_id: RecordSortDirectionEnum
  to_u_id: RecordSortDirectionEnum
  quetype_id: RecordSortDirectionEnum
  created_u_id: RecordSortDirectionEnum
  created_ar_id: RecordSortDirectionEnum
  from_email: RecordSortDirectionEnum
  to_email: RecordSortDirectionEnum
  subject: RecordSortDirectionEnum
  sent: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input QueueEmailFindInputWhere {
  """Unique ID of the queueemail, auto generated."""
  id: FindOperatorDto

  """From user ID of the queueemail."""
  from_u_id: FindOperatorDto

  """To user ID of the queueemail."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queueemail."""
  quetype_id: FindOperatorDto

  """Who response ID of the queueemail."""
  whresp_id: FindOperatorDto

  """Reference ID of the queueemail."""
  ref_id: FindOperatorDto

  """Reference type of the queueemail."""
  ref_type: FindOperatorDto

  """User Id of the queueemail added by."""
  created_u_id: FindOperatorDto

  """Authorisation role id of the user."""
  created_ar_id: FindOperatorDto

  """From email of the queueemail."""
  from_email: FindOperatorDto

  """To email of the queueemail."""
  to_email: FindOperatorDto

  """Subject of the queueemail."""
  subject: FindOperatorDto

  """Whether the queueemail is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queueemail"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queueemail"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queueemail"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

input QueueEmailFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type QueueEmailFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [QueueEmailEntity!]!
}

input QueueEmailRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueEmailRecoverInputWhere!]
}

input QueueEmailRecoverInputWhere {
  """Unique ID of the queueemail, auto generated."""
  id: FindOperatorDto

  """From user ID of the queueemail."""
  from_u_id: FindOperatorDto

  """To user ID of the queueemail."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queueemail."""
  quetype_id: FindOperatorDto

  """Who response ID of the queueemail."""
  whresp_id: FindOperatorDto

  """Reference ID of the queueemail."""
  ref_id: FindOperatorDto

  """Reference type of the queueemail."""
  ref_type: FindOperatorDto

  """User Id of the queueemail added by."""
  created_u_id: FindOperatorDto

  """Authorisation role id of the user."""
  created_ar_id: FindOperatorDto

  """From email of the queueemail."""
  from_email: FindOperatorDto

  """To email of the queueemail."""
  to_email: FindOperatorDto

  """Subject of the queueemail."""
  subject: FindOperatorDto

  """Whether the queueemail is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queueemail"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queueemail"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queueemail"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type QueueEmailRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueEmailEntity!]!
}

input QueueEmailRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueEmailRemoveInputWhere!]
}

input QueueEmailRemoveInputWhere {
  """Unique ID of the queueemail, auto generated."""
  id: FindOperatorDto

  """From user ID of the queueemail."""
  from_u_id: FindOperatorDto

  """To user ID of the queueemail."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queueemail."""
  quetype_id: FindOperatorDto

  """Who response ID of the queueemail."""
  whresp_id: FindOperatorDto

  """Reference ID of the queueemail."""
  ref_id: FindOperatorDto

  """Reference type of the queueemail."""
  ref_type: FindOperatorDto

  """User Id of the queueemail added by."""
  created_u_id: FindOperatorDto

  """Authorisation role id of the user."""
  created_ar_id: FindOperatorDto

  """From email of the queueemail."""
  from_email: FindOperatorDto

  """To email of the queueemail."""
  to_email: FindOperatorDto

  """Subject of the queueemail."""
  subject: FindOperatorDto

  """Whether the queueemail is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queueemail"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queueemail"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queueemail"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type QueueEmailRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueEmailEntity!]!
}

input QueueEmailRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueEmailRestoreInputWhere!]
}

input QueueEmailRestoreInputWhere {
  """Unique ID of the queueemail, auto generated."""
  id: FindOperatorDto

  """From user ID of the queueemail."""
  from_u_id: FindOperatorDto

  """To user ID of the queueemail."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queueemail."""
  quetype_id: FindOperatorDto

  """Who response ID of the queueemail."""
  whresp_id: FindOperatorDto

  """Reference ID of the queueemail."""
  ref_id: FindOperatorDto

  """Reference type of the queueemail."""
  ref_type: FindOperatorDto

  """User Id of the queueemail added by."""
  created_u_id: FindOperatorDto

  """Authorisation role id of the user."""
  created_ar_id: FindOperatorDto

  """From email of the queueemail."""
  from_email: FindOperatorDto

  """To email of the queueemail."""
  to_email: FindOperatorDto

  """Subject of the queueemail."""
  subject: FindOperatorDto

  """Whether the queueemail is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queueemail"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queueemail"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queueemail"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type QueueEmailRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input QueueEmailSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueEmailSoftDeleteInputWhere!]
}

input QueueEmailSoftDeleteInputWhere {
  """Unique ID of the queueemail, auto generated."""
  id: FindOperatorDto

  """From user ID of the queueemail."""
  from_u_id: FindOperatorDto

  """To user ID of the queueemail."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queueemail."""
  quetype_id: FindOperatorDto

  """Who response ID of the queueemail."""
  whresp_id: FindOperatorDto

  """Reference ID of the queueemail."""
  ref_id: FindOperatorDto

  """Reference type of the queueemail."""
  ref_type: FindOperatorDto

  """User Id of the queueemail added by."""
  created_u_id: FindOperatorDto

  """Authorisation role id of the user."""
  created_ar_id: FindOperatorDto

  """From email of the queueemail."""
  from_email: FindOperatorDto

  """To email of the queueemail."""
  to_email: FindOperatorDto

  """Subject of the queueemail."""
  subject: FindOperatorDto

  """Whether the queueemail is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queueemail"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queueemail"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queueemail"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type QueueEmailSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input QueueEmailSoftRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueEmailSoftRemoveInputWhere!]
}

input QueueEmailSoftRemoveInputWhere {
  """Unique ID of the queueemail, auto generated."""
  id: FindOperatorDto

  """From user ID of the queueemail."""
  from_u_id: FindOperatorDto

  """To user ID of the queueemail."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queueemail."""
  quetype_id: FindOperatorDto

  """Who response ID of the queueemail."""
  whresp_id: FindOperatorDto

  """Reference ID of the queueemail."""
  ref_id: FindOperatorDto

  """Reference type of the queueemail."""
  ref_type: FindOperatorDto

  """User Id of the queueemail added by."""
  created_u_id: FindOperatorDto

  """Authorisation role id of the user."""
  created_ar_id: FindOperatorDto

  """From email of the queueemail."""
  from_email: FindOperatorDto

  """To email of the queueemail."""
  to_email: FindOperatorDto

  """Subject of the queueemail."""
  subject: FindOperatorDto

  """Whether the queueemail is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queueemail"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queueemail"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queueemail"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type QueueEmailSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueEmailEntity!]!
}

input QueueEmailUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueEmailUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: QueueEmailUpdateInputSets!
}

input QueueEmailUpdateInputSets {
  """Reference ID of the queueemail."""
  ref_id: String

  """Reference type of the queueemail."""
  ref_type: String

  """Queue type ID of the queueemail."""
  quetype_id: Int

  """From user ID of the queueemail."""
  from_u_id: Int

  """To user ID of the queueemail."""
  to_u_id: Int

  """Who response ID of the queueemail."""
  whresp_id: Int

  """User Id of the queueemail added by."""
  created_u_id: Int

  """Authorisation role id of the user."""
  created_ar_id: Int

  """From email of the queueemail."""
  from_email: String

  """To email of the queueemail."""
  to_email: String

  """CC email of the queueemail."""
  cc: String

  """CC Other email of the queueemail."""
  ccother: String

  """BCC email of the queueemail."""
  bcc: String

  """Subject of the queueemail."""
  subject: String

  """Body of the queueemail."""
  body: String

  """Whether the queueemail is sent or not."""
  sent: DateTime

  """Raw json data of the queue process."""
  raw_data: JSON
}

input QueueEmailUpdateInputWhere {
  """Unique ID of the queueemail, auto generated."""
  id: FindOperatorDto

  """From user ID of the queueemail."""
  from_u_id: FindOperatorDto

  """To user ID of the queueemail."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queueemail."""
  quetype_id: FindOperatorDto

  """Who response ID of the queueemail."""
  whresp_id: FindOperatorDto

  """Reference ID of the queueemail."""
  ref_id: FindOperatorDto

  """Reference type of the queueemail."""
  ref_type: FindOperatorDto

  """User Id of the queueemail added by."""
  created_u_id: FindOperatorDto

  """Authorisation role id of the user."""
  created_ar_id: FindOperatorDto

  """From email of the queueemail."""
  from_email: FindOperatorDto

  """To email of the queueemail."""
  to_email: FindOperatorDto

  """Subject of the queueemail."""
  subject: FindOperatorDto

  """Whether the queueemail is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queueemail"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queueemail"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queueemail"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type QueueEmailUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [QueueEmailEntity!]!
}

input QueueEmailUpsertInput {
  """Reference ID of the queueemail."""
  ref_id: String!

  """Reference type of the queueemail."""
  ref_type: String!

  """Queue type ID of the queueemail."""
  quetype_id: Int!

  """From user ID of the queueemail."""
  from_u_id: Int

  """To user ID of the queueemail."""
  to_u_id: Int

  """Who response ID of the queueemail."""
  whresp_id: Int

  """User Id of the queueemail added by."""
  created_u_id: Int

  """Authorisation role id of the user."""
  created_ar_id: Int

  """From email of the queueemail."""
  from_email: String

  """To email of the queueemail."""
  to_email: String

  """CC email of the queueemail."""
  cc: String

  """CC Other email of the queueemail."""
  ccother: String

  """BCC email of the queueemail."""
  bcc: String

  """Subject of the queueemail."""
  subject: String

  """Body of the queueemail."""
  body: String

  """Whether the queueemail is sent or not."""
  sent: DateTime

  """Raw json data of the queue process."""
  raw_data: JSON

  """Unique ID of the queueemail, auto generated. undefined"""
  id: Int
}

type QueueEmailUpsertOutput {
  """Unique ID of the queueemail, auto generated."""
  id: Int

  """From user ID of the queueemail."""
  from_u_id: Int

  """To user ID of the queueemail."""
  to_u_id: Int

  """Queue type ID of the queueemail."""
  quetype_id: Int

  """Who response ID of the queueemail."""
  whresp_id: Int

  """Reference ID of the queueemail."""
  ref_id: String

  """Reference type of the queueemail."""
  ref_type: String

  """User Id of the queueemail added by."""
  created_u_id: Int

  """Authorisation role id of the user."""
  created_ar_id: Int

  """From email of the queueemail."""
  from_email: String

  """To email of the queueemail."""
  to_email: String

  """CC email of the queueemail."""
  cc: String

  """CC Other email of the queueemail."""
  ccother: String

  """BCC email of the queueemail."""
  bcc: String

  """Subject of the queueemail."""
  subject: String

  """Body of the queueemail."""
  body: String

  """Raw json data of the queue process."""
  raw_data: JSON

  """Whether the queueemail is sent or not."""
  sent: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the queueemail"""
  fr_from_user: UserEntity

  """To user of the queueemail"""
  fr_to_user: UserEntity

  """Queue type of the queueemail"""
  fr_queue_type: QueueTypeEntity

  """User id of the queueemail added by"""
  fr_created_user: UserEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input QueueSmsCreateInput {
  """Reference ID of the queuesms."""
  ref_id: String!

  """Reference type of the queuesms."""
  ref_type: String!

  """Queue type ID of the queuesms."""
  quetype_id: Int!

  """Message of the queuesms."""
  msg: String!

  """From user ID of the queuesms."""
  from_u_id: Int

  """To user ID of the queuesms."""
  to_u_id: Int

  """Who response ID of the queuesms."""
  whresp_id: Int

  """From mobile of the queuesms."""
  from_mobile: String

  """From mobile country code of the queuesms."""
  from_mobile_cc: String

  """To mobile of the queuesms."""
  to_mobile: String

  """To mobile country code of the queuesms."""
  to_mobile_cc: String

  """Subject of the queuesms."""
  subject: String

  """Whether the queuesms is sent or not."""
  sent: DateTime

  """Raw json data of the queue process."""
  raw_data: JSON
}

type QueueSmsCreateOutput {
  """Unique ID of the queuesms, auto generated."""
  id: Int

  """From user ID of the queuesms."""
  from_u_id: Int

  """To user ID of the queuesms."""
  to_u_id: Int

  """Queue type ID of the queuesms."""
  quetype_id: Int

  """Who response ID of the queuesms."""
  whresp_id: Int

  """Reference ID of the queuesms."""
  ref_id: String

  """Reference type of the queuesms."""
  ref_type: String

  """From mobile of the queuesms."""
  from_mobile: String

  """From mobile country code of the queuesms."""
  from_mobile_cc: String

  """To mobile of the queuesms."""
  to_mobile: String

  """To mobile country code of the queuesms."""
  to_mobile_cc: String

  """Subject of the queuesms."""
  subject: String

  """Message of the queuesms."""
  msg: String

  """Raw json data of the queue process."""
  raw_data: JSON

  """Whether the queuesms is sent or not."""
  sent: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the queuesms"""
  fr_from_user: UserEntity

  """To user of the queuesms"""
  fr_to_user: UserEntity

  """Queue type of the queuesms"""
  fr_queue_type: QueueTypeEntity

  """Webhook response of the queuesms"""
  fr_webhook_response: WebhookResponseEntity
}

input QueueSmsDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueSmsDeleteInputWhere!]
}

input QueueSmsDeleteInputWhere {
  """Unique ID of the queuesms, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuesms."""
  from_u_id: FindOperatorDto

  """To user ID of the queuesms."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuesms."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuesms."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuesms."""
  ref_id: FindOperatorDto

  """Reference type of the queuesms."""
  ref_type: FindOperatorDto

  """From mobile of the queuesms."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuesms."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuesms."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuesms."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuesms."""
  subject: FindOperatorDto

  """Whether the queuesms is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuesms"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuesms"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuesms"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuesms"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueSmsDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type QueueSmsEntity {
  """Unique ID of the queuesms, auto generated."""
  id: Int

  """From user ID of the queuesms."""
  from_u_id: Int

  """To user ID of the queuesms."""
  to_u_id: Int

  """Queue type ID of the queuesms."""
  quetype_id: Int

  """Who response ID of the queuesms."""
  whresp_id: Int

  """Reference ID of the queuesms."""
  ref_id: String

  """Reference type of the queuesms."""
  ref_type: String

  """From mobile of the queuesms."""
  from_mobile: String

  """From mobile country code of the queuesms."""
  from_mobile_cc: String

  """To mobile of the queuesms."""
  to_mobile: String

  """To mobile country code of the queuesms."""
  to_mobile_cc: String

  """Subject of the queuesms."""
  subject: String

  """Message of the queuesms."""
  msg: String

  """Raw json data of the queue process."""
  raw_data: JSON

  """Whether the queuesms is sent or not."""
  sent: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the queuesms"""
  fr_from_user: UserEntity

  """To user of the queuesms"""
  fr_to_user: UserEntity

  """Queue type of the queuesms"""
  fr_queue_type: QueueTypeEntity

  """Webhook response of the queuesms"""
  fr_webhook_response: WebhookResponseEntity
}

input QueueSmsFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueSmsFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: QueueSmsFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: QueueSmsFindInputSortOrder
}

input QueueSmsFindInputGroupBy {
  from_u_id: Boolean
  to_u_id: Boolean
  quetype_id: Boolean
  ref_id: Boolean
  ref_type: Boolean
  from_mobile_cc: Boolean
  to_mobile_cc: Boolean
  sent: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input QueueSmsFindInputSortOrder {
  id: RecordSortDirectionEnum
  from_u_id: RecordSortDirectionEnum
  to_u_id: RecordSortDirectionEnum
  quetype_id: RecordSortDirectionEnum
  from_mobile_cc: RecordSortDirectionEnum
  to_mobile_cc: RecordSortDirectionEnum
  sent: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input QueueSmsFindInputWhere {
  """Unique ID of the queuesms, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuesms."""
  from_u_id: FindOperatorDto

  """To user ID of the queuesms."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuesms."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuesms."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuesms."""
  ref_id: FindOperatorDto

  """Reference type of the queuesms."""
  ref_type: FindOperatorDto

  """From mobile of the queuesms."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuesms."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuesms."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuesms."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuesms."""
  subject: FindOperatorDto

  """Whether the queuesms is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuesms"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuesms"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuesms"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuesms"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

input QueueSmsFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type QueueSmsFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [QueueSmsEntity!]!
}

input QueueSmsRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueSmsRecoverInputWhere!]
}

input QueueSmsRecoverInputWhere {
  """Unique ID of the queuesms, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuesms."""
  from_u_id: FindOperatorDto

  """To user ID of the queuesms."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuesms."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuesms."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuesms."""
  ref_id: FindOperatorDto

  """Reference type of the queuesms."""
  ref_type: FindOperatorDto

  """From mobile of the queuesms."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuesms."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuesms."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuesms."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuesms."""
  subject: FindOperatorDto

  """Whether the queuesms is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuesms"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuesms"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuesms"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuesms"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueSmsRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueSmsEntity!]!
}

input QueueSmsRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueSmsRemoveInputWhere!]
}

input QueueSmsRemoveInputWhere {
  """Unique ID of the queuesms, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuesms."""
  from_u_id: FindOperatorDto

  """To user ID of the queuesms."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuesms."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuesms."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuesms."""
  ref_id: FindOperatorDto

  """Reference type of the queuesms."""
  ref_type: FindOperatorDto

  """From mobile of the queuesms."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuesms."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuesms."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuesms."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuesms."""
  subject: FindOperatorDto

  """Whether the queuesms is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuesms"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuesms"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuesms"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuesms"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueSmsRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueSmsEntity!]!
}

input QueueSmsRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueSmsRestoreInputWhere!]
}

input QueueSmsRestoreInputWhere {
  """Unique ID of the queuesms, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuesms."""
  from_u_id: FindOperatorDto

  """To user ID of the queuesms."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuesms."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuesms."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuesms."""
  ref_id: FindOperatorDto

  """Reference type of the queuesms."""
  ref_type: FindOperatorDto

  """From mobile of the queuesms."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuesms."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuesms."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuesms."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuesms."""
  subject: FindOperatorDto

  """Whether the queuesms is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuesms"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuesms"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuesms"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuesms"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueSmsRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input QueueSmsSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueSmsSoftDeleteInputWhere!]
}

input QueueSmsSoftDeleteInputWhere {
  """Unique ID of the queuesms, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuesms."""
  from_u_id: FindOperatorDto

  """To user ID of the queuesms."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuesms."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuesms."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuesms."""
  ref_id: FindOperatorDto

  """Reference type of the queuesms."""
  ref_type: FindOperatorDto

  """From mobile of the queuesms."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuesms."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuesms."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuesms."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuesms."""
  subject: FindOperatorDto

  """Whether the queuesms is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuesms"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuesms"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuesms"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuesms"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueSmsSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input QueueSmsSoftRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueSmsSoftRemoveInputWhere!]
}

input QueueSmsSoftRemoveInputWhere {
  """Unique ID of the queuesms, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuesms."""
  from_u_id: FindOperatorDto

  """To user ID of the queuesms."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuesms."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuesms."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuesms."""
  ref_id: FindOperatorDto

  """Reference type of the queuesms."""
  ref_type: FindOperatorDto

  """From mobile of the queuesms."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuesms."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuesms."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuesms."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuesms."""
  subject: FindOperatorDto

  """Whether the queuesms is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuesms"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuesms"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuesms"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuesms"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueSmsSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueSmsEntity!]!
}

input QueueSmsUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueSmsUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: QueueSmsUpdateInputSets!
}

input QueueSmsUpdateInputSets {
  """Reference ID of the queuesms."""
  ref_id: String

  """Reference type of the queuesms."""
  ref_type: String

  """Queue type ID of the queuesms."""
  quetype_id: Int

  """Message of the queuesms."""
  msg: String

  """From user ID of the queuesms."""
  from_u_id: Int

  """To user ID of the queuesms."""
  to_u_id: Int

  """Who response ID of the queuesms."""
  whresp_id: Int

  """From mobile of the queuesms."""
  from_mobile: String

  """From mobile country code of the queuesms."""
  from_mobile_cc: String

  """To mobile of the queuesms."""
  to_mobile: String

  """To mobile country code of the queuesms."""
  to_mobile_cc: String

  """Subject of the queuesms."""
  subject: String

  """Whether the queuesms is sent or not."""
  sent: DateTime

  """Raw json data of the queue process."""
  raw_data: JSON
}

input QueueSmsUpdateInputWhere {
  """Unique ID of the queuesms, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuesms."""
  from_u_id: FindOperatorDto

  """To user ID of the queuesms."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuesms."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuesms."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuesms."""
  ref_id: FindOperatorDto

  """Reference type of the queuesms."""
  ref_type: FindOperatorDto

  """From mobile of the queuesms."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuesms."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuesms."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuesms."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuesms."""
  subject: FindOperatorDto

  """Whether the queuesms is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuesms"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuesms"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuesms"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuesms"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueSmsUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [QueueSmsEntity!]!
}

input QueueSmsUpsertInput {
  """Reference ID of the queuesms."""
  ref_id: String!

  """Reference type of the queuesms."""
  ref_type: String!

  """Queue type ID of the queuesms."""
  quetype_id: Int!

  """Message of the queuesms."""
  msg: String!

  """From user ID of the queuesms."""
  from_u_id: Int

  """To user ID of the queuesms."""
  to_u_id: Int

  """Who response ID of the queuesms."""
  whresp_id: Int

  """From mobile of the queuesms."""
  from_mobile: String

  """From mobile country code of the queuesms."""
  from_mobile_cc: String

  """To mobile of the queuesms."""
  to_mobile: String

  """To mobile country code of the queuesms."""
  to_mobile_cc: String

  """Subject of the queuesms."""
  subject: String

  """Whether the queuesms is sent or not."""
  sent: DateTime

  """Raw json data of the queue process."""
  raw_data: JSON

  """Unique ID of the queuesms, auto generated. undefined"""
  id: Int
}

type QueueSmsUpsertOutput {
  """Unique ID of the queuesms, auto generated."""
  id: Int

  """From user ID of the queuesms."""
  from_u_id: Int

  """To user ID of the queuesms."""
  to_u_id: Int

  """Queue type ID of the queuesms."""
  quetype_id: Int

  """Who response ID of the queuesms."""
  whresp_id: Int

  """Reference ID of the queuesms."""
  ref_id: String

  """Reference type of the queuesms."""
  ref_type: String

  """From mobile of the queuesms."""
  from_mobile: String

  """From mobile country code of the queuesms."""
  from_mobile_cc: String

  """To mobile of the queuesms."""
  to_mobile: String

  """To mobile country code of the queuesms."""
  to_mobile_cc: String

  """Subject of the queuesms."""
  subject: String

  """Message of the queuesms."""
  msg: String

  """Raw json data of the queue process."""
  raw_data: JSON

  """Whether the queuesms is sent or not."""
  sent: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the queuesms"""
  fr_from_user: UserEntity

  """To user of the queuesms"""
  fr_to_user: UserEntity

  """Queue type of the queuesms"""
  fr_queue_type: QueueTypeEntity

  """Webhook response of the queuesms"""
  fr_webhook_response: WebhookResponseEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input QueueTypeCreateInput {
  """Title of the queuetype."""
  title: String!

  """Description of the queuetype."""
  desc: String
}

type QueueTypeCreateOutput {
  """Unique ID of the queuetype, auto generated."""
  id: Int

  """Title of the queuetype."""
  title: String

  """Description of the queuetype."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides list of queuesms of specific queuetype."""
  fr_queue_sms: [QueueSmsEntity!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_whatsapp: [QueueWhatsappEntity!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_email: [QueueEmailEntity!]
}

input QueueTypeDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueTypeDeleteInputWhere!]
}

input QueueTypeDeleteInputWhere {
  """Unique ID of the queuetype, auto generated."""
  id: FindOperatorDto

  """Title of the queuetype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of queuesms of specific queuetype."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_email: [QueueEmailFindInputWhere!]
}

type QueueTypeDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type QueueTypeEntity {
  """Unique ID of the queuetype, auto generated."""
  id: Int

  """Title of the queuetype."""
  title: String

  """Description of the queuetype."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides list of queuesms of specific queuetype."""
  fr_queue_sms: [QueueSmsEntity!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_whatsapp: [QueueWhatsappEntity!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_email: [QueueEmailEntity!]
}

input QueueTypeFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueTypeFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: QueueTypeFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: QueueTypeFindInputSortOrder
}

input QueueTypeFindInputGroupBy {
  title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input QueueTypeFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input QueueTypeFindInputWhere {
  """Unique ID of the queuetype, auto generated."""
  id: FindOperatorDto

  """Title of the queuetype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of queuesms of specific queuetype."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_email: [QueueEmailFindInputWhere!]
}

input QueueTypeFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type QueueTypeFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [QueueTypeEntity!]!
}

input QueueTypeRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueTypeRecoverInputWhere!]
}

input QueueTypeRecoverInputWhere {
  """Unique ID of the queuetype, auto generated."""
  id: FindOperatorDto

  """Title of the queuetype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of queuesms of specific queuetype."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_email: [QueueEmailFindInputWhere!]
}

type QueueTypeRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueTypeEntity!]!
}

input QueueTypeRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueTypeRemoveInputWhere!]
}

input QueueTypeRemoveInputWhere {
  """Unique ID of the queuetype, auto generated."""
  id: FindOperatorDto

  """Title of the queuetype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of queuesms of specific queuetype."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_email: [QueueEmailFindInputWhere!]
}

type QueueTypeRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueTypeEntity!]!
}

input QueueTypeRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueTypeRestoreInputWhere!]
}

input QueueTypeRestoreInputWhere {
  """Unique ID of the queuetype, auto generated."""
  id: FindOperatorDto

  """Title of the queuetype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of queuesms of specific queuetype."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_email: [QueueEmailFindInputWhere!]
}

type QueueTypeRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input QueueTypeSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueTypeSoftDeleteInputWhere!]
}

input QueueTypeSoftDeleteInputWhere {
  """Unique ID of the queuetype, auto generated."""
  id: FindOperatorDto

  """Title of the queuetype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of queuesms of specific queuetype."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_email: [QueueEmailFindInputWhere!]
}

type QueueTypeSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input QueueTypeSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueTypeSoftRemoveInputWhere!]
}

input QueueTypeSoftRemoveInputWhere {
  """Unique ID of the queuetype, auto generated."""
  id: FindOperatorDto

  """Title of the queuetype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of queuesms of specific queuetype."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_email: [QueueEmailFindInputWhere!]
}

type QueueTypeSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueTypeEntity!]!
}

input QueueTypeUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueTypeUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: QueueTypeUpdateInputSets!
}

input QueueTypeUpdateInputSets {
  """Title of the queuetype."""
  title: String

  """Description of the queuetype."""
  desc: String
}

input QueueTypeUpdateInputWhere {
  """Unique ID of the queuetype, auto generated."""
  id: FindOperatorDto

  """Title of the queuetype."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of queuesms of specific queuetype."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_email: [QueueEmailFindInputWhere!]
}

type QueueTypeUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [QueueTypeEntity!]!
}

input QueueTypeUpsertInput {
  """Title of the queuetype."""
  title: String!

  """Description of the queuetype."""
  desc: String

  """Unique ID of the queuetype, auto generated. undefined"""
  id: Int
}

type QueueTypeUpsertOutput {
  """Unique ID of the queuetype, auto generated."""
  id: Int

  """Title of the queuetype."""
  title: String

  """Description of the queuetype."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides list of queuesms of specific queuetype."""
  fr_queue_sms: [QueueSmsEntity!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_whatsapp: [QueueWhatsappEntity!]

  """Provides list of queue whatsapp msg of specific queuetype."""
  fr_queue_email: [QueueEmailEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input QueueWhatsappCreateInput {
  """Reference ID of the queuewhatsapp."""
  ref_id: String!

  """Queue type ID of the queuewhatsapp."""
  quetype_id: Int!

  """Message of the queuewhatsapp."""
  msg: String!

  """From user ID of the queuewhatsapp."""
  from_u_id: Int

  """To user ID of the queuewhatsapp."""
  to_u_id: Int

  """Who response ID of the queuewhatsapp."""
  whresp_id: Int

  """From mobile of the queuewhatsapp."""
  from_mobile: String

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: String

  """To mobile of the queuewhatsapp."""
  to_mobile: String

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: String

  """Subject of the queuewhatsapp."""
  subject: String

  """Whether the queuewhatsapp is sent or not."""
  sent: DateTime
}

type QueueWhatsappCreateOutput {
  """Unique ID of the queuewhatsapp, auto generated."""
  id: Int

  """From user ID of the queuewhatsapp."""
  from_u_id: Int

  """To user ID of the queuewhatsapp."""
  to_u_id: Int

  """Queue type ID of the queuewhatsapp."""
  quetype_id: Int

  """Who response ID of the queuewhatsapp."""
  whresp_id: Int

  """Reference ID of the queuewhatsapp."""
  ref_id: String

  """Reference type of the queuewhatsapp."""
  ref_type: String

  """From mobile of the queuewhatsapp."""
  from_mobile: String

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: String

  """To mobile of the queuewhatsapp."""
  to_mobile: String

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: String

  """Subject of the queuewhatsapp."""
  subject: String

  """Message of the queuewhatsapp."""
  msg: String

  """Whether the queuewhatsapp is sent or not."""
  sent: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the queuewhatsapp"""
  fr_from_user: UserEntity

  """To user of the queuewhatsapp"""
  fr_to_user: UserEntity

  """Queue type of the queuewhatsapp"""
  fr_queue_type: QueueTypeEntity

  """Webhook response of the queuewhatsapp"""
  fr_webhook_response: WebhookResponseEntity
}

input QueueWhatsappDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueWhatsappDeleteInputWhere!]
}

input QueueWhatsappDeleteInputWhere {
  """Unique ID of the queuewhatsapp, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuewhatsapp."""
  from_u_id: FindOperatorDto

  """To user ID of the queuewhatsapp."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuewhatsapp."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuewhatsapp."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuewhatsapp."""
  ref_id: FindOperatorDto

  """Reference type of the queuewhatsapp."""
  ref_type: FindOperatorDto

  """From mobile of the queuewhatsapp."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuewhatsapp."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuewhatsapp."""
  subject: FindOperatorDto

  """Whether the queuewhatsapp is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuewhatsapp"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuewhatsapp"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuewhatsapp"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuewhatsapp"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueWhatsappDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type QueueWhatsappEntity {
  """Unique ID of the queuewhatsapp, auto generated."""
  id: Int

  """From user ID of the queuewhatsapp."""
  from_u_id: Int

  """To user ID of the queuewhatsapp."""
  to_u_id: Int

  """Queue type ID of the queuewhatsapp."""
  quetype_id: Int

  """Who response ID of the queuewhatsapp."""
  whresp_id: Int

  """Reference ID of the queuewhatsapp."""
  ref_id: String

  """Reference type of the queuewhatsapp."""
  ref_type: String

  """From mobile of the queuewhatsapp."""
  from_mobile: String

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: String

  """To mobile of the queuewhatsapp."""
  to_mobile: String

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: String

  """Subject of the queuewhatsapp."""
  subject: String

  """Message of the queuewhatsapp."""
  msg: String

  """Whether the queuewhatsapp is sent or not."""
  sent: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the queuewhatsapp"""
  fr_from_user: UserEntity

  """To user of the queuewhatsapp"""
  fr_to_user: UserEntity

  """Queue type of the queuewhatsapp"""
  fr_queue_type: QueueTypeEntity

  """Webhook response of the queuewhatsapp"""
  fr_webhook_response: WebhookResponseEntity
}

input QueueWhatsappFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueWhatsappFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: QueueWhatsappFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: QueueWhatsappFindInputSortOrder
}

input QueueWhatsappFindInputGroupBy {
  from_u_id: Boolean
  to_u_id: Boolean
  quetype_id: Boolean
  ref_id: Boolean
  ref_type: Boolean
  from_mobile_cc: Boolean
  to_mobile_cc: Boolean
  sent: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input QueueWhatsappFindInputSortOrder {
  id: RecordSortDirectionEnum
  from_u_id: RecordSortDirectionEnum
  to_u_id: RecordSortDirectionEnum
  quetype_id: RecordSortDirectionEnum
  from_mobile_cc: RecordSortDirectionEnum
  to_mobile_cc: RecordSortDirectionEnum
  sent: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input QueueWhatsappFindInputWhere {
  """Unique ID of the queuewhatsapp, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuewhatsapp."""
  from_u_id: FindOperatorDto

  """To user ID of the queuewhatsapp."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuewhatsapp."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuewhatsapp."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuewhatsapp."""
  ref_id: FindOperatorDto

  """Reference type of the queuewhatsapp."""
  ref_type: FindOperatorDto

  """From mobile of the queuewhatsapp."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuewhatsapp."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuewhatsapp."""
  subject: FindOperatorDto

  """Whether the queuewhatsapp is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuewhatsapp"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuewhatsapp"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuewhatsapp"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuewhatsapp"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

input QueueWhatsappFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type QueueWhatsappFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [QueueWhatsappEntity!]!
}

input QueueWhatsappRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueWhatsappRecoverInputWhere!]
}

input QueueWhatsappRecoverInputWhere {
  """Unique ID of the queuewhatsapp, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuewhatsapp."""
  from_u_id: FindOperatorDto

  """To user ID of the queuewhatsapp."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuewhatsapp."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuewhatsapp."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuewhatsapp."""
  ref_id: FindOperatorDto

  """Reference type of the queuewhatsapp."""
  ref_type: FindOperatorDto

  """From mobile of the queuewhatsapp."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuewhatsapp."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuewhatsapp."""
  subject: FindOperatorDto

  """Whether the queuewhatsapp is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuewhatsapp"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuewhatsapp"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuewhatsapp"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuewhatsapp"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueWhatsappRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueWhatsappEntity!]!
}

input QueueWhatsappRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueWhatsappRemoveInputWhere!]
}

input QueueWhatsappRemoveInputWhere {
  """Unique ID of the queuewhatsapp, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuewhatsapp."""
  from_u_id: FindOperatorDto

  """To user ID of the queuewhatsapp."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuewhatsapp."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuewhatsapp."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuewhatsapp."""
  ref_id: FindOperatorDto

  """Reference type of the queuewhatsapp."""
  ref_type: FindOperatorDto

  """From mobile of the queuewhatsapp."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuewhatsapp."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuewhatsapp."""
  subject: FindOperatorDto

  """Whether the queuewhatsapp is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuewhatsapp"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuewhatsapp"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuewhatsapp"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuewhatsapp"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueWhatsappRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueWhatsappEntity!]!
}

input QueueWhatsappRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueWhatsappRestoreInputWhere!]
}

input QueueWhatsappRestoreInputWhere {
  """Unique ID of the queuewhatsapp, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuewhatsapp."""
  from_u_id: FindOperatorDto

  """To user ID of the queuewhatsapp."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuewhatsapp."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuewhatsapp."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuewhatsapp."""
  ref_id: FindOperatorDto

  """Reference type of the queuewhatsapp."""
  ref_type: FindOperatorDto

  """From mobile of the queuewhatsapp."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuewhatsapp."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuewhatsapp."""
  subject: FindOperatorDto

  """Whether the queuewhatsapp is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuewhatsapp"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuewhatsapp"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuewhatsapp"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuewhatsapp"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueWhatsappRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input QueueWhatsappSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueWhatsappSoftDeleteInputWhere!]
}

input QueueWhatsappSoftDeleteInputWhere {
  """Unique ID of the queuewhatsapp, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuewhatsapp."""
  from_u_id: FindOperatorDto

  """To user ID of the queuewhatsapp."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuewhatsapp."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuewhatsapp."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuewhatsapp."""
  ref_id: FindOperatorDto

  """Reference type of the queuewhatsapp."""
  ref_type: FindOperatorDto

  """From mobile of the queuewhatsapp."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuewhatsapp."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuewhatsapp."""
  subject: FindOperatorDto

  """Whether the queuewhatsapp is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuewhatsapp"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuewhatsapp"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuewhatsapp"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuewhatsapp"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueWhatsappSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input QueueWhatsappSoftRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueWhatsappSoftRemoveInputWhere!]
}

input QueueWhatsappSoftRemoveInputWhere {
  """Unique ID of the queuewhatsapp, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuewhatsapp."""
  from_u_id: FindOperatorDto

  """To user ID of the queuewhatsapp."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuewhatsapp."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuewhatsapp."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuewhatsapp."""
  ref_id: FindOperatorDto

  """Reference type of the queuewhatsapp."""
  ref_type: FindOperatorDto

  """From mobile of the queuewhatsapp."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuewhatsapp."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuewhatsapp."""
  subject: FindOperatorDto

  """Whether the queuewhatsapp is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuewhatsapp"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuewhatsapp"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuewhatsapp"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuewhatsapp"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueWhatsappSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [QueueWhatsappEntity!]!
}

input QueueWhatsappUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [QueueWhatsappUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: QueueWhatsappUpdateInputSets!
}

input QueueWhatsappUpdateInputSets {
  """Reference ID of the queuewhatsapp."""
  ref_id: String

  """Queue type ID of the queuewhatsapp."""
  quetype_id: Int

  """Message of the queuewhatsapp."""
  msg: String

  """From user ID of the queuewhatsapp."""
  from_u_id: Int

  """To user ID of the queuewhatsapp."""
  to_u_id: Int

  """Who response ID of the queuewhatsapp."""
  whresp_id: Int

  """From mobile of the queuewhatsapp."""
  from_mobile: String

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: String

  """To mobile of the queuewhatsapp."""
  to_mobile: String

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: String

  """Subject of the queuewhatsapp."""
  subject: String

  """Whether the queuewhatsapp is sent or not."""
  sent: DateTime
}

input QueueWhatsappUpdateInputWhere {
  """Unique ID of the queuewhatsapp, auto generated."""
  id: FindOperatorDto

  """From user ID of the queuewhatsapp."""
  from_u_id: FindOperatorDto

  """To user ID of the queuewhatsapp."""
  to_u_id: FindOperatorDto

  """Queue type ID of the queuewhatsapp."""
  quetype_id: FindOperatorDto

  """Who response ID of the queuewhatsapp."""
  whresp_id: FindOperatorDto

  """Reference ID of the queuewhatsapp."""
  ref_id: FindOperatorDto

  """Reference type of the queuewhatsapp."""
  ref_type: FindOperatorDto

  """From mobile of the queuewhatsapp."""
  from_mobile: FindOperatorDto

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: FindOperatorDto

  """To mobile of the queuewhatsapp."""
  to_mobile: FindOperatorDto

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: FindOperatorDto

  """Subject of the queuewhatsapp."""
  subject: FindOperatorDto

  """Whether the queuewhatsapp is sent or not."""
  sent: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """From user of the queuewhatsapp"""
  fr_from_user: [UserFindInputWhere!]

  """To user of the queuewhatsapp"""
  fr_to_user: [UserFindInputWhere!]

  """Queue type of the queuewhatsapp"""
  fr_queue_type: [QueueTypeFindInputWhere!]

  """Webhook response of the queuewhatsapp"""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type QueueWhatsappUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [QueueWhatsappEntity!]!
}

input QueueWhatsappUpsertInput {
  """Reference ID of the queuewhatsapp."""
  ref_id: String!

  """Queue type ID of the queuewhatsapp."""
  quetype_id: Int!

  """Message of the queuewhatsapp."""
  msg: String!

  """From user ID of the queuewhatsapp."""
  from_u_id: Int

  """To user ID of the queuewhatsapp."""
  to_u_id: Int

  """Who response ID of the queuewhatsapp."""
  whresp_id: Int

  """From mobile of the queuewhatsapp."""
  from_mobile: String

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: String

  """To mobile of the queuewhatsapp."""
  to_mobile: String

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: String

  """Subject of the queuewhatsapp."""
  subject: String

  """Whether the queuewhatsapp is sent or not."""
  sent: DateTime

  """Unique ID of the queuewhatsapp, auto generated. undefined"""
  id: Int
}

type QueueWhatsappUpsertOutput {
  """Unique ID of the queuewhatsapp, auto generated."""
  id: Int

  """From user ID of the queuewhatsapp."""
  from_u_id: Int

  """To user ID of the queuewhatsapp."""
  to_u_id: Int

  """Queue type ID of the queuewhatsapp."""
  quetype_id: Int

  """Who response ID of the queuewhatsapp."""
  whresp_id: Int

  """Reference ID of the queuewhatsapp."""
  ref_id: String

  """Reference type of the queuewhatsapp."""
  ref_type: String

  """From mobile of the queuewhatsapp."""
  from_mobile: String

  """From mobile country code of the queuewhatsapp."""
  from_mobile_cc: String

  """To mobile of the queuewhatsapp."""
  to_mobile: String

  """To mobile country code of the queuewhatsapp."""
  to_mobile_cc: String

  """Subject of the queuewhatsapp."""
  subject: String

  """Message of the queuewhatsapp."""
  msg: String

  """Whether the queuewhatsapp is sent or not."""
  sent: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """From user of the queuewhatsapp"""
  fr_from_user: UserEntity

  """To user of the queuewhatsapp"""
  fr_to_user: UserEntity

  """Queue type of the queuewhatsapp"""
  fr_queue_type: QueueTypeEntity

  """Webhook response of the queuewhatsapp"""
  fr_webhook_response: WebhookResponseEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""Serach result order by direction"""
enum RecordSortDirectionEnum {
  """A to Z - Used to sort the data returned in ascending order"""
  ASC

  """Z to A - Used to sort the data returned in descending order"""
  DESC
}

input RegionCreateInput {
  """Name of the region."""
  name: String!

  """Translations of the region."""
  translations: String
}

type RegionCreateOutput {
  """Unique ID of the region, auto generated."""
  id: Int

  """Name of the region."""
  name: String

  """Translations of the region."""
  translations: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of subregions for this region."""
  fr_subregions: [SubregionEntity!]

  """List of countries for this region."""
  fr_countries: CountryEntity
}

input RegionDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RegionDeleteInputWhere!]
}

input RegionDeleteInputWhere {
  """Unique ID of the region, auto generated."""
  id: FindOperatorDto

  """Name of the region."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of subregions for this region."""
  fr_subregions: [SubregionFindInputWhere!]

  """List of countries for this region."""
  fr_countries: [CountryFindInputWhere!]
}

type RegionDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RegionEntity {
  """Unique ID of the region, auto generated."""
  id: Int

  """Name of the region."""
  name: String

  """Translations of the region."""
  translations: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of subregions for this region."""
  fr_subregions: [SubregionEntity!]

  """List of countries for this region."""
  fr_countries: CountryEntity
}

input RegionFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RegionFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RegionFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RegionFindInputSortOrder
}

input RegionFindInputGroupBy {
  name: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input RegionFindInputSortOrder {
  id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input RegionFindInputWhere {
  """Unique ID of the region, auto generated."""
  id: FindOperatorDto

  """Name of the region."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of subregions for this region."""
  fr_subregions: [SubregionFindInputWhere!]

  """List of countries for this region."""
  fr_countries: [CountryFindInputWhere!]
}

input RegionFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RegionFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RegionEntity!]!
}

input RegionRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RegionRecoverInputWhere!]
}

input RegionRecoverInputWhere {
  """Unique ID of the region, auto generated."""
  id: FindOperatorDto

  """Name of the region."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of subregions for this region."""
  fr_subregions: [SubregionFindInputWhere!]

  """List of countries for this region."""
  fr_countries: [CountryFindInputWhere!]
}

type RegionRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RegionEntity!]!
}

input RegionRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RegionRemoveInputWhere!]
}

input RegionRemoveInputWhere {
  """Unique ID of the region, auto generated."""
  id: FindOperatorDto

  """Name of the region."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of subregions for this region."""
  fr_subregions: [SubregionFindInputWhere!]

  """List of countries for this region."""
  fr_countries: [CountryFindInputWhere!]
}

type RegionRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RegionEntity!]!
}

input RegionRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RegionRestoreInputWhere!]
}

input RegionRestoreInputWhere {
  """Unique ID of the region, auto generated."""
  id: FindOperatorDto

  """Name of the region."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of subregions for this region."""
  fr_subregions: [SubregionFindInputWhere!]

  """List of countries for this region."""
  fr_countries: [CountryFindInputWhere!]
}

type RegionRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RegionSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RegionSoftDeleteInputWhere!]
}

input RegionSoftDeleteInputWhere {
  """Unique ID of the region, auto generated."""
  id: FindOperatorDto

  """Name of the region."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of subregions for this region."""
  fr_subregions: [SubregionFindInputWhere!]

  """List of countries for this region."""
  fr_countries: [CountryFindInputWhere!]
}

type RegionSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RegionSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RegionSoftRemoveInputWhere!]
}

input RegionSoftRemoveInputWhere {
  """Unique ID of the region, auto generated."""
  id: FindOperatorDto

  """Name of the region."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of subregions for this region."""
  fr_subregions: [SubregionFindInputWhere!]

  """List of countries for this region."""
  fr_countries: [CountryFindInputWhere!]
}

type RegionSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RegionEntity!]!
}

input RegionUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RegionUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RegionUpdateInputSets!
}

input RegionUpdateInputSets {
  """Name of the region."""
  name: String

  """Translations of the region."""
  translations: String
}

input RegionUpdateInputWhere {
  """Unique ID of the region, auto generated."""
  id: FindOperatorDto

  """Name of the region."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """List of subregions for this region."""
  fr_subregions: [SubregionFindInputWhere!]

  """List of countries for this region."""
  fr_countries: [CountryFindInputWhere!]
}

type RegionUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RegionEntity!]!
}

input RegionUpsertInput {
  """Name of the region."""
  name: String!

  """Translations of the region."""
  translations: String

  """Unique ID of the region, auto generated. undefined"""
  id: Int
}

type RegionUpsertOutput {
  """Unique ID of the region, auto generated."""
  id: Int

  """Name of the region."""
  name: String

  """Translations of the region."""
  translations: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """List of subregions for this region."""
  fr_subregions: [SubregionEntity!]

  """List of countries for this region."""
  fr_countries: CountryEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsListingAdditionalInfoCreateInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Unique ID of Listing"""
  mls_num: String!

  """MLS Status"""
  mls_status: String

  """Buyer Agent Email"""
  buyer_agent_email: String

  """Buyer Agent Name"""
  buyer_agent_name: String

  """Buyer Agent Office ID"""
  buyer_agent_office_id: String

  """Buyer Office Name"""
  buyer_office_name: String

  """Buyer Office Phone"""
  buyer_office_phone: String

  """Seller Agent Name"""
  seller_agent_name: String

  """Seller Office Name"""
  seller_office_name: String

  """Seller Office ID"""
  seller_office_id: String

  """Seller Office Phone"""
  seller_office_phone: String

  """Accessibility Features"""
  accessibility_features: String

  """Acreage"""
  acreage: Float

  """Amen Rec Freq"""
  amen_rec_freq: String

  """Amenities"""
  amenities: String

  """Amenity Rec Fee"""
  amenity_rec_fee: Float

  """Appliances"""
  appliances: String

  """Application Fee"""
  application_fee: Float

  """Approval"""
  approval: String

  """Approx Living Area"""
  approx_living_area: Float

  """Available Documents"""
  available_documents: String

  """Basement"""
  basement: String

  """Bath Desc"""
  bath_desc: String

  """Bed Description"""
  bed_description: String

  """Beds Total"""
  beds_total: Int

  """Boat Access"""
  boat_access: String

  """Building Features"""
  building_features: String

  """Buildings"""
  buildings: Int

  """C Dom"""
  c_dom: Int

  """Cable Available Yn"""
  cable_available_yn: String

  """Canal Width"""
  canal_width: String

  """Carport Desc"""
  carport_desc: String

  """Carport Spaces"""
  carport_spaces: Float

  """Community Features"""
  community_features: String

  """Community Type"""
  community_type: String

  """Condo Fee Freq"""
  condo_fee_freq: String

  """Condo Fee"""
  condo_fee: Float

  """Construction"""
  construction: String

  """Contract Status Change Date"""
  contract_status_change_date: DateTime

  """Cooling"""
  cooling: String

  """Development Name"""
  development_name: String

  """Development"""
  development: String

  """Dining"""
  dining: String

  """Driving Directions"""
  driving_directions: String

  """Electric"""
  electric: String

  """Elevator"""
  elevator: String

  """Equipment"""
  equipment: String

  """Exterior Features"""
  exterior_features: String

  """Exterior Finish"""
  exterior_finish: String

  """Fencing"""
  fencing: String

  """Fireplace Features"""
  fireplace_features: String

  """Fireplace"""
  fireplace: Int

  """Floor Plan Type"""
  floor_plan_type: String

  """Flooring"""
  flooring: String

  """Foundation Details"""
  foundation_details: String

  """Furnished"""
  furnished: String

  """Gas"""
  gas: String

  """Golf Type"""
  golf_type: String

  """Gross Operating Income"""
  gross_operating_income: Float

  """Gross Rental Income"""
  gross_rental_income: Float

  """Ground Cover"""
  ground_cover: String

  """Guest House Description"""
  guest_house_desc: String

  """Guest House Living Area"""
  guest_house_living_area: Float

  """Gulf Access Type"""
  gulf_access_type: String

  """HOA Fee"""
  hoa_fee: Float

  """HOA Frequency"""
  hoa_frequency: String

  """HOA Include"""
  hoa_include: String

  """Is HOA"""
  is_hoa: String

  """Interior Features"""
  interior_features: String

  """Irrigation"""
  irrigation: String

  """Is Gulf Access"""
  is_gulf_access: String

  """Is Lease Limit"""
  is_lease_limit: String

  """Is Pool"""
  is_pool: String

  """Kitchen Features"""
  kitchen_features: String

  """Land Improvements"""
  land_improvements: String

  """Land Lease Fee Freq"""
  land_lease_fee_freq: String

  """Land Lease Fee"""
  land_lease_fee: Float

  """Last Change Date"""
  last_change_date: DateTime

  """Last Change Type"""
  last_change_type: String

  """Leases Per Year"""
  leases_per_year: Int

  """Legal"""
  legal: String

  """Lot Back"""
  lot_back: Int

  """Lot Description"""
  lot_description: String

  """Lot Dimensions"""
  lot_dimensions: String

  """Lot Frontage"""
  lot_frontage: Int

  """Lot Left"""
  lot_left: Int

  """Lot Right"""
  lot_right: Int

  """Lower Sqft"""
  lower_sqft: String

  """Mls Area Major"""
  mls_area_major: String

  """Maintenance"""
  maintenance: Float

  """Management"""
  management: String

  """Mandatory Club Fee Freq"""
  mandatory_club_fee_freq: String

  """Mandatory Club Fee"""
  mandatory_club_fee: Float

  """Mandatory Hoa Yn"""
  mandatory_hoa_yn: String

  """Mandatory Hoa Fee Freq"""
  master_hoa_fee_freq: String

  """Mandatory Hoa Fee"""
  master_hoa_fee: Float

  """Max Pets Limit Weight"""
  max_pets_limit_weight: Int

  """Max Pets Limit"""
  max_pets_limit: Int

  """Media"""
  media: String

  """Min Days Of Lease"""
  min_days_of_lease: Int

  """Net Operating Income"""
  net_operating_income: String

  """Num Unit Floor"""
  num_unit_floor: Int

  """One Time Land Lease Fee"""
  one_time_land_lease_fee: Float

  """One Time Mandatory Club Fee"""
  one_time_mandatory_club_fee: Float

  """One Time Othe Fee"""
  one_time_othe_fee: Float

  """One Time Rec Lease Fee"""
  one_time_rec_lease_fee: Float

  """One Time Special Assessment Fee"""
  one_time_special_assessment_fee: Float

  """Ownership"""
  ownership: String

  """Parcel Number"""
  parcel_number: String

  """Parcel Lots"""
  parcels_lots: String

  """Pet Desc"""
  pet_desc: String

  """Pet Restrictions"""
  pet_restrictions: String

  """Planned Use"""
  planned_use: String

  """Pool Desc"""
  pool_desc: String

  """Possession"""
  possession: String

  """Previous List Price"""
  previous_list_price: Float

  """Net Operating Income"""
  price_per_sqft: Float

  """Primary Bed Level"""
  primary_bed_level: String

  """Property Record Update Timestamp"""
  property_record_update_timestamp: DateTime

  """Rear Exposure"""
  rear_exposure: String

  """Restrictions"""
  restrictions: String

  """Road"""
  road: String

  """Roof"""
  roof: String

  """Rooms"""
  rooms: Int

  """Section"""
  section: String

  """Security Safety"""
  security_safety: String

  """Sewer"""
  sewer: String

  """Spa Desc"""
  spa_desc: String

  """Special Assessment Fee Freq"""
  special_assessment_fee_freq: String

  """Special Assessment"""
  special_assessment: String

  """Specials"""
  specials: String

  """Sprinkler"""
  sprinkler: String

  """Status Change Datetime"""
  status_change_datetime: DateTime

  """Status Type"""
  status_type: String

  """Storm Protection"""
  storm_protection: String

  """Tax District Type"""
  tax_district_type: String

  """Tax Remarks"""
  tax_remarks: String

  """Tenantpays"""
  tenantpays: String

  """Transfer Fee"""
  transfer_fee: Float

  """Trees"""
  trees: String

  """Unit Location"""
  unit_location: String

  """Units In Building"""
  units_in_building: Int

  """Unitsin Complex"""
  unitsin_complex: Int

  """Upper Sqft"""
  upper_sqft: Float

  """Usage"""
  usage: String

  """Utilities"""
  utilities: String

  """View Desc"""
  view_desc: String

  """View"""
  view: String

  """Virtual Tour Url"""
  virtual_tour_url: String

  """Water"""
  water: String

  """Waterfront Desc"""
  waterfront_desc: String

  """Windows"""
  windows: String

  """Zoning"""
  zoning: String

  """Buyer Financing"""
  buyer_financing: String

  """P Date"""
  p_date: String

  """Bidding War"""
  bidding_war: String
}

type RetsListingAdditionalInfoCreateOutput {
  """Unique ID of the market type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """MLS Status"""
  mls_status: String

  """Buyer Agent Email"""
  buyer_agent_email: String

  """Buyer Agent Name"""
  buyer_agent_name: String

  """Buyer Agent Office ID"""
  buyer_agent_office_id: String

  """Buyer Office Name"""
  buyer_office_name: String

  """Buyer Office Phone"""
  buyer_office_phone: String

  """Seller Agent Name"""
  seller_agent_name: String

  """Seller Office Name"""
  seller_office_name: String

  """Seller Office ID"""
  seller_office_id: String

  """Seller Office Phone"""
  seller_office_phone: String

  """Accessibility Features"""
  accessibility_features: String

  """Acreage"""
  acreage: Float

  """Amen Rec Freq"""
  amen_rec_freq: String

  """Amenities"""
  amenities: String

  """Amenity Rec Fee"""
  amenity_rec_fee: Float

  """Appliances"""
  appliances: String

  """Application Fee"""
  application_fee: Float

  """Approval"""
  approval: String

  """Approx Living Area"""
  approx_living_area: Float

  """Available Documents"""
  available_documents: String

  """Basement"""
  basement: String

  """Bath Desc"""
  bath_desc: String

  """Bed Description"""
  bed_description: String

  """Beds Total"""
  beds_total: Int

  """Boat Access"""
  boat_access: String

  """Building Features"""
  building_features: String

  """Buildings"""
  buildings: Int

  """C Dom"""
  c_dom: Int

  """Cable Available Yn"""
  cable_available_yn: String

  """Canal Width"""
  canal_width: String

  """Carport Desc"""
  carport_desc: String

  """Carport Spaces"""
  carport_spaces: Float

  """Community Features"""
  community_features: String

  """Community Type"""
  community_type: String

  """Condo Fee Freq"""
  condo_fee_freq: String

  """Condo Fee"""
  condo_fee: Float

  """Construction"""
  construction: String

  """Contract Status Change Date"""
  contract_status_change_date: DateTime

  """Cooling"""
  cooling: String

  """Development Name"""
  development_name: String

  """Development"""
  development: String

  """Dining"""
  dining: String

  """Driving Directions"""
  driving_directions: String

  """Electric"""
  electric: String

  """Elevator"""
  elevator: String

  """Equipment"""
  equipment: String

  """Exterior Features"""
  exterior_features: String

  """Exterior Finish"""
  exterior_finish: String

  """Fencing"""
  fencing: String

  """Fireplace Features"""
  fireplace_features: String

  """Fireplace"""
  fireplace: Int

  """Floor Plan Type"""
  floor_plan_type: String

  """Flooring"""
  flooring: String

  """Foundation Details"""
  foundation_details: String

  """Furnished"""
  furnished: String

  """Gas"""
  gas: String

  """Golf Type"""
  golf_type: String

  """Gross Operating Income"""
  gross_operating_income: Float

  """Gross Rental Income"""
  gross_rental_income: Float

  """Ground Cover"""
  ground_cover: String

  """Guest House Description"""
  guest_house_desc: String

  """Guest House Living Area"""
  guest_house_living_area: Float

  """Gulf Access Type"""
  gulf_access_type: String

  """HOA Fee"""
  hoa_fee: Float

  """HOA Frequency"""
  hoa_frequency: String

  """HOA Include"""
  hoa_include: String

  """Is HOA"""
  is_hoa: String

  """Interior Features"""
  interior_features: String

  """Irrigation"""
  irrigation: String

  """Is Gulf Access"""
  is_gulf_access: String

  """Is Lease Limit"""
  is_lease_limit: String

  """Is Pool"""
  is_pool: String

  """Kitchen Features"""
  kitchen_features: String

  """Land Improvements"""
  land_improvements: String

  """Land Lease Fee Freq"""
  land_lease_fee_freq: String

  """Land Lease Fee"""
  land_lease_fee: Float

  """Last Change Date"""
  last_change_date: DateTime

  """Last Change Type"""
  last_change_type: String

  """Leases Per Year"""
  leases_per_year: Int

  """Legal"""
  legal: String

  """Lot Back"""
  lot_back: Int

  """Lot Description"""
  lot_description: String

  """Lot Dimensions"""
  lot_dimensions: String

  """Lot Frontage"""
  lot_frontage: Int

  """Lot Left"""
  lot_left: Int

  """Lot Right"""
  lot_right: Int

  """Lower Sqft"""
  lower_sqft: String

  """Mls Area Major"""
  mls_area_major: String

  """Maintenance"""
  maintenance: Float

  """Management"""
  management: String

  """Mandatory Club Fee Freq"""
  mandatory_club_fee_freq: String

  """Mandatory Club Fee"""
  mandatory_club_fee: Float

  """Mandatory Hoa Yn"""
  mandatory_hoa_yn: String

  """Mandatory Hoa Fee Freq"""
  master_hoa_fee_freq: String

  """Mandatory Hoa Fee"""
  master_hoa_fee: Float

  """Max Pets Limit Weight"""
  max_pets_limit_weight: Int

  """Max Pets Limit"""
  max_pets_limit: Int

  """Media"""
  media: String

  """Min Days Of Lease"""
  min_days_of_lease: Int

  """Net Operating Income"""
  net_operating_income: String

  """Num Unit Floor"""
  num_unit_floor: Int

  """One Time Land Lease Fee"""
  one_time_land_lease_fee: Float

  """One Time Mandatory Club Fee"""
  one_time_mandatory_club_fee: Float

  """One Time Othe Fee"""
  one_time_othe_fee: Float

  """One Time Rec Lease Fee"""
  one_time_rec_lease_fee: Float

  """One Time Special Assessment Fee"""
  one_time_special_assessment_fee: Float

  """Ownership"""
  ownership: String

  """Parcel Number"""
  parcel_number: String

  """Parcel Lots"""
  parcels_lots: String

  """Pet Desc"""
  pet_desc: String

  """Pet Restrictions"""
  pet_restrictions: String

  """Planned Use"""
  planned_use: String

  """Pool Desc"""
  pool_desc: String

  """Possession"""
  possession: String

  """Previous List Price"""
  previous_list_price: Float

  """Net Operating Income"""
  price_per_sqft: Float

  """Primary Bed Level"""
  primary_bed_level: String

  """Property Record Update Timestamp"""
  property_record_update_timestamp: DateTime

  """Rear Exposure"""
  rear_exposure: String

  """Restrictions"""
  restrictions: String

  """Road"""
  road: String

  """Roof"""
  roof: String

  """Rooms"""
  rooms: Int

  """Section"""
  section: String

  """Security Safety"""
  security_safety: String

  """Sewer"""
  sewer: String

  """Spa Desc"""
  spa_desc: String

  """Special Assessment Fee Freq"""
  special_assessment_fee_freq: String

  """Special Assessment"""
  special_assessment: String

  """Specials"""
  specials: String

  """Sprinkler"""
  sprinkler: String

  """Status Change Datetime"""
  status_change_datetime: DateTime

  """Status Type"""
  status_type: String

  """Storm Protection"""
  storm_protection: String

  """Tax District Type"""
  tax_district_type: String

  """Tax Remarks"""
  tax_remarks: String

  """Tenantpays"""
  tenantpays: String

  """Transfer Fee"""
  transfer_fee: Float

  """Trees"""
  trees: String

  """Unit Location"""
  unit_location: String

  """Units In Building"""
  units_in_building: Int

  """Unitsin Complex"""
  unitsin_complex: Int

  """Upper Sqft"""
  upper_sqft: Float

  """Usage"""
  usage: String

  """Utilities"""
  utilities: String

  """View Desc"""
  view_desc: String

  """View"""
  view: String

  """Virtual Tour Url"""
  virtual_tour_url: String

  """Water"""
  water: String

  """Waterfront Desc"""
  waterfront_desc: String

  """Windows"""
  windows: String

  """Zoning"""
  zoning: String

  """Buyer Financing"""
  buyer_financing: String

  """P Date"""
  p_date: String

  """Bidding War"""
  bidding_war: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing additional info."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingAdditionalInfoDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAdditionalInfoDeleteInputWhere!]
}

input RetsListingAdditionalInfoDeleteInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """MLS Status"""
  mls_status: FindOperatorDto

  """Buyer Agent Email"""
  buyer_agent_email: FindOperatorDto

  """Buyer Agent Name"""
  buyer_agent_name: FindOperatorDto

  """Buyer Agent Office ID"""
  buyer_agent_office_id: FindOperatorDto

  """Buyer Office Name"""
  buyer_office_name: FindOperatorDto

  """Buyer Office Phone"""
  buyer_office_phone: FindOperatorDto

  """Seller Agent Name"""
  seller_agent_name: FindOperatorDto

  """Seller Office Name"""
  seller_office_name: FindOperatorDto

  """Seller Office ID"""
  seller_office_id: FindOperatorDto

  """Seller Office Phone"""
  seller_office_phone: FindOperatorDto

  """Accessibility Features"""
  accessibility_features: FindOperatorDto

  """Amenities"""
  amenities: FindOperatorDto

  """Amenity Rec Fee"""
  amenity_rec_fee: FindOperatorDto

  """Application Fee"""
  application_fee: FindOperatorDto

  """Approval"""
  approval: FindOperatorDto

  """Beds Total"""
  beds_total: FindOperatorDto

  """Building Features"""
  building_features: FindOperatorDto

  """Buildings"""
  buildings: FindOperatorDto

  """Cable Available Yn"""
  cable_available_yn: FindOperatorDto

  """Community Features"""
  community_features: FindOperatorDto

  """Community Type"""
  community_type: FindOperatorDto

  """Dining"""
  dining: FindOperatorDto

  """Electric"""
  electric: FindOperatorDto

  """Elevator"""
  elevator: FindOperatorDto

  """Equipment"""
  equipment: FindOperatorDto

  """Fencing"""
  fencing: FindOperatorDto

  """Furnished"""
  furnished: FindOperatorDto

  """Gas"""
  gas: FindOperatorDto

  """HOA Fee"""
  hoa_fee: FindOperatorDto

  """HOA Frequency"""
  hoa_frequency: FindOperatorDto

  """HOA Include"""
  hoa_include: FindOperatorDto

  """Is HOA"""
  is_hoa: FindOperatorDto

  """Is Gulf Access"""
  is_gulf_access: FindOperatorDto

  """Is Lease Limit"""
  is_lease_limit: FindOperatorDto

  """Is Pool"""
  is_pool: FindOperatorDto

  """Kitchen Features"""
  kitchen_features: FindOperatorDto

  """Land Lease Fee"""
  land_lease_fee: FindOperatorDto

  """Legal"""
  legal: FindOperatorDto

  """Maintenance"""
  maintenance: FindOperatorDto

  """Management"""
  management: FindOperatorDto

  """Num Unit Floor"""
  num_unit_floor: FindOperatorDto

  """Ownership"""
  ownership: FindOperatorDto

  """Parcel Number"""
  parcel_number: FindOperatorDto

  """Pool Desc"""
  pool_desc: FindOperatorDto

  """Previous List Price"""
  previous_list_price: FindOperatorDto

  """Restrictions"""
  restrictions: FindOperatorDto

  """Road"""
  road: FindOperatorDto

  """Roof"""
  roof: FindOperatorDto

  """Rooms"""
  rooms: FindOperatorDto

  """Section"""
  section: FindOperatorDto

  """Sewer"""
  sewer: FindOperatorDto

  """Specials"""
  specials: FindOperatorDto

  """Sprinkler"""
  sprinkler: FindOperatorDto

  """Utilities"""
  utilities: FindOperatorDto

  """View"""
  view: FindOperatorDto

  """Water"""
  water: FindOperatorDto

  """Waterfront Desc"""
  waterfront_desc: FindOperatorDto

  """Windows"""
  windows: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing additional info."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAdditionalInfoDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsListingAdditionalInfoEntity {
  """Unique ID of the market type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """MLS Status"""
  mls_status: String

  """Buyer Agent Email"""
  buyer_agent_email: String

  """Buyer Agent Name"""
  buyer_agent_name: String

  """Buyer Agent Office ID"""
  buyer_agent_office_id: String

  """Buyer Office Name"""
  buyer_office_name: String

  """Buyer Office Phone"""
  buyer_office_phone: String

  """Seller Agent Name"""
  seller_agent_name: String

  """Seller Office Name"""
  seller_office_name: String

  """Seller Office ID"""
  seller_office_id: String

  """Seller Office Phone"""
  seller_office_phone: String

  """Accessibility Features"""
  accessibility_features: String

  """Acreage"""
  acreage: Float

  """Amen Rec Freq"""
  amen_rec_freq: String

  """Amenities"""
  amenities: String

  """Amenity Rec Fee"""
  amenity_rec_fee: Float

  """Appliances"""
  appliances: String

  """Application Fee"""
  application_fee: Float

  """Approval"""
  approval: String

  """Approx Living Area"""
  approx_living_area: Float

  """Available Documents"""
  available_documents: String

  """Basement"""
  basement: String

  """Bath Desc"""
  bath_desc: String

  """Bed Description"""
  bed_description: String

  """Beds Total"""
  beds_total: Int

  """Boat Access"""
  boat_access: String

  """Building Features"""
  building_features: String

  """Buildings"""
  buildings: Int

  """C Dom"""
  c_dom: Int

  """Cable Available Yn"""
  cable_available_yn: String

  """Canal Width"""
  canal_width: String

  """Carport Desc"""
  carport_desc: String

  """Carport Spaces"""
  carport_spaces: Float

  """Community Features"""
  community_features: String

  """Community Type"""
  community_type: String

  """Condo Fee Freq"""
  condo_fee_freq: String

  """Condo Fee"""
  condo_fee: Float

  """Construction"""
  construction: String

  """Contract Status Change Date"""
  contract_status_change_date: DateTime

  """Cooling"""
  cooling: String

  """Development Name"""
  development_name: String

  """Development"""
  development: String

  """Dining"""
  dining: String

  """Driving Directions"""
  driving_directions: String

  """Electric"""
  electric: String

  """Elevator"""
  elevator: String

  """Equipment"""
  equipment: String

  """Exterior Features"""
  exterior_features: String

  """Exterior Finish"""
  exterior_finish: String

  """Fencing"""
  fencing: String

  """Fireplace Features"""
  fireplace_features: String

  """Fireplace"""
  fireplace: Int

  """Floor Plan Type"""
  floor_plan_type: String

  """Flooring"""
  flooring: String

  """Foundation Details"""
  foundation_details: String

  """Furnished"""
  furnished: String

  """Gas"""
  gas: String

  """Golf Type"""
  golf_type: String

  """Gross Operating Income"""
  gross_operating_income: Float

  """Gross Rental Income"""
  gross_rental_income: Float

  """Ground Cover"""
  ground_cover: String

  """Guest House Description"""
  guest_house_desc: String

  """Guest House Living Area"""
  guest_house_living_area: Float

  """Gulf Access Type"""
  gulf_access_type: String

  """HOA Fee"""
  hoa_fee: Float

  """HOA Frequency"""
  hoa_frequency: String

  """HOA Include"""
  hoa_include: String

  """Is HOA"""
  is_hoa: String

  """Interior Features"""
  interior_features: String

  """Irrigation"""
  irrigation: String

  """Is Gulf Access"""
  is_gulf_access: String

  """Is Lease Limit"""
  is_lease_limit: String

  """Is Pool"""
  is_pool: String

  """Kitchen Features"""
  kitchen_features: String

  """Land Improvements"""
  land_improvements: String

  """Land Lease Fee Freq"""
  land_lease_fee_freq: String

  """Land Lease Fee"""
  land_lease_fee: Float

  """Last Change Date"""
  last_change_date: DateTime

  """Last Change Type"""
  last_change_type: String

  """Leases Per Year"""
  leases_per_year: Int

  """Legal"""
  legal: String

  """Lot Back"""
  lot_back: Int

  """Lot Description"""
  lot_description: String

  """Lot Dimensions"""
  lot_dimensions: String

  """Lot Frontage"""
  lot_frontage: Int

  """Lot Left"""
  lot_left: Int

  """Lot Right"""
  lot_right: Int

  """Lower Sqft"""
  lower_sqft: String

  """Mls Area Major"""
  mls_area_major: String

  """Maintenance"""
  maintenance: Float

  """Management"""
  management: String

  """Mandatory Club Fee Freq"""
  mandatory_club_fee_freq: String

  """Mandatory Club Fee"""
  mandatory_club_fee: Float

  """Mandatory Hoa Yn"""
  mandatory_hoa_yn: String

  """Mandatory Hoa Fee Freq"""
  master_hoa_fee_freq: String

  """Mandatory Hoa Fee"""
  master_hoa_fee: Float

  """Max Pets Limit Weight"""
  max_pets_limit_weight: Int

  """Max Pets Limit"""
  max_pets_limit: Int

  """Media"""
  media: String

  """Min Days Of Lease"""
  min_days_of_lease: Int

  """Net Operating Income"""
  net_operating_income: String

  """Num Unit Floor"""
  num_unit_floor: Int

  """One Time Land Lease Fee"""
  one_time_land_lease_fee: Float

  """One Time Mandatory Club Fee"""
  one_time_mandatory_club_fee: Float

  """One Time Othe Fee"""
  one_time_othe_fee: Float

  """One Time Rec Lease Fee"""
  one_time_rec_lease_fee: Float

  """One Time Special Assessment Fee"""
  one_time_special_assessment_fee: Float

  """Ownership"""
  ownership: String

  """Parcel Number"""
  parcel_number: String

  """Parcel Lots"""
  parcels_lots: String

  """Pet Desc"""
  pet_desc: String

  """Pet Restrictions"""
  pet_restrictions: String

  """Planned Use"""
  planned_use: String

  """Pool Desc"""
  pool_desc: String

  """Possession"""
  possession: String

  """Previous List Price"""
  previous_list_price: Float

  """Net Operating Income"""
  price_per_sqft: Float

  """Primary Bed Level"""
  primary_bed_level: String

  """Property Record Update Timestamp"""
  property_record_update_timestamp: DateTime

  """Rear Exposure"""
  rear_exposure: String

  """Restrictions"""
  restrictions: String

  """Road"""
  road: String

  """Roof"""
  roof: String

  """Rooms"""
  rooms: Int

  """Section"""
  section: String

  """Security Safety"""
  security_safety: String

  """Sewer"""
  sewer: String

  """Spa Desc"""
  spa_desc: String

  """Special Assessment Fee Freq"""
  special_assessment_fee_freq: String

  """Special Assessment"""
  special_assessment: String

  """Specials"""
  specials: String

  """Sprinkler"""
  sprinkler: String

  """Status Change Datetime"""
  status_change_datetime: DateTime

  """Status Type"""
  status_type: String

  """Storm Protection"""
  storm_protection: String

  """Tax District Type"""
  tax_district_type: String

  """Tax Remarks"""
  tax_remarks: String

  """Tenantpays"""
  tenantpays: String

  """Transfer Fee"""
  transfer_fee: Float

  """Trees"""
  trees: String

  """Unit Location"""
  unit_location: String

  """Units In Building"""
  units_in_building: Int

  """Unitsin Complex"""
  unitsin_complex: Int

  """Upper Sqft"""
  upper_sqft: Float

  """Usage"""
  usage: String

  """Utilities"""
  utilities: String

  """View Desc"""
  view_desc: String

  """View"""
  view: String

  """Virtual Tour Url"""
  virtual_tour_url: String

  """Water"""
  water: String

  """Waterfront Desc"""
  waterfront_desc: String

  """Windows"""
  windows: String

  """Zoning"""
  zoning: String

  """Buyer Financing"""
  buyer_financing: String

  """P Date"""
  p_date: String

  """Bidding War"""
  bidding_war: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing additional info."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingAdditionalInfoFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAdditionalInfoFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsListingAdditionalInfoFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsListingAdditionalInfoFindInputSortOrder
}

input RetsListingAdditionalInfoFindInputGroupBy {
  mlsp_id: Boolean
  mls_num: Boolean
  mls_status: Boolean
  buyer_agent_email: Boolean
  buyer_agent_name: Boolean
  buyer_agent_office_id: Boolean
  buyer_office_name: Boolean
  buyer_office_phone: Boolean
  seller_agent_name: Boolean
  seller_office_name: Boolean
  seller_office_id: Boolean
  seller_office_phone: Boolean
  accessibility_features: Boolean
  amenities: Boolean
  building_features: Boolean
  buildings: Boolean
  hoa_fee: Boolean
  hoa_frequency: Boolean
  hoa_include: Boolean
  is_hoa: Boolean
  kitchen_features: Boolean
  maintenance: Boolean
  ownership: Boolean
  pool_desc: Boolean
  restrictions: Boolean
  road: Boolean
  roof: Boolean
  rooms: Boolean
  specials: Boolean
  utilities: Boolean
  view: Boolean
  water: Boolean
  waterfront_desc: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input RetsListingAdditionalInfoFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  mls_status: RecordSortDirectionEnum
  buyer_agent_email: RecordSortDirectionEnum
  buyer_agent_name: RecordSortDirectionEnum
  buyer_agent_office_id: RecordSortDirectionEnum
  buyer_office_name: RecordSortDirectionEnum
  buyer_office_phone: RecordSortDirectionEnum
  seller_agent_name: RecordSortDirectionEnum
  seller_office_name: RecordSortDirectionEnum
  seller_office_id: RecordSortDirectionEnum
  seller_office_phone: RecordSortDirectionEnum
  accessibility_features: RecordSortDirectionEnum
  amenities: RecordSortDirectionEnum
  amenity_rec_fee: RecordSortDirectionEnum
  application_fee: RecordSortDirectionEnum
  approval: RecordSortDirectionEnum
  beds_total: RecordSortDirectionEnum
  building_features: RecordSortDirectionEnum
  buildings: RecordSortDirectionEnum
  cable_available_yn: RecordSortDirectionEnum
  community_features: RecordSortDirectionEnum
  community_type: RecordSortDirectionEnum
  dining: RecordSortDirectionEnum
  electric: RecordSortDirectionEnum
  elevator: RecordSortDirectionEnum
  equipment: RecordSortDirectionEnum
  fencing: RecordSortDirectionEnum
  furnished: RecordSortDirectionEnum
  gas: RecordSortDirectionEnum
  hoa_fee: RecordSortDirectionEnum
  hoa_frequency: RecordSortDirectionEnum
  hoa_include: RecordSortDirectionEnum
  is_hoa: RecordSortDirectionEnum
  is_gulf_access: RecordSortDirectionEnum
  is_lease_limit: RecordSortDirectionEnum
  is_pool: RecordSortDirectionEnum
  kitchen_features: RecordSortDirectionEnum
  land_lease_fee: RecordSortDirectionEnum
  legal: RecordSortDirectionEnum
  maintenance: RecordSortDirectionEnum
  management: RecordSortDirectionEnum
  num_unit_floor: RecordSortDirectionEnum
  ownership: RecordSortDirectionEnum
  parcel_number: RecordSortDirectionEnum
  pool_desc: RecordSortDirectionEnum
  previous_list_price: RecordSortDirectionEnum
  restrictions: RecordSortDirectionEnum
  road: RecordSortDirectionEnum
  roof: RecordSortDirectionEnum
  rooms: RecordSortDirectionEnum
  section: RecordSortDirectionEnum
  sewer: RecordSortDirectionEnum
  specials: RecordSortDirectionEnum
  sprinkler: RecordSortDirectionEnum
  utilities: RecordSortDirectionEnum
  view: RecordSortDirectionEnum
  water: RecordSortDirectionEnum
  waterfront_desc: RecordSortDirectionEnum
  windows: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input RetsListingAdditionalInfoFindInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """MLS Status"""
  mls_status: FindOperatorDto

  """Buyer Agent Email"""
  buyer_agent_email: FindOperatorDto

  """Buyer Agent Name"""
  buyer_agent_name: FindOperatorDto

  """Buyer Agent Office ID"""
  buyer_agent_office_id: FindOperatorDto

  """Buyer Office Name"""
  buyer_office_name: FindOperatorDto

  """Buyer Office Phone"""
  buyer_office_phone: FindOperatorDto

  """Seller Agent Name"""
  seller_agent_name: FindOperatorDto

  """Seller Office Name"""
  seller_office_name: FindOperatorDto

  """Seller Office ID"""
  seller_office_id: FindOperatorDto

  """Seller Office Phone"""
  seller_office_phone: FindOperatorDto

  """Accessibility Features"""
  accessibility_features: FindOperatorDto

  """Amenities"""
  amenities: FindOperatorDto

  """Amenity Rec Fee"""
  amenity_rec_fee: FindOperatorDto

  """Application Fee"""
  application_fee: FindOperatorDto

  """Approval"""
  approval: FindOperatorDto

  """Beds Total"""
  beds_total: FindOperatorDto

  """Building Features"""
  building_features: FindOperatorDto

  """Buildings"""
  buildings: FindOperatorDto

  """Cable Available Yn"""
  cable_available_yn: FindOperatorDto

  """Community Features"""
  community_features: FindOperatorDto

  """Community Type"""
  community_type: FindOperatorDto

  """Dining"""
  dining: FindOperatorDto

  """Electric"""
  electric: FindOperatorDto

  """Elevator"""
  elevator: FindOperatorDto

  """Equipment"""
  equipment: FindOperatorDto

  """Fencing"""
  fencing: FindOperatorDto

  """Furnished"""
  furnished: FindOperatorDto

  """Gas"""
  gas: FindOperatorDto

  """HOA Fee"""
  hoa_fee: FindOperatorDto

  """HOA Frequency"""
  hoa_frequency: FindOperatorDto

  """HOA Include"""
  hoa_include: FindOperatorDto

  """Is HOA"""
  is_hoa: FindOperatorDto

  """Is Gulf Access"""
  is_gulf_access: FindOperatorDto

  """Is Lease Limit"""
  is_lease_limit: FindOperatorDto

  """Is Pool"""
  is_pool: FindOperatorDto

  """Kitchen Features"""
  kitchen_features: FindOperatorDto

  """Land Lease Fee"""
  land_lease_fee: FindOperatorDto

  """Legal"""
  legal: FindOperatorDto

  """Maintenance"""
  maintenance: FindOperatorDto

  """Management"""
  management: FindOperatorDto

  """Num Unit Floor"""
  num_unit_floor: FindOperatorDto

  """Ownership"""
  ownership: FindOperatorDto

  """Parcel Number"""
  parcel_number: FindOperatorDto

  """Pool Desc"""
  pool_desc: FindOperatorDto

  """Previous List Price"""
  previous_list_price: FindOperatorDto

  """Restrictions"""
  restrictions: FindOperatorDto

  """Road"""
  road: FindOperatorDto

  """Roof"""
  roof: FindOperatorDto

  """Rooms"""
  rooms: FindOperatorDto

  """Section"""
  section: FindOperatorDto

  """Sewer"""
  sewer: FindOperatorDto

  """Specials"""
  specials: FindOperatorDto

  """Sprinkler"""
  sprinkler: FindOperatorDto

  """Utilities"""
  utilities: FindOperatorDto

  """View"""
  view: FindOperatorDto

  """Water"""
  water: FindOperatorDto

  """Waterfront Desc"""
  waterfront_desc: FindOperatorDto

  """Windows"""
  windows: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing additional info."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input RetsListingAdditionalInfoFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsListingAdditionalInfoFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsListingAdditionalInfoEntity!]!
}

input RetsListingAdditionalInfoRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAdditionalInfoRecoverInputWhere!]
}

input RetsListingAdditionalInfoRecoverInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """MLS Status"""
  mls_status: FindOperatorDto

  """Buyer Agent Email"""
  buyer_agent_email: FindOperatorDto

  """Buyer Agent Name"""
  buyer_agent_name: FindOperatorDto

  """Buyer Agent Office ID"""
  buyer_agent_office_id: FindOperatorDto

  """Buyer Office Name"""
  buyer_office_name: FindOperatorDto

  """Buyer Office Phone"""
  buyer_office_phone: FindOperatorDto

  """Seller Agent Name"""
  seller_agent_name: FindOperatorDto

  """Seller Office Name"""
  seller_office_name: FindOperatorDto

  """Seller Office ID"""
  seller_office_id: FindOperatorDto

  """Seller Office Phone"""
  seller_office_phone: FindOperatorDto

  """Accessibility Features"""
  accessibility_features: FindOperatorDto

  """Amenities"""
  amenities: FindOperatorDto

  """Amenity Rec Fee"""
  amenity_rec_fee: FindOperatorDto

  """Application Fee"""
  application_fee: FindOperatorDto

  """Approval"""
  approval: FindOperatorDto

  """Beds Total"""
  beds_total: FindOperatorDto

  """Building Features"""
  building_features: FindOperatorDto

  """Buildings"""
  buildings: FindOperatorDto

  """Cable Available Yn"""
  cable_available_yn: FindOperatorDto

  """Community Features"""
  community_features: FindOperatorDto

  """Community Type"""
  community_type: FindOperatorDto

  """Dining"""
  dining: FindOperatorDto

  """Electric"""
  electric: FindOperatorDto

  """Elevator"""
  elevator: FindOperatorDto

  """Equipment"""
  equipment: FindOperatorDto

  """Fencing"""
  fencing: FindOperatorDto

  """Furnished"""
  furnished: FindOperatorDto

  """Gas"""
  gas: FindOperatorDto

  """HOA Fee"""
  hoa_fee: FindOperatorDto

  """HOA Frequency"""
  hoa_frequency: FindOperatorDto

  """HOA Include"""
  hoa_include: FindOperatorDto

  """Is HOA"""
  is_hoa: FindOperatorDto

  """Is Gulf Access"""
  is_gulf_access: FindOperatorDto

  """Is Lease Limit"""
  is_lease_limit: FindOperatorDto

  """Is Pool"""
  is_pool: FindOperatorDto

  """Kitchen Features"""
  kitchen_features: FindOperatorDto

  """Land Lease Fee"""
  land_lease_fee: FindOperatorDto

  """Legal"""
  legal: FindOperatorDto

  """Maintenance"""
  maintenance: FindOperatorDto

  """Management"""
  management: FindOperatorDto

  """Num Unit Floor"""
  num_unit_floor: FindOperatorDto

  """Ownership"""
  ownership: FindOperatorDto

  """Parcel Number"""
  parcel_number: FindOperatorDto

  """Pool Desc"""
  pool_desc: FindOperatorDto

  """Previous List Price"""
  previous_list_price: FindOperatorDto

  """Restrictions"""
  restrictions: FindOperatorDto

  """Road"""
  road: FindOperatorDto

  """Roof"""
  roof: FindOperatorDto

  """Rooms"""
  rooms: FindOperatorDto

  """Section"""
  section: FindOperatorDto

  """Sewer"""
  sewer: FindOperatorDto

  """Specials"""
  specials: FindOperatorDto

  """Sprinkler"""
  sprinkler: FindOperatorDto

  """Utilities"""
  utilities: FindOperatorDto

  """View"""
  view: FindOperatorDto

  """Water"""
  water: FindOperatorDto

  """Waterfront Desc"""
  waterfront_desc: FindOperatorDto

  """Windows"""
  windows: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing additional info."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAdditionalInfoRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingAdditionalInfoEntity!]!
}

input RetsListingAdditionalInfoRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAdditionalInfoRemoveInputWhere!]
}

input RetsListingAdditionalInfoRemoveInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """MLS Status"""
  mls_status: FindOperatorDto

  """Buyer Agent Email"""
  buyer_agent_email: FindOperatorDto

  """Buyer Agent Name"""
  buyer_agent_name: FindOperatorDto

  """Buyer Agent Office ID"""
  buyer_agent_office_id: FindOperatorDto

  """Buyer Office Name"""
  buyer_office_name: FindOperatorDto

  """Buyer Office Phone"""
  buyer_office_phone: FindOperatorDto

  """Seller Agent Name"""
  seller_agent_name: FindOperatorDto

  """Seller Office Name"""
  seller_office_name: FindOperatorDto

  """Seller Office ID"""
  seller_office_id: FindOperatorDto

  """Seller Office Phone"""
  seller_office_phone: FindOperatorDto

  """Accessibility Features"""
  accessibility_features: FindOperatorDto

  """Amenities"""
  amenities: FindOperatorDto

  """Amenity Rec Fee"""
  amenity_rec_fee: FindOperatorDto

  """Application Fee"""
  application_fee: FindOperatorDto

  """Approval"""
  approval: FindOperatorDto

  """Beds Total"""
  beds_total: FindOperatorDto

  """Building Features"""
  building_features: FindOperatorDto

  """Buildings"""
  buildings: FindOperatorDto

  """Cable Available Yn"""
  cable_available_yn: FindOperatorDto

  """Community Features"""
  community_features: FindOperatorDto

  """Community Type"""
  community_type: FindOperatorDto

  """Dining"""
  dining: FindOperatorDto

  """Electric"""
  electric: FindOperatorDto

  """Elevator"""
  elevator: FindOperatorDto

  """Equipment"""
  equipment: FindOperatorDto

  """Fencing"""
  fencing: FindOperatorDto

  """Furnished"""
  furnished: FindOperatorDto

  """Gas"""
  gas: FindOperatorDto

  """HOA Fee"""
  hoa_fee: FindOperatorDto

  """HOA Frequency"""
  hoa_frequency: FindOperatorDto

  """HOA Include"""
  hoa_include: FindOperatorDto

  """Is HOA"""
  is_hoa: FindOperatorDto

  """Is Gulf Access"""
  is_gulf_access: FindOperatorDto

  """Is Lease Limit"""
  is_lease_limit: FindOperatorDto

  """Is Pool"""
  is_pool: FindOperatorDto

  """Kitchen Features"""
  kitchen_features: FindOperatorDto

  """Land Lease Fee"""
  land_lease_fee: FindOperatorDto

  """Legal"""
  legal: FindOperatorDto

  """Maintenance"""
  maintenance: FindOperatorDto

  """Management"""
  management: FindOperatorDto

  """Num Unit Floor"""
  num_unit_floor: FindOperatorDto

  """Ownership"""
  ownership: FindOperatorDto

  """Parcel Number"""
  parcel_number: FindOperatorDto

  """Pool Desc"""
  pool_desc: FindOperatorDto

  """Previous List Price"""
  previous_list_price: FindOperatorDto

  """Restrictions"""
  restrictions: FindOperatorDto

  """Road"""
  road: FindOperatorDto

  """Roof"""
  roof: FindOperatorDto

  """Rooms"""
  rooms: FindOperatorDto

  """Section"""
  section: FindOperatorDto

  """Sewer"""
  sewer: FindOperatorDto

  """Specials"""
  specials: FindOperatorDto

  """Sprinkler"""
  sprinkler: FindOperatorDto

  """Utilities"""
  utilities: FindOperatorDto

  """View"""
  view: FindOperatorDto

  """Water"""
  water: FindOperatorDto

  """Waterfront Desc"""
  waterfront_desc: FindOperatorDto

  """Windows"""
  windows: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing additional info."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAdditionalInfoRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingAdditionalInfoEntity!]!
}

input RetsListingAdditionalInfoRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAdditionalInfoRestoreInputWhere!]
}

input RetsListingAdditionalInfoRestoreInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """MLS Status"""
  mls_status: FindOperatorDto

  """Buyer Agent Email"""
  buyer_agent_email: FindOperatorDto

  """Buyer Agent Name"""
  buyer_agent_name: FindOperatorDto

  """Buyer Agent Office ID"""
  buyer_agent_office_id: FindOperatorDto

  """Buyer Office Name"""
  buyer_office_name: FindOperatorDto

  """Buyer Office Phone"""
  buyer_office_phone: FindOperatorDto

  """Seller Agent Name"""
  seller_agent_name: FindOperatorDto

  """Seller Office Name"""
  seller_office_name: FindOperatorDto

  """Seller Office ID"""
  seller_office_id: FindOperatorDto

  """Seller Office Phone"""
  seller_office_phone: FindOperatorDto

  """Accessibility Features"""
  accessibility_features: FindOperatorDto

  """Amenities"""
  amenities: FindOperatorDto

  """Amenity Rec Fee"""
  amenity_rec_fee: FindOperatorDto

  """Application Fee"""
  application_fee: FindOperatorDto

  """Approval"""
  approval: FindOperatorDto

  """Beds Total"""
  beds_total: FindOperatorDto

  """Building Features"""
  building_features: FindOperatorDto

  """Buildings"""
  buildings: FindOperatorDto

  """Cable Available Yn"""
  cable_available_yn: FindOperatorDto

  """Community Features"""
  community_features: FindOperatorDto

  """Community Type"""
  community_type: FindOperatorDto

  """Dining"""
  dining: FindOperatorDto

  """Electric"""
  electric: FindOperatorDto

  """Elevator"""
  elevator: FindOperatorDto

  """Equipment"""
  equipment: FindOperatorDto

  """Fencing"""
  fencing: FindOperatorDto

  """Furnished"""
  furnished: FindOperatorDto

  """Gas"""
  gas: FindOperatorDto

  """HOA Fee"""
  hoa_fee: FindOperatorDto

  """HOA Frequency"""
  hoa_frequency: FindOperatorDto

  """HOA Include"""
  hoa_include: FindOperatorDto

  """Is HOA"""
  is_hoa: FindOperatorDto

  """Is Gulf Access"""
  is_gulf_access: FindOperatorDto

  """Is Lease Limit"""
  is_lease_limit: FindOperatorDto

  """Is Pool"""
  is_pool: FindOperatorDto

  """Kitchen Features"""
  kitchen_features: FindOperatorDto

  """Land Lease Fee"""
  land_lease_fee: FindOperatorDto

  """Legal"""
  legal: FindOperatorDto

  """Maintenance"""
  maintenance: FindOperatorDto

  """Management"""
  management: FindOperatorDto

  """Num Unit Floor"""
  num_unit_floor: FindOperatorDto

  """Ownership"""
  ownership: FindOperatorDto

  """Parcel Number"""
  parcel_number: FindOperatorDto

  """Pool Desc"""
  pool_desc: FindOperatorDto

  """Previous List Price"""
  previous_list_price: FindOperatorDto

  """Restrictions"""
  restrictions: FindOperatorDto

  """Road"""
  road: FindOperatorDto

  """Roof"""
  roof: FindOperatorDto

  """Rooms"""
  rooms: FindOperatorDto

  """Section"""
  section: FindOperatorDto

  """Sewer"""
  sewer: FindOperatorDto

  """Specials"""
  specials: FindOperatorDto

  """Sprinkler"""
  sprinkler: FindOperatorDto

  """Utilities"""
  utilities: FindOperatorDto

  """View"""
  view: FindOperatorDto

  """Water"""
  water: FindOperatorDto

  """Waterfront Desc"""
  waterfront_desc: FindOperatorDto

  """Windows"""
  windows: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing additional info."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAdditionalInfoRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingAdditionalInfoSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAdditionalInfoSoftDeleteInputWhere!]
}

input RetsListingAdditionalInfoSoftDeleteInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """MLS Status"""
  mls_status: FindOperatorDto

  """Buyer Agent Email"""
  buyer_agent_email: FindOperatorDto

  """Buyer Agent Name"""
  buyer_agent_name: FindOperatorDto

  """Buyer Agent Office ID"""
  buyer_agent_office_id: FindOperatorDto

  """Buyer Office Name"""
  buyer_office_name: FindOperatorDto

  """Buyer Office Phone"""
  buyer_office_phone: FindOperatorDto

  """Seller Agent Name"""
  seller_agent_name: FindOperatorDto

  """Seller Office Name"""
  seller_office_name: FindOperatorDto

  """Seller Office ID"""
  seller_office_id: FindOperatorDto

  """Seller Office Phone"""
  seller_office_phone: FindOperatorDto

  """Accessibility Features"""
  accessibility_features: FindOperatorDto

  """Amenities"""
  amenities: FindOperatorDto

  """Amenity Rec Fee"""
  amenity_rec_fee: FindOperatorDto

  """Application Fee"""
  application_fee: FindOperatorDto

  """Approval"""
  approval: FindOperatorDto

  """Beds Total"""
  beds_total: FindOperatorDto

  """Building Features"""
  building_features: FindOperatorDto

  """Buildings"""
  buildings: FindOperatorDto

  """Cable Available Yn"""
  cable_available_yn: FindOperatorDto

  """Community Features"""
  community_features: FindOperatorDto

  """Community Type"""
  community_type: FindOperatorDto

  """Dining"""
  dining: FindOperatorDto

  """Electric"""
  electric: FindOperatorDto

  """Elevator"""
  elevator: FindOperatorDto

  """Equipment"""
  equipment: FindOperatorDto

  """Fencing"""
  fencing: FindOperatorDto

  """Furnished"""
  furnished: FindOperatorDto

  """Gas"""
  gas: FindOperatorDto

  """HOA Fee"""
  hoa_fee: FindOperatorDto

  """HOA Frequency"""
  hoa_frequency: FindOperatorDto

  """HOA Include"""
  hoa_include: FindOperatorDto

  """Is HOA"""
  is_hoa: FindOperatorDto

  """Is Gulf Access"""
  is_gulf_access: FindOperatorDto

  """Is Lease Limit"""
  is_lease_limit: FindOperatorDto

  """Is Pool"""
  is_pool: FindOperatorDto

  """Kitchen Features"""
  kitchen_features: FindOperatorDto

  """Land Lease Fee"""
  land_lease_fee: FindOperatorDto

  """Legal"""
  legal: FindOperatorDto

  """Maintenance"""
  maintenance: FindOperatorDto

  """Management"""
  management: FindOperatorDto

  """Num Unit Floor"""
  num_unit_floor: FindOperatorDto

  """Ownership"""
  ownership: FindOperatorDto

  """Parcel Number"""
  parcel_number: FindOperatorDto

  """Pool Desc"""
  pool_desc: FindOperatorDto

  """Previous List Price"""
  previous_list_price: FindOperatorDto

  """Restrictions"""
  restrictions: FindOperatorDto

  """Road"""
  road: FindOperatorDto

  """Roof"""
  roof: FindOperatorDto

  """Rooms"""
  rooms: FindOperatorDto

  """Section"""
  section: FindOperatorDto

  """Sewer"""
  sewer: FindOperatorDto

  """Specials"""
  specials: FindOperatorDto

  """Sprinkler"""
  sprinkler: FindOperatorDto

  """Utilities"""
  utilities: FindOperatorDto

  """View"""
  view: FindOperatorDto

  """Water"""
  water: FindOperatorDto

  """Waterfront Desc"""
  waterfront_desc: FindOperatorDto

  """Windows"""
  windows: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing additional info."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAdditionalInfoSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingAdditionalInfoSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAdditionalInfoSoftRemoveInputWhere!]
}

input RetsListingAdditionalInfoSoftRemoveInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """MLS Status"""
  mls_status: FindOperatorDto

  """Buyer Agent Email"""
  buyer_agent_email: FindOperatorDto

  """Buyer Agent Name"""
  buyer_agent_name: FindOperatorDto

  """Buyer Agent Office ID"""
  buyer_agent_office_id: FindOperatorDto

  """Buyer Office Name"""
  buyer_office_name: FindOperatorDto

  """Buyer Office Phone"""
  buyer_office_phone: FindOperatorDto

  """Seller Agent Name"""
  seller_agent_name: FindOperatorDto

  """Seller Office Name"""
  seller_office_name: FindOperatorDto

  """Seller Office ID"""
  seller_office_id: FindOperatorDto

  """Seller Office Phone"""
  seller_office_phone: FindOperatorDto

  """Accessibility Features"""
  accessibility_features: FindOperatorDto

  """Amenities"""
  amenities: FindOperatorDto

  """Amenity Rec Fee"""
  amenity_rec_fee: FindOperatorDto

  """Application Fee"""
  application_fee: FindOperatorDto

  """Approval"""
  approval: FindOperatorDto

  """Beds Total"""
  beds_total: FindOperatorDto

  """Building Features"""
  building_features: FindOperatorDto

  """Buildings"""
  buildings: FindOperatorDto

  """Cable Available Yn"""
  cable_available_yn: FindOperatorDto

  """Community Features"""
  community_features: FindOperatorDto

  """Community Type"""
  community_type: FindOperatorDto

  """Dining"""
  dining: FindOperatorDto

  """Electric"""
  electric: FindOperatorDto

  """Elevator"""
  elevator: FindOperatorDto

  """Equipment"""
  equipment: FindOperatorDto

  """Fencing"""
  fencing: FindOperatorDto

  """Furnished"""
  furnished: FindOperatorDto

  """Gas"""
  gas: FindOperatorDto

  """HOA Fee"""
  hoa_fee: FindOperatorDto

  """HOA Frequency"""
  hoa_frequency: FindOperatorDto

  """HOA Include"""
  hoa_include: FindOperatorDto

  """Is HOA"""
  is_hoa: FindOperatorDto

  """Is Gulf Access"""
  is_gulf_access: FindOperatorDto

  """Is Lease Limit"""
  is_lease_limit: FindOperatorDto

  """Is Pool"""
  is_pool: FindOperatorDto

  """Kitchen Features"""
  kitchen_features: FindOperatorDto

  """Land Lease Fee"""
  land_lease_fee: FindOperatorDto

  """Legal"""
  legal: FindOperatorDto

  """Maintenance"""
  maintenance: FindOperatorDto

  """Management"""
  management: FindOperatorDto

  """Num Unit Floor"""
  num_unit_floor: FindOperatorDto

  """Ownership"""
  ownership: FindOperatorDto

  """Parcel Number"""
  parcel_number: FindOperatorDto

  """Pool Desc"""
  pool_desc: FindOperatorDto

  """Previous List Price"""
  previous_list_price: FindOperatorDto

  """Restrictions"""
  restrictions: FindOperatorDto

  """Road"""
  road: FindOperatorDto

  """Roof"""
  roof: FindOperatorDto

  """Rooms"""
  rooms: FindOperatorDto

  """Section"""
  section: FindOperatorDto

  """Sewer"""
  sewer: FindOperatorDto

  """Specials"""
  specials: FindOperatorDto

  """Sprinkler"""
  sprinkler: FindOperatorDto

  """Utilities"""
  utilities: FindOperatorDto

  """View"""
  view: FindOperatorDto

  """Water"""
  water: FindOperatorDto

  """Waterfront Desc"""
  waterfront_desc: FindOperatorDto

  """Windows"""
  windows: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing additional info."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAdditionalInfoSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingAdditionalInfoEntity!]!
}

input RetsListingAdditionalInfoUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAdditionalInfoUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsListingAdditionalInfoUpdateInputSets!
}

input RetsListingAdditionalInfoUpdateInputSets {
  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """MLS Status"""
  mls_status: String

  """Buyer Agent Email"""
  buyer_agent_email: String

  """Buyer Agent Name"""
  buyer_agent_name: String

  """Buyer Agent Office ID"""
  buyer_agent_office_id: String

  """Buyer Office Name"""
  buyer_office_name: String

  """Buyer Office Phone"""
  buyer_office_phone: String

  """Seller Agent Name"""
  seller_agent_name: String

  """Seller Office Name"""
  seller_office_name: String

  """Seller Office ID"""
  seller_office_id: String

  """Seller Office Phone"""
  seller_office_phone: String

  """Accessibility Features"""
  accessibility_features: String

  """Acreage"""
  acreage: Float

  """Amen Rec Freq"""
  amen_rec_freq: String

  """Amenities"""
  amenities: String

  """Amenity Rec Fee"""
  amenity_rec_fee: Float

  """Appliances"""
  appliances: String

  """Application Fee"""
  application_fee: Float

  """Approval"""
  approval: String

  """Approx Living Area"""
  approx_living_area: Float

  """Available Documents"""
  available_documents: String

  """Basement"""
  basement: String

  """Bath Desc"""
  bath_desc: String

  """Bed Description"""
  bed_description: String

  """Beds Total"""
  beds_total: Int

  """Boat Access"""
  boat_access: String

  """Building Features"""
  building_features: String

  """Buildings"""
  buildings: Int

  """C Dom"""
  c_dom: Int

  """Cable Available Yn"""
  cable_available_yn: String

  """Canal Width"""
  canal_width: String

  """Carport Desc"""
  carport_desc: String

  """Carport Spaces"""
  carport_spaces: Float

  """Community Features"""
  community_features: String

  """Community Type"""
  community_type: String

  """Condo Fee Freq"""
  condo_fee_freq: String

  """Condo Fee"""
  condo_fee: Float

  """Construction"""
  construction: String

  """Contract Status Change Date"""
  contract_status_change_date: DateTime

  """Cooling"""
  cooling: String

  """Development Name"""
  development_name: String

  """Development"""
  development: String

  """Dining"""
  dining: String

  """Driving Directions"""
  driving_directions: String

  """Electric"""
  electric: String

  """Elevator"""
  elevator: String

  """Equipment"""
  equipment: String

  """Exterior Features"""
  exterior_features: String

  """Exterior Finish"""
  exterior_finish: String

  """Fencing"""
  fencing: String

  """Fireplace Features"""
  fireplace_features: String

  """Fireplace"""
  fireplace: Int

  """Floor Plan Type"""
  floor_plan_type: String

  """Flooring"""
  flooring: String

  """Foundation Details"""
  foundation_details: String

  """Furnished"""
  furnished: String

  """Gas"""
  gas: String

  """Golf Type"""
  golf_type: String

  """Gross Operating Income"""
  gross_operating_income: Float

  """Gross Rental Income"""
  gross_rental_income: Float

  """Ground Cover"""
  ground_cover: String

  """Guest House Description"""
  guest_house_desc: String

  """Guest House Living Area"""
  guest_house_living_area: Float

  """Gulf Access Type"""
  gulf_access_type: String

  """HOA Fee"""
  hoa_fee: Float

  """HOA Frequency"""
  hoa_frequency: String

  """HOA Include"""
  hoa_include: String

  """Is HOA"""
  is_hoa: String

  """Interior Features"""
  interior_features: String

  """Irrigation"""
  irrigation: String

  """Is Gulf Access"""
  is_gulf_access: String

  """Is Lease Limit"""
  is_lease_limit: String

  """Is Pool"""
  is_pool: String

  """Kitchen Features"""
  kitchen_features: String

  """Land Improvements"""
  land_improvements: String

  """Land Lease Fee Freq"""
  land_lease_fee_freq: String

  """Land Lease Fee"""
  land_lease_fee: Float

  """Last Change Date"""
  last_change_date: DateTime

  """Last Change Type"""
  last_change_type: String

  """Leases Per Year"""
  leases_per_year: Int

  """Legal"""
  legal: String

  """Lot Back"""
  lot_back: Int

  """Lot Description"""
  lot_description: String

  """Lot Dimensions"""
  lot_dimensions: String

  """Lot Frontage"""
  lot_frontage: Int

  """Lot Left"""
  lot_left: Int

  """Lot Right"""
  lot_right: Int

  """Lower Sqft"""
  lower_sqft: String

  """Mls Area Major"""
  mls_area_major: String

  """Maintenance"""
  maintenance: Float

  """Management"""
  management: String

  """Mandatory Club Fee Freq"""
  mandatory_club_fee_freq: String

  """Mandatory Club Fee"""
  mandatory_club_fee: Float

  """Mandatory Hoa Yn"""
  mandatory_hoa_yn: String

  """Mandatory Hoa Fee Freq"""
  master_hoa_fee_freq: String

  """Mandatory Hoa Fee"""
  master_hoa_fee: Float

  """Max Pets Limit Weight"""
  max_pets_limit_weight: Int

  """Max Pets Limit"""
  max_pets_limit: Int

  """Media"""
  media: String

  """Min Days Of Lease"""
  min_days_of_lease: Int

  """Net Operating Income"""
  net_operating_income: String

  """Num Unit Floor"""
  num_unit_floor: Int

  """One Time Land Lease Fee"""
  one_time_land_lease_fee: Float

  """One Time Mandatory Club Fee"""
  one_time_mandatory_club_fee: Float

  """One Time Othe Fee"""
  one_time_othe_fee: Float

  """One Time Rec Lease Fee"""
  one_time_rec_lease_fee: Float

  """One Time Special Assessment Fee"""
  one_time_special_assessment_fee: Float

  """Ownership"""
  ownership: String

  """Parcel Number"""
  parcel_number: String

  """Parcel Lots"""
  parcels_lots: String

  """Pet Desc"""
  pet_desc: String

  """Pet Restrictions"""
  pet_restrictions: String

  """Planned Use"""
  planned_use: String

  """Pool Desc"""
  pool_desc: String

  """Possession"""
  possession: String

  """Previous List Price"""
  previous_list_price: Float

  """Net Operating Income"""
  price_per_sqft: Float

  """Primary Bed Level"""
  primary_bed_level: String

  """Property Record Update Timestamp"""
  property_record_update_timestamp: DateTime

  """Rear Exposure"""
  rear_exposure: String

  """Restrictions"""
  restrictions: String

  """Road"""
  road: String

  """Roof"""
  roof: String

  """Rooms"""
  rooms: Int

  """Section"""
  section: String

  """Security Safety"""
  security_safety: String

  """Sewer"""
  sewer: String

  """Spa Desc"""
  spa_desc: String

  """Special Assessment Fee Freq"""
  special_assessment_fee_freq: String

  """Special Assessment"""
  special_assessment: String

  """Specials"""
  specials: String

  """Sprinkler"""
  sprinkler: String

  """Status Change Datetime"""
  status_change_datetime: DateTime

  """Status Type"""
  status_type: String

  """Storm Protection"""
  storm_protection: String

  """Tax District Type"""
  tax_district_type: String

  """Tax Remarks"""
  tax_remarks: String

  """Tenantpays"""
  tenantpays: String

  """Transfer Fee"""
  transfer_fee: Float

  """Trees"""
  trees: String

  """Unit Location"""
  unit_location: String

  """Units In Building"""
  units_in_building: Int

  """Unitsin Complex"""
  unitsin_complex: Int

  """Upper Sqft"""
  upper_sqft: Float

  """Usage"""
  usage: String

  """Utilities"""
  utilities: String

  """View Desc"""
  view_desc: String

  """View"""
  view: String

  """Virtual Tour Url"""
  virtual_tour_url: String

  """Water"""
  water: String

  """Waterfront Desc"""
  waterfront_desc: String

  """Windows"""
  windows: String

  """Zoning"""
  zoning: String

  """Buyer Financing"""
  buyer_financing: String

  """P Date"""
  p_date: String

  """Bidding War"""
  bidding_war: String
}

input RetsListingAdditionalInfoUpdateInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """MLS Status"""
  mls_status: FindOperatorDto

  """Buyer Agent Email"""
  buyer_agent_email: FindOperatorDto

  """Buyer Agent Name"""
  buyer_agent_name: FindOperatorDto

  """Buyer Agent Office ID"""
  buyer_agent_office_id: FindOperatorDto

  """Buyer Office Name"""
  buyer_office_name: FindOperatorDto

  """Buyer Office Phone"""
  buyer_office_phone: FindOperatorDto

  """Seller Agent Name"""
  seller_agent_name: FindOperatorDto

  """Seller Office Name"""
  seller_office_name: FindOperatorDto

  """Seller Office ID"""
  seller_office_id: FindOperatorDto

  """Seller Office Phone"""
  seller_office_phone: FindOperatorDto

  """Accessibility Features"""
  accessibility_features: FindOperatorDto

  """Amenities"""
  amenities: FindOperatorDto

  """Amenity Rec Fee"""
  amenity_rec_fee: FindOperatorDto

  """Application Fee"""
  application_fee: FindOperatorDto

  """Approval"""
  approval: FindOperatorDto

  """Beds Total"""
  beds_total: FindOperatorDto

  """Building Features"""
  building_features: FindOperatorDto

  """Buildings"""
  buildings: FindOperatorDto

  """Cable Available Yn"""
  cable_available_yn: FindOperatorDto

  """Community Features"""
  community_features: FindOperatorDto

  """Community Type"""
  community_type: FindOperatorDto

  """Dining"""
  dining: FindOperatorDto

  """Electric"""
  electric: FindOperatorDto

  """Elevator"""
  elevator: FindOperatorDto

  """Equipment"""
  equipment: FindOperatorDto

  """Fencing"""
  fencing: FindOperatorDto

  """Furnished"""
  furnished: FindOperatorDto

  """Gas"""
  gas: FindOperatorDto

  """HOA Fee"""
  hoa_fee: FindOperatorDto

  """HOA Frequency"""
  hoa_frequency: FindOperatorDto

  """HOA Include"""
  hoa_include: FindOperatorDto

  """Is HOA"""
  is_hoa: FindOperatorDto

  """Is Gulf Access"""
  is_gulf_access: FindOperatorDto

  """Is Lease Limit"""
  is_lease_limit: FindOperatorDto

  """Is Pool"""
  is_pool: FindOperatorDto

  """Kitchen Features"""
  kitchen_features: FindOperatorDto

  """Land Lease Fee"""
  land_lease_fee: FindOperatorDto

  """Legal"""
  legal: FindOperatorDto

  """Maintenance"""
  maintenance: FindOperatorDto

  """Management"""
  management: FindOperatorDto

  """Num Unit Floor"""
  num_unit_floor: FindOperatorDto

  """Ownership"""
  ownership: FindOperatorDto

  """Parcel Number"""
  parcel_number: FindOperatorDto

  """Pool Desc"""
  pool_desc: FindOperatorDto

  """Previous List Price"""
  previous_list_price: FindOperatorDto

  """Restrictions"""
  restrictions: FindOperatorDto

  """Road"""
  road: FindOperatorDto

  """Roof"""
  roof: FindOperatorDto

  """Rooms"""
  rooms: FindOperatorDto

  """Section"""
  section: FindOperatorDto

  """Sewer"""
  sewer: FindOperatorDto

  """Specials"""
  specials: FindOperatorDto

  """Sprinkler"""
  sprinkler: FindOperatorDto

  """Utilities"""
  utilities: FindOperatorDto

  """View"""
  view: FindOperatorDto

  """Water"""
  water: FindOperatorDto

  """Waterfront Desc"""
  waterfront_desc: FindOperatorDto

  """Windows"""
  windows: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing additional info."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAdditionalInfoUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsListingAdditionalInfoEntity!]!
}

input RetsListingAdditionalInfoUpsertInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Unique ID of Listing"""
  mls_num: String!

  """MLS Status"""
  mls_status: String

  """Buyer Agent Email"""
  buyer_agent_email: String

  """Buyer Agent Name"""
  buyer_agent_name: String

  """Buyer Agent Office ID"""
  buyer_agent_office_id: String

  """Buyer Office Name"""
  buyer_office_name: String

  """Buyer Office Phone"""
  buyer_office_phone: String

  """Seller Agent Name"""
  seller_agent_name: String

  """Seller Office Name"""
  seller_office_name: String

  """Seller Office ID"""
  seller_office_id: String

  """Seller Office Phone"""
  seller_office_phone: String

  """Accessibility Features"""
  accessibility_features: String

  """Acreage"""
  acreage: Float

  """Amen Rec Freq"""
  amen_rec_freq: String

  """Amenities"""
  amenities: String

  """Amenity Rec Fee"""
  amenity_rec_fee: Float

  """Appliances"""
  appliances: String

  """Application Fee"""
  application_fee: Float

  """Approval"""
  approval: String

  """Approx Living Area"""
  approx_living_area: Float

  """Available Documents"""
  available_documents: String

  """Basement"""
  basement: String

  """Bath Desc"""
  bath_desc: String

  """Bed Description"""
  bed_description: String

  """Beds Total"""
  beds_total: Int

  """Boat Access"""
  boat_access: String

  """Building Features"""
  building_features: String

  """Buildings"""
  buildings: Int

  """C Dom"""
  c_dom: Int

  """Cable Available Yn"""
  cable_available_yn: String

  """Canal Width"""
  canal_width: String

  """Carport Desc"""
  carport_desc: String

  """Carport Spaces"""
  carport_spaces: Float

  """Community Features"""
  community_features: String

  """Community Type"""
  community_type: String

  """Condo Fee Freq"""
  condo_fee_freq: String

  """Condo Fee"""
  condo_fee: Float

  """Construction"""
  construction: String

  """Contract Status Change Date"""
  contract_status_change_date: DateTime

  """Cooling"""
  cooling: String

  """Development Name"""
  development_name: String

  """Development"""
  development: String

  """Dining"""
  dining: String

  """Driving Directions"""
  driving_directions: String

  """Electric"""
  electric: String

  """Elevator"""
  elevator: String

  """Equipment"""
  equipment: String

  """Exterior Features"""
  exterior_features: String

  """Exterior Finish"""
  exterior_finish: String

  """Fencing"""
  fencing: String

  """Fireplace Features"""
  fireplace_features: String

  """Fireplace"""
  fireplace: Int

  """Floor Plan Type"""
  floor_plan_type: String

  """Flooring"""
  flooring: String

  """Foundation Details"""
  foundation_details: String

  """Furnished"""
  furnished: String

  """Gas"""
  gas: String

  """Golf Type"""
  golf_type: String

  """Gross Operating Income"""
  gross_operating_income: Float

  """Gross Rental Income"""
  gross_rental_income: Float

  """Ground Cover"""
  ground_cover: String

  """Guest House Description"""
  guest_house_desc: String

  """Guest House Living Area"""
  guest_house_living_area: Float

  """Gulf Access Type"""
  gulf_access_type: String

  """HOA Fee"""
  hoa_fee: Float

  """HOA Frequency"""
  hoa_frequency: String

  """HOA Include"""
  hoa_include: String

  """Is HOA"""
  is_hoa: String

  """Interior Features"""
  interior_features: String

  """Irrigation"""
  irrigation: String

  """Is Gulf Access"""
  is_gulf_access: String

  """Is Lease Limit"""
  is_lease_limit: String

  """Is Pool"""
  is_pool: String

  """Kitchen Features"""
  kitchen_features: String

  """Land Improvements"""
  land_improvements: String

  """Land Lease Fee Freq"""
  land_lease_fee_freq: String

  """Land Lease Fee"""
  land_lease_fee: Float

  """Last Change Date"""
  last_change_date: DateTime

  """Last Change Type"""
  last_change_type: String

  """Leases Per Year"""
  leases_per_year: Int

  """Legal"""
  legal: String

  """Lot Back"""
  lot_back: Int

  """Lot Description"""
  lot_description: String

  """Lot Dimensions"""
  lot_dimensions: String

  """Lot Frontage"""
  lot_frontage: Int

  """Lot Left"""
  lot_left: Int

  """Lot Right"""
  lot_right: Int

  """Lower Sqft"""
  lower_sqft: String

  """Mls Area Major"""
  mls_area_major: String

  """Maintenance"""
  maintenance: Float

  """Management"""
  management: String

  """Mandatory Club Fee Freq"""
  mandatory_club_fee_freq: String

  """Mandatory Club Fee"""
  mandatory_club_fee: Float

  """Mandatory Hoa Yn"""
  mandatory_hoa_yn: String

  """Mandatory Hoa Fee Freq"""
  master_hoa_fee_freq: String

  """Mandatory Hoa Fee"""
  master_hoa_fee: Float

  """Max Pets Limit Weight"""
  max_pets_limit_weight: Int

  """Max Pets Limit"""
  max_pets_limit: Int

  """Media"""
  media: String

  """Min Days Of Lease"""
  min_days_of_lease: Int

  """Net Operating Income"""
  net_operating_income: String

  """Num Unit Floor"""
  num_unit_floor: Int

  """One Time Land Lease Fee"""
  one_time_land_lease_fee: Float

  """One Time Mandatory Club Fee"""
  one_time_mandatory_club_fee: Float

  """One Time Othe Fee"""
  one_time_othe_fee: Float

  """One Time Rec Lease Fee"""
  one_time_rec_lease_fee: Float

  """One Time Special Assessment Fee"""
  one_time_special_assessment_fee: Float

  """Ownership"""
  ownership: String

  """Parcel Number"""
  parcel_number: String

  """Parcel Lots"""
  parcels_lots: String

  """Pet Desc"""
  pet_desc: String

  """Pet Restrictions"""
  pet_restrictions: String

  """Planned Use"""
  planned_use: String

  """Pool Desc"""
  pool_desc: String

  """Possession"""
  possession: String

  """Previous List Price"""
  previous_list_price: Float

  """Net Operating Income"""
  price_per_sqft: Float

  """Primary Bed Level"""
  primary_bed_level: String

  """Property Record Update Timestamp"""
  property_record_update_timestamp: DateTime

  """Rear Exposure"""
  rear_exposure: String

  """Restrictions"""
  restrictions: String

  """Road"""
  road: String

  """Roof"""
  roof: String

  """Rooms"""
  rooms: Int

  """Section"""
  section: String

  """Security Safety"""
  security_safety: String

  """Sewer"""
  sewer: String

  """Spa Desc"""
  spa_desc: String

  """Special Assessment Fee Freq"""
  special_assessment_fee_freq: String

  """Special Assessment"""
  special_assessment: String

  """Specials"""
  specials: String

  """Sprinkler"""
  sprinkler: String

  """Status Change Datetime"""
  status_change_datetime: DateTime

  """Status Type"""
  status_type: String

  """Storm Protection"""
  storm_protection: String

  """Tax District Type"""
  tax_district_type: String

  """Tax Remarks"""
  tax_remarks: String

  """Tenantpays"""
  tenantpays: String

  """Transfer Fee"""
  transfer_fee: Float

  """Trees"""
  trees: String

  """Unit Location"""
  unit_location: String

  """Units In Building"""
  units_in_building: Int

  """Unitsin Complex"""
  unitsin_complex: Int

  """Upper Sqft"""
  upper_sqft: Float

  """Usage"""
  usage: String

  """Utilities"""
  utilities: String

  """View Desc"""
  view_desc: String

  """View"""
  view: String

  """Virtual Tour Url"""
  virtual_tour_url: String

  """Water"""
  water: String

  """Waterfront Desc"""
  waterfront_desc: String

  """Windows"""
  windows: String

  """Zoning"""
  zoning: String

  """Buyer Financing"""
  buyer_financing: String

  """P Date"""
  p_date: String

  """Bidding War"""
  bidding_war: String

  """Unique ID of the market type, auto generated. undefined"""
  id: Int
}

type RetsListingAdditionalInfoUpsertOutput {
  """Unique ID of the market type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """MLS Status"""
  mls_status: String

  """Buyer Agent Email"""
  buyer_agent_email: String

  """Buyer Agent Name"""
  buyer_agent_name: String

  """Buyer Agent Office ID"""
  buyer_agent_office_id: String

  """Buyer Office Name"""
  buyer_office_name: String

  """Buyer Office Phone"""
  buyer_office_phone: String

  """Seller Agent Name"""
  seller_agent_name: String

  """Seller Office Name"""
  seller_office_name: String

  """Seller Office ID"""
  seller_office_id: String

  """Seller Office Phone"""
  seller_office_phone: String

  """Accessibility Features"""
  accessibility_features: String

  """Acreage"""
  acreage: Float

  """Amen Rec Freq"""
  amen_rec_freq: String

  """Amenities"""
  amenities: String

  """Amenity Rec Fee"""
  amenity_rec_fee: Float

  """Appliances"""
  appliances: String

  """Application Fee"""
  application_fee: Float

  """Approval"""
  approval: String

  """Approx Living Area"""
  approx_living_area: Float

  """Available Documents"""
  available_documents: String

  """Basement"""
  basement: String

  """Bath Desc"""
  bath_desc: String

  """Bed Description"""
  bed_description: String

  """Beds Total"""
  beds_total: Int

  """Boat Access"""
  boat_access: String

  """Building Features"""
  building_features: String

  """Buildings"""
  buildings: Int

  """C Dom"""
  c_dom: Int

  """Cable Available Yn"""
  cable_available_yn: String

  """Canal Width"""
  canal_width: String

  """Carport Desc"""
  carport_desc: String

  """Carport Spaces"""
  carport_spaces: Float

  """Community Features"""
  community_features: String

  """Community Type"""
  community_type: String

  """Condo Fee Freq"""
  condo_fee_freq: String

  """Condo Fee"""
  condo_fee: Float

  """Construction"""
  construction: String

  """Contract Status Change Date"""
  contract_status_change_date: DateTime

  """Cooling"""
  cooling: String

  """Development Name"""
  development_name: String

  """Development"""
  development: String

  """Dining"""
  dining: String

  """Driving Directions"""
  driving_directions: String

  """Electric"""
  electric: String

  """Elevator"""
  elevator: String

  """Equipment"""
  equipment: String

  """Exterior Features"""
  exterior_features: String

  """Exterior Finish"""
  exterior_finish: String

  """Fencing"""
  fencing: String

  """Fireplace Features"""
  fireplace_features: String

  """Fireplace"""
  fireplace: Int

  """Floor Plan Type"""
  floor_plan_type: String

  """Flooring"""
  flooring: String

  """Foundation Details"""
  foundation_details: String

  """Furnished"""
  furnished: String

  """Gas"""
  gas: String

  """Golf Type"""
  golf_type: String

  """Gross Operating Income"""
  gross_operating_income: Float

  """Gross Rental Income"""
  gross_rental_income: Float

  """Ground Cover"""
  ground_cover: String

  """Guest House Description"""
  guest_house_desc: String

  """Guest House Living Area"""
  guest_house_living_area: Float

  """Gulf Access Type"""
  gulf_access_type: String

  """HOA Fee"""
  hoa_fee: Float

  """HOA Frequency"""
  hoa_frequency: String

  """HOA Include"""
  hoa_include: String

  """Is HOA"""
  is_hoa: String

  """Interior Features"""
  interior_features: String

  """Irrigation"""
  irrigation: String

  """Is Gulf Access"""
  is_gulf_access: String

  """Is Lease Limit"""
  is_lease_limit: String

  """Is Pool"""
  is_pool: String

  """Kitchen Features"""
  kitchen_features: String

  """Land Improvements"""
  land_improvements: String

  """Land Lease Fee Freq"""
  land_lease_fee_freq: String

  """Land Lease Fee"""
  land_lease_fee: Float

  """Last Change Date"""
  last_change_date: DateTime

  """Last Change Type"""
  last_change_type: String

  """Leases Per Year"""
  leases_per_year: Int

  """Legal"""
  legal: String

  """Lot Back"""
  lot_back: Int

  """Lot Description"""
  lot_description: String

  """Lot Dimensions"""
  lot_dimensions: String

  """Lot Frontage"""
  lot_frontage: Int

  """Lot Left"""
  lot_left: Int

  """Lot Right"""
  lot_right: Int

  """Lower Sqft"""
  lower_sqft: String

  """Mls Area Major"""
  mls_area_major: String

  """Maintenance"""
  maintenance: Float

  """Management"""
  management: String

  """Mandatory Club Fee Freq"""
  mandatory_club_fee_freq: String

  """Mandatory Club Fee"""
  mandatory_club_fee: Float

  """Mandatory Hoa Yn"""
  mandatory_hoa_yn: String

  """Mandatory Hoa Fee Freq"""
  master_hoa_fee_freq: String

  """Mandatory Hoa Fee"""
  master_hoa_fee: Float

  """Max Pets Limit Weight"""
  max_pets_limit_weight: Int

  """Max Pets Limit"""
  max_pets_limit: Int

  """Media"""
  media: String

  """Min Days Of Lease"""
  min_days_of_lease: Int

  """Net Operating Income"""
  net_operating_income: String

  """Num Unit Floor"""
  num_unit_floor: Int

  """One Time Land Lease Fee"""
  one_time_land_lease_fee: Float

  """One Time Mandatory Club Fee"""
  one_time_mandatory_club_fee: Float

  """One Time Othe Fee"""
  one_time_othe_fee: Float

  """One Time Rec Lease Fee"""
  one_time_rec_lease_fee: Float

  """One Time Special Assessment Fee"""
  one_time_special_assessment_fee: Float

  """Ownership"""
  ownership: String

  """Parcel Number"""
  parcel_number: String

  """Parcel Lots"""
  parcels_lots: String

  """Pet Desc"""
  pet_desc: String

  """Pet Restrictions"""
  pet_restrictions: String

  """Planned Use"""
  planned_use: String

  """Pool Desc"""
  pool_desc: String

  """Possession"""
  possession: String

  """Previous List Price"""
  previous_list_price: Float

  """Net Operating Income"""
  price_per_sqft: Float

  """Primary Bed Level"""
  primary_bed_level: String

  """Property Record Update Timestamp"""
  property_record_update_timestamp: DateTime

  """Rear Exposure"""
  rear_exposure: String

  """Restrictions"""
  restrictions: String

  """Road"""
  road: String

  """Roof"""
  roof: String

  """Rooms"""
  rooms: Int

  """Section"""
  section: String

  """Security Safety"""
  security_safety: String

  """Sewer"""
  sewer: String

  """Spa Desc"""
  spa_desc: String

  """Special Assessment Fee Freq"""
  special_assessment_fee_freq: String

  """Special Assessment"""
  special_assessment: String

  """Specials"""
  specials: String

  """Sprinkler"""
  sprinkler: String

  """Status Change Datetime"""
  status_change_datetime: DateTime

  """Status Type"""
  status_type: String

  """Storm Protection"""
  storm_protection: String

  """Tax District Type"""
  tax_district_type: String

  """Tax Remarks"""
  tax_remarks: String

  """Tenantpays"""
  tenantpays: String

  """Transfer Fee"""
  transfer_fee: Float

  """Trees"""
  trees: String

  """Unit Location"""
  unit_location: String

  """Units In Building"""
  units_in_building: Int

  """Unitsin Complex"""
  unitsin_complex: Int

  """Upper Sqft"""
  upper_sqft: Float

  """Usage"""
  usage: String

  """Utilities"""
  utilities: String

  """View Desc"""
  view_desc: String

  """View"""
  view: String

  """Virtual Tour Url"""
  virtual_tour_url: String

  """Water"""
  water: String

  """Waterfront Desc"""
  waterfront_desc: String

  """Windows"""
  windows: String

  """Zoning"""
  zoning: String

  """Buyer Financing"""
  buyer_financing: String

  """P Date"""
  p_date: String

  """Bidding War"""
  bidding_war: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing additional info."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsListingAgentCreateInput {
  """Agent ID of Listing Agent"""
  agent_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Agent Name"""
  agent_name: String!

  """Agent Fname"""
  agent_fname: String

  """Agent Lname"""
  agent_lname: String

  """Agent Email"""
  agent_email: String

  """Agent Phone"""
  agent_phone: String

  """Agent Office Id"""
  agent_office_id: String

  """Agent Home Phone"""
  agent_home_phone: String

  """Agent Fax"""
  agent_fax: String

  """Agent License Name"""
  agent_license_number: String
}

type RetsListingAgentCreateOutput {
  """Unique ID of the listing agent type, auto generated."""
  id: Int

  """Agent ID of Listing Agent"""
  agent_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Agent Name"""
  agent_name: String

  """Agent Fname"""
  agent_fname: String

  """Agent Lname"""
  agent_lname: String

  """Agent Email"""
  agent_email: String

  """Agent Phone"""
  agent_phone: String

  """Agent Office Id"""
  agent_office_id: String

  """Agent Home Phone"""
  agent_home_phone: String

  """Agent Fax"""
  agent_fax: String

  """Agent License Name"""
  agent_license_number: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing agent."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingAgentDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAgentDeleteInputWhere!]
}

input RetsListingAgentDeleteInputWhere {
  """Unique ID of the listing agent type, auto generated."""
  id: FindOperatorDto

  """Agent ID of Listing Agent"""
  agent_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Agent Name"""
  agent_name: FindOperatorDto

  """Agent Fname"""
  agent_fname: FindOperatorDto

  """Agent Lname"""
  agent_lname: FindOperatorDto

  """Agent Email"""
  agent_email: FindOperatorDto

  """Agent Phone"""
  agent_phone: FindOperatorDto

  """Agent Office Id"""
  agent_office_id: FindOperatorDto

  """Agent Home Phone"""
  agent_home_phone: FindOperatorDto

  """Agent License Name"""
  agent_license_number: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing agent."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAgentDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsListingAgentEntity {
  """Unique ID of the listing agent type, auto generated."""
  id: Int

  """Agent ID of Listing Agent"""
  agent_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Agent Name"""
  agent_name: String

  """Agent Fname"""
  agent_fname: String

  """Agent Lname"""
  agent_lname: String

  """Agent Email"""
  agent_email: String

  """Agent Phone"""
  agent_phone: String

  """Agent Office Id"""
  agent_office_id: String

  """Agent Home Phone"""
  agent_home_phone: String

  """Agent Fax"""
  agent_fax: String

  """Agent License Name"""
  agent_license_number: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing agent."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingAgentFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAgentFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsListingAgentFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsListingAgentFindInputSortOrder
}

input RetsListingAgentFindInputGroupBy {
  agent_id: Boolean
  mlsp_id: Boolean
  agent_name: Boolean
  agent_email: Boolean
  agent_phone: Boolean
  agent_office_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input RetsListingAgentFindInputSortOrder {
  id: RecordSortDirectionEnum
  agent_id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  agent_name: RecordSortDirectionEnum
  agent_fname: RecordSortDirectionEnum
  agent_lname: RecordSortDirectionEnum
  agent_email: RecordSortDirectionEnum
  agent_phone: RecordSortDirectionEnum
  agent_office_id: RecordSortDirectionEnum
  agent_home_phone: RecordSortDirectionEnum
  agent_license_number: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input RetsListingAgentFindInputWhere {
  """Unique ID of the listing agent type, auto generated."""
  id: FindOperatorDto

  """Agent ID of Listing Agent"""
  agent_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Agent Name"""
  agent_name: FindOperatorDto

  """Agent Fname"""
  agent_fname: FindOperatorDto

  """Agent Lname"""
  agent_lname: FindOperatorDto

  """Agent Email"""
  agent_email: FindOperatorDto

  """Agent Phone"""
  agent_phone: FindOperatorDto

  """Agent Office Id"""
  agent_office_id: FindOperatorDto

  """Agent Home Phone"""
  agent_home_phone: FindOperatorDto

  """Agent License Name"""
  agent_license_number: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing agent."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input RetsListingAgentFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsListingAgentFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsListingAgentEntity!]!
}

input RetsListingAgentRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAgentRecoverInputWhere!]
}

input RetsListingAgentRecoverInputWhere {
  """Unique ID of the listing agent type, auto generated."""
  id: FindOperatorDto

  """Agent ID of Listing Agent"""
  agent_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Agent Name"""
  agent_name: FindOperatorDto

  """Agent Fname"""
  agent_fname: FindOperatorDto

  """Agent Lname"""
  agent_lname: FindOperatorDto

  """Agent Email"""
  agent_email: FindOperatorDto

  """Agent Phone"""
  agent_phone: FindOperatorDto

  """Agent Office Id"""
  agent_office_id: FindOperatorDto

  """Agent Home Phone"""
  agent_home_phone: FindOperatorDto

  """Agent License Name"""
  agent_license_number: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing agent."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAgentRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingAgentEntity!]!
}

input RetsListingAgentRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAgentRemoveInputWhere!]
}

input RetsListingAgentRemoveInputWhere {
  """Unique ID of the listing agent type, auto generated."""
  id: FindOperatorDto

  """Agent ID of Listing Agent"""
  agent_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Agent Name"""
  agent_name: FindOperatorDto

  """Agent Fname"""
  agent_fname: FindOperatorDto

  """Agent Lname"""
  agent_lname: FindOperatorDto

  """Agent Email"""
  agent_email: FindOperatorDto

  """Agent Phone"""
  agent_phone: FindOperatorDto

  """Agent Office Id"""
  agent_office_id: FindOperatorDto

  """Agent Home Phone"""
  agent_home_phone: FindOperatorDto

  """Agent License Name"""
  agent_license_number: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing agent."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAgentRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingAgentEntity!]!
}

input RetsListingAgentRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAgentRestoreInputWhere!]
}

input RetsListingAgentRestoreInputWhere {
  """Unique ID of the listing agent type, auto generated."""
  id: FindOperatorDto

  """Agent ID of Listing Agent"""
  agent_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Agent Name"""
  agent_name: FindOperatorDto

  """Agent Fname"""
  agent_fname: FindOperatorDto

  """Agent Lname"""
  agent_lname: FindOperatorDto

  """Agent Email"""
  agent_email: FindOperatorDto

  """Agent Phone"""
  agent_phone: FindOperatorDto

  """Agent Office Id"""
  agent_office_id: FindOperatorDto

  """Agent Home Phone"""
  agent_home_phone: FindOperatorDto

  """Agent License Name"""
  agent_license_number: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing agent."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAgentRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingAgentSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAgentSoftDeleteInputWhere!]
}

input RetsListingAgentSoftDeleteInputWhere {
  """Unique ID of the listing agent type, auto generated."""
  id: FindOperatorDto

  """Agent ID of Listing Agent"""
  agent_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Agent Name"""
  agent_name: FindOperatorDto

  """Agent Fname"""
  agent_fname: FindOperatorDto

  """Agent Lname"""
  agent_lname: FindOperatorDto

  """Agent Email"""
  agent_email: FindOperatorDto

  """Agent Phone"""
  agent_phone: FindOperatorDto

  """Agent Office Id"""
  agent_office_id: FindOperatorDto

  """Agent Home Phone"""
  agent_home_phone: FindOperatorDto

  """Agent License Name"""
  agent_license_number: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing agent."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAgentSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingAgentSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAgentSoftRemoveInputWhere!]
}

input RetsListingAgentSoftRemoveInputWhere {
  """Unique ID of the listing agent type, auto generated."""
  id: FindOperatorDto

  """Agent ID of Listing Agent"""
  agent_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Agent Name"""
  agent_name: FindOperatorDto

  """Agent Fname"""
  agent_fname: FindOperatorDto

  """Agent Lname"""
  agent_lname: FindOperatorDto

  """Agent Email"""
  agent_email: FindOperatorDto

  """Agent Phone"""
  agent_phone: FindOperatorDto

  """Agent Office Id"""
  agent_office_id: FindOperatorDto

  """Agent Home Phone"""
  agent_home_phone: FindOperatorDto

  """Agent License Name"""
  agent_license_number: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing agent."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAgentSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingAgentEntity!]!
}

input RetsListingAgentUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingAgentUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsListingAgentUpdateInputSets!
}

input RetsListingAgentUpdateInputSets {
  """Agent ID of Listing Agent"""
  agent_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Agent Name"""
  agent_name: String

  """Agent Fname"""
  agent_fname: String

  """Agent Lname"""
  agent_lname: String

  """Agent Email"""
  agent_email: String

  """Agent Phone"""
  agent_phone: String

  """Agent Office Id"""
  agent_office_id: String

  """Agent Home Phone"""
  agent_home_phone: String

  """Agent Fax"""
  agent_fax: String

  """Agent License Name"""
  agent_license_number: String
}

input RetsListingAgentUpdateInputWhere {
  """Unique ID of the listing agent type, auto generated."""
  id: FindOperatorDto

  """Agent ID of Listing Agent"""
  agent_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Agent Name"""
  agent_name: FindOperatorDto

  """Agent Fname"""
  agent_fname: FindOperatorDto

  """Agent Lname"""
  agent_lname: FindOperatorDto

  """Agent Email"""
  agent_email: FindOperatorDto

  """Agent Phone"""
  agent_phone: FindOperatorDto

  """Agent Office Id"""
  agent_office_id: FindOperatorDto

  """Agent Home Phone"""
  agent_home_phone: FindOperatorDto

  """Agent License Name"""
  agent_license_number: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing agent."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingAgentUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsListingAgentEntity!]!
}

input RetsListingAgentUpsertInput {
  """Agent ID of Listing Agent"""
  agent_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Agent Name"""
  agent_name: String!

  """Agent Fname"""
  agent_fname: String

  """Agent Lname"""
  agent_lname: String

  """Agent Email"""
  agent_email: String

  """Agent Phone"""
  agent_phone: String

  """Agent Office Id"""
  agent_office_id: String

  """Agent Home Phone"""
  agent_home_phone: String

  """Agent Fax"""
  agent_fax: String

  """Agent License Name"""
  agent_license_number: String

  """Unique ID of the listing agent type, auto generated. undefined"""
  id: Int
}

type RetsListingAgentUpsertOutput {
  """Unique ID of the listing agent type, auto generated."""
  id: Int

  """Agent ID of Listing Agent"""
  agent_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Agent Name"""
  agent_name: String

  """Agent Fname"""
  agent_fname: String

  """Agent Lname"""
  agent_lname: String

  """Agent Email"""
  agent_email: String

  """Agent Phone"""
  agent_phone: String

  """Agent Office Id"""
  agent_office_id: String

  """Agent Home Phone"""
  agent_home_phone: String

  """Agent Fax"""
  agent_fax: String

  """Agent License Name"""
  agent_license_number: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing agent."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsListingCreateInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Unique ID of Listing"""
  mls_num: String!

  """Listing key"""
  listing_key: String!

  """Price difference"""
  price_diff: Float!

  """Picture downloaded"""
  pic_downloaded: DateTime

  """Picture download error"""
  pic_download_error: DateTime

  """Picture updated"""
  pic_updated: DateTime

  """Third Party api platform"""
  latlong_tppltf_id: Int

  """Latlong downloaded"""
  latlong_downloaded: DateTime

  """When record is created, date-time will be saved."""
  created_timestamp: DateTime

  """Property status"""
  property_status: String

  """Property style"""
  property_style: String

  """Property type"""
  property_type: String!

  """Subtype"""
  subtype: String

  """Display address"""
  display_address: String!

  """address"""
  address: String!

  """Unit no"""
  unit_no: String

  """Street dir prefix"""
  street_dir_prefix: String

  """Street dir suffix"""
  street_dir_suffix: String

  """Street number modifier"""
  street_number_modifier: String

  """Street name"""
  street_name: String!

  """Street number"""
  street_number: String!

  """Street suffix"""
  street_suffix: String

  """City name"""
  city_name: String!

  """State"""
  state: String!

  """Zipcode"""
  zipcode: String!

  """County"""
  county: String

  """Sub Condo Name"""
  sub_condo_name: String

  """Subdivision"""
  subdivision: String

  """Baths"""
  baths: Int!

  """Beds"""
  beds: Int!

  """Dom"""
  dom: Int

  """Listing Date"""
  listing_date: DateTime!

  """Last Photo Date"""
  last_photo_date: DateTime

  """Last Update Date"""
  last_update_date: DateTime

  """Latitude"""
  latitude: Float!

  """Longitude"""
  longitude: Float!

  """List price"""
  list_price: Float!

  """Lot size"""
  lot_size: Float

  """Main sqft"""
  main_sqft: Float

  """Main photo url"""
  main_photo_url: String

  """Original entry timestamp"""
  original_entry_timestamp: DateTime

  """Original list price"""
  original_list_price: Float!

  """Property description"""
  property_desc: String!

  """Sqft"""
  sqft: Float!

  """Sold date"""
  sold_date: DateTime

  """Sold Price"""
  sold_price: Float

  """Stories"""
  stories: Int

  """Tax year"""
  tax_year: Int

  """Tax"""
  tax: Float

  """Total floor"""
  total_floor: Int

  """Total garage"""
  total_garage: Float!

  """Total parking"""
  total_parking: Float!

  """Total photos"""
  total_photos: Int!

  """Total rooms"""
  total_rooms: Int!

  """Total units"""
  total_units: Int!

  """Unit floor"""
  unit_floor: Int

  """Year built"""
  yearbuilt: Int

  """Office id"""
  office_id: String

  """Agent id"""
  agent_id: String!

  """Co agent id"""
  co_agent_id: String

  """Co agent name"""
  co_agent_name: String

  """Co list agent email"""
  co_list_agent_email: String

  """Co list agent full name"""
  co_list_agent_full_name: String

  """Co office id"""
  co_office_id: String

  """Co office name"""
  co_office_name: String

  """Buyer agent id"""
  buyer_agent_id: String

  """Seller agent id"""
  seller_agent_id: String

  """Area"""
  area: String

  """Baths full"""
  baths_full: Int

  """Baths half"""
  baths_half: Int

  """Elementary school"""
  elementary_school: String!

  """Garage"""
  garage: Float

  """Heating"""
  heating: String

  """High school"""
  high_school: String

  """Is openhouse"""
  is_openhouse: String

  """Is reo"""
  is_reo: String

  """Is shortsale"""
  is_shortsale: String

  """Is spa"""
  is_spa: String

  """Is waterfront"""
  is_waterfront: String

  """Middle school"""
  middle_school: String

  """Parking features"""
  parking_features: String
}

type RetsListingCreateOutput {
  """Unique ID of the market type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """Listing key"""
  listing_key: String

  """Price difference"""
  price_diff: Float

  """Picture downloaded"""
  pic_downloaded: DateTime

  """Picture download error"""
  pic_download_error: DateTime

  """Picture updated"""
  pic_updated: DateTime

  """Latlong downloaded"""
  latlong_downloaded: DateTime

  """Third Party api platform"""
  latlong_tppltf_id: Int

  """When record is created, date-time will be saved."""
  created_timestamp: DateTime

  """Property status"""
  property_status: String

  """Property style"""
  property_style: String

  """Property type"""
  property_type: String

  """Subtype"""
  subtype: String

  """Display address"""
  display_address: String

  """address"""
  address: String

  """Unit no"""
  unit_no: String

  """Street dir prefix"""
  street_dir_prefix: String

  """Street dir suffix"""
  street_dir_suffix: String

  """Street number modifier"""
  street_number_modifier: String

  """Street name"""
  street_name: String

  """Street number"""
  street_number: String

  """Street suffix"""
  street_suffix: String

  """City name"""
  city_name: String

  """State"""
  state: String

  """Zipcode"""
  zipcode: String

  """County"""
  county: String

  """Sub Condo Name"""
  sub_condo_name: String

  """Subdivision"""
  subdivision: String

  """Baths"""
  baths: Int

  """Beds"""
  beds: Int

  """Dom"""
  dom: Int

  """Listing Date"""
  listing_date: DateTime

  """Last Photo Date"""
  last_photo_date: DateTime

  """Last Update Date"""
  last_update_date: DateTime

  """Latitude"""
  latitude: Float

  """Longitude"""
  longitude: Float

  """List price"""
  list_price: Float!

  """Lot size"""
  lot_size: Float

  """Main sqft"""
  main_sqft: Float

  """Main photo url"""
  main_photo_url: String

  """Original entry timestamp"""
  original_entry_timestamp: DateTime

  """Original list price"""
  original_list_price: Float

  """Property description"""
  property_desc: String

  """Sqft"""
  sqft: Float

  """Sold date"""
  sold_date: DateTime

  """Sold Price"""
  sold_price: Float

  """Stories"""
  stories: Int

  """Tax year"""
  tax_year: Int

  """Tax"""
  tax: Float

  """Total floor"""
  total_floor: Int

  """Total garage"""
  total_garage: Float

  """Total parking"""
  total_parking: Float

  """Total photos"""
  total_photos: Int

  """Total rooms"""
  total_rooms: Int

  """Total units"""
  total_units: Int

  """Unit floor"""
  unit_floor: Int

  """Year built"""
  yearbuilt: Int

  """Office id"""
  office_id: String

  """Agent id"""
  agent_id: String

  """Co agent id"""
  co_agent_id: String

  """Co agent name"""
  co_agent_name: String

  """Co list agent email"""
  co_list_agent_email: String

  """Co list agent full name"""
  co_list_agent_full_name: String

  """Co office id"""
  co_office_id: String

  """Co office name"""
  co_office_name: String

  """Buyer agent id"""
  buyer_agent_id: String

  """Seller agent id"""
  seller_agent_id: String

  """Area"""
  area: String

  """Baths full"""
  baths_full: Int

  """Baths half"""
  baths_half: Int

  """Elementary school"""
  elementary_school: String

  """Garage"""
  garage: Float

  """Heating"""
  heating: String

  """High school"""
  high_school: String

  """Is openhouse"""
  is_openhouse: String

  """Is reo"""
  is_reo: String

  """Is shortsale"""
  is_shortsale: String

  """Is spa"""
  is_spa: String

  """Is waterfront"""
  is_waterfront: String

  """Middle school"""
  middle_school: String

  """Parking features"""
  parking_features: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing."""
  fr_mlsp_id: RetsMlsProviderEntity

  """Third party platform of the rets listing."""
  fr_third_party_platform: ThirdPartyPlatformEntity
}

input RetsListingDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingDeleteInputWhere!]
}

input RetsListingDeleteInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Listing key"""
  listing_key: FindOperatorDto

  """Price difference"""
  price_diff: FindOperatorDto

  """Picture downloaded"""
  pic_downloaded: FindOperatorDto

  """Picture download error"""
  pic_download_error: FindOperatorDto

  """Latlong downloaded"""
  latlong_downloaded: FindOperatorDto

  """When record is created, date-time will be saved."""
  created_timestamp: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Property status"""
  property_status: FindOperatorDto

  """Property style"""
  property_style: FindOperatorDto

  """Property type"""
  property_type: FindOperatorDto

  """Subtype"""
  subtype: FindOperatorDto

  """Display address"""
  display_address: FindOperatorDto

  """address"""
  address: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Street dir suffix"""
  street_dir_suffix: FindOperatorDto

  """Street name"""
  street_name: FindOperatorDto

  """Street number"""
  street_number: FindOperatorDto

  """Street suffix"""
  street_suffix: FindOperatorDto

  """City name"""
  city_name: FindOperatorDto

  """State"""
  state: FindOperatorDto

  """Zipcode"""
  zipcode: FindOperatorDto

  """County"""
  county: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """Dom"""
  dom: FindOperatorDto

  """Listing Date"""
  listing_date: FindOperatorDto

  """Last Photo Date"""
  last_photo_date: FindOperatorDto

  """Last Update Date"""
  last_update_date: FindOperatorDto

  """Latitude"""
  latitude: FindOperatorDto

  """Longitude"""
  longitude: FindOperatorDto

  """List price"""
  list_price: FindOperatorDto

  """Lot size"""
  lot_size: FindOperatorDto

  """Main photo url"""
  main_photo_url: FindOperatorDto

  """Original entry timestamp"""
  original_entry_timestamp: FindOperatorDto

  """Original list price"""
  original_list_price: FindOperatorDto

  """Sqft"""
  sqft: FindOperatorDto

  """Sold date"""
  sold_date: FindOperatorDto

  """Sold Price"""
  sold_price: FindOperatorDto

  """Total floor"""
  total_floor: FindOperatorDto

  """Total garage"""
  total_garage: FindOperatorDto

  """Total parking"""
  total_parking: FindOperatorDto

  """Total photos"""
  total_photos: FindOperatorDto

  """Total rooms"""
  total_rooms: FindOperatorDto

  """Total units"""
  total_units: FindOperatorDto

  """Unit floor"""
  unit_floor: FindOperatorDto

  """Year built"""
  yearbuilt: FindOperatorDto

  """Office id"""
  office_id: FindOperatorDto

  """Agent id"""
  agent_id: FindOperatorDto

  """Co agent id"""
  co_agent_id: FindOperatorDto

  """Co agent name"""
  co_agent_name: FindOperatorDto

  """Co list agent email"""
  co_list_agent_email: FindOperatorDto

  """Co office id"""
  co_office_id: FindOperatorDto

  """Buyer agent id"""
  buyer_agent_id: FindOperatorDto

  """Seller agent id"""
  seller_agent_id: FindOperatorDto

  """Area"""
  area: FindOperatorDto

  """Baths full"""
  baths_full: FindOperatorDto

  """Baths half"""
  baths_half: FindOperatorDto

  """Is openhouse"""
  is_openhouse: FindOperatorDto

  """Is spa"""
  is_spa: FindOperatorDto

  """Is waterfront"""
  is_waterfront: FindOperatorDto

  """MLSP ID of the rets listing."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsListingEntity {
  """Unique ID of the market type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """Listing key"""
  listing_key: String

  """Price difference"""
  price_diff: Float

  """Picture downloaded"""
  pic_downloaded: DateTime

  """Picture download error"""
  pic_download_error: DateTime

  """Picture updated"""
  pic_updated: DateTime

  """Latlong downloaded"""
  latlong_downloaded: DateTime

  """Third Party api platform"""
  latlong_tppltf_id: Int

  """When record is created, date-time will be saved."""
  created_timestamp: DateTime

  """Property status"""
  property_status: String

  """Property style"""
  property_style: String

  """Property type"""
  property_type: String

  """Subtype"""
  subtype: String

  """Display address"""
  display_address: String

  """address"""
  address: String

  """Unit no"""
  unit_no: String

  """Street dir prefix"""
  street_dir_prefix: String

  """Street dir suffix"""
  street_dir_suffix: String

  """Street number modifier"""
  street_number_modifier: String

  """Street name"""
  street_name: String

  """Street number"""
  street_number: String

  """Street suffix"""
  street_suffix: String

  """City name"""
  city_name: String

  """State"""
  state: String

  """Zipcode"""
  zipcode: String

  """County"""
  county: String

  """Sub Condo Name"""
  sub_condo_name: String

  """Subdivision"""
  subdivision: String

  """Baths"""
  baths: Int

  """Beds"""
  beds: Int

  """Dom"""
  dom: Int

  """Listing Date"""
  listing_date: DateTime

  """Last Photo Date"""
  last_photo_date: DateTime

  """Last Update Date"""
  last_update_date: DateTime

  """Latitude"""
  latitude: Float

  """Longitude"""
  longitude: Float

  """List price"""
  list_price: Float!

  """Lot size"""
  lot_size: Float

  """Main sqft"""
  main_sqft: Float

  """Main photo url"""
  main_photo_url: String

  """Original entry timestamp"""
  original_entry_timestamp: DateTime

  """Original list price"""
  original_list_price: Float

  """Property description"""
  property_desc: String

  """Sqft"""
  sqft: Float

  """Sold date"""
  sold_date: DateTime

  """Sold Price"""
  sold_price: Float

  """Stories"""
  stories: Int

  """Tax year"""
  tax_year: Int

  """Tax"""
  tax: Float

  """Total floor"""
  total_floor: Int

  """Total garage"""
  total_garage: Float

  """Total parking"""
  total_parking: Float

  """Total photos"""
  total_photos: Int

  """Total rooms"""
  total_rooms: Int

  """Total units"""
  total_units: Int

  """Unit floor"""
  unit_floor: Int

  """Year built"""
  yearbuilt: Int

  """Office id"""
  office_id: String

  """Agent id"""
  agent_id: String

  """Co agent id"""
  co_agent_id: String

  """Co agent name"""
  co_agent_name: String

  """Co list agent email"""
  co_list_agent_email: String

  """Co list agent full name"""
  co_list_agent_full_name: String

  """Co office id"""
  co_office_id: String

  """Co office name"""
  co_office_name: String

  """Buyer agent id"""
  buyer_agent_id: String

  """Seller agent id"""
  seller_agent_id: String

  """Area"""
  area: String

  """Baths full"""
  baths_full: Int

  """Baths half"""
  baths_half: Int

  """Elementary school"""
  elementary_school: String

  """Garage"""
  garage: Float

  """Heating"""
  heating: String

  """High school"""
  high_school: String

  """Is openhouse"""
  is_openhouse: String

  """Is reo"""
  is_reo: String

  """Is shortsale"""
  is_shortsale: String

  """Is spa"""
  is_spa: String

  """Is waterfront"""
  is_waterfront: String

  """Middle school"""
  middle_school: String

  """Parking features"""
  parking_features: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing."""
  fr_mlsp_id: RetsMlsProviderEntity

  """Third party platform of the rets listing."""
  fr_third_party_platform: ThirdPartyPlatformEntity
}

input RetsListingFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsListingFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsListingFindInputSortOrder
}

input RetsListingFindInputGroupBy {
  mlsp_id: Boolean
  mls_num: Boolean
  listing_key: Boolean
  price_diff: Boolean
  pic_downloaded: Boolean
  pic_download_error: Boolean
  pic_updated: Boolean
  latlong_downloaded: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
  property_status: Boolean
  property_style: Boolean
  property_type: Boolean
  subtype: Boolean
  display_address: Boolean
  address: Boolean
  unit_no: Boolean
  street_dir_suffix: Boolean
  street_name: Boolean
  street_number: Boolean
  street_suffix: Boolean
  city_name: Boolean
  state: Boolean
  zipcode: Boolean
  county: Boolean
  baths: Boolean
  beds: Boolean
  dom: Boolean
  listing_date: Boolean
  last_photo_date: Boolean
  latitude: Boolean
  longitude: Boolean
  list_price: Boolean
  lot_size: Boolean
  main_photo_url: Boolean
  original_entry_timestamp: Boolean
  original_list_price: Boolean
  sqft: Boolean
  sold_date: Boolean
  sold_price: Boolean
  total_floor: Boolean
  total_garage: Boolean
  total_parking: Boolean
  total_photos: Boolean
  total_rooms: Boolean
  total_units: Boolean
  yearbuilt: Boolean
  office_id: Boolean
  agent_id: Boolean
  area: Boolean
  baths_full: Boolean
  baths_half: Boolean
}

input RetsListingFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  listing_key: RecordSortDirectionEnum
  price_diff: RecordSortDirectionEnum
  pic_downloaded: RecordSortDirectionEnum
  pic_download_error: RecordSortDirectionEnum
  pic_updated: RecordSortDirectionEnum
  latlong_downloaded: RecordSortDirectionEnum
  created_timestamp: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
  property_status: RecordSortDirectionEnum
  property_style: RecordSortDirectionEnum
  property_type: RecordSortDirectionEnum
  subtype: RecordSortDirectionEnum
  display_address: RecordSortDirectionEnum
  address: RecordSortDirectionEnum
  unit_no: RecordSortDirectionEnum
  street_dir_suffix: RecordSortDirectionEnum
  street_name: RecordSortDirectionEnum
  street_number: RecordSortDirectionEnum
  street_suffix: RecordSortDirectionEnum
  city_name: RecordSortDirectionEnum
  state: RecordSortDirectionEnum
  zipcode: RecordSortDirectionEnum
  county: RecordSortDirectionEnum
  baths: RecordSortDirectionEnum
  beds: RecordSortDirectionEnum
  dom: RecordSortDirectionEnum
  listing_date: RecordSortDirectionEnum
  last_photo_date: RecordSortDirectionEnum
  last_update_date: RecordSortDirectionEnum
  latitude: RecordSortDirectionEnum
  longitude: RecordSortDirectionEnum
  list_price: RecordSortDirectionEnum
  lot_size: RecordSortDirectionEnum
  main_photo_url: RecordSortDirectionEnum
  original_entry_timestamp: RecordSortDirectionEnum
  original_list_price: RecordSortDirectionEnum
  sqft: RecordSortDirectionEnum
  sold_date: RecordSortDirectionEnum
  sold_price: RecordSortDirectionEnum
  total_floor: RecordSortDirectionEnum
  total_garage: RecordSortDirectionEnum
  total_parking: RecordSortDirectionEnum
  total_photos: RecordSortDirectionEnum
  total_rooms: RecordSortDirectionEnum
  total_units: RecordSortDirectionEnum
  yearbuilt: RecordSortDirectionEnum
  office_id: RecordSortDirectionEnum
  agent_id: RecordSortDirectionEnum
  co_agent_id: RecordSortDirectionEnum
  co_agent_name: RecordSortDirectionEnum
  co_list_agent_email: RecordSortDirectionEnum
  co_office_id: RecordSortDirectionEnum
  buyer_agent_id: RecordSortDirectionEnum
  seller_agent_id: RecordSortDirectionEnum
  area: RecordSortDirectionEnum
  baths_full: RecordSortDirectionEnum
  baths_half: RecordSortDirectionEnum
  is_openhouse: RecordSortDirectionEnum
  is_spa: RecordSortDirectionEnum
  is_waterfront: RecordSortDirectionEnum
}

input RetsListingFindInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Listing key"""
  listing_key: FindOperatorDto

  """Price difference"""
  price_diff: FindOperatorDto

  """Picture downloaded"""
  pic_downloaded: FindOperatorDto

  """Picture download error"""
  pic_download_error: FindOperatorDto

  """Latlong downloaded"""
  latlong_downloaded: FindOperatorDto

  """When record is created, date-time will be saved."""
  created_timestamp: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Property status"""
  property_status: FindOperatorDto

  """Property style"""
  property_style: FindOperatorDto

  """Property type"""
  property_type: FindOperatorDto

  """Subtype"""
  subtype: FindOperatorDto

  """Display address"""
  display_address: FindOperatorDto

  """address"""
  address: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Street dir suffix"""
  street_dir_suffix: FindOperatorDto

  """Street name"""
  street_name: FindOperatorDto

  """Street number"""
  street_number: FindOperatorDto

  """Street suffix"""
  street_suffix: FindOperatorDto

  """City name"""
  city_name: FindOperatorDto

  """State"""
  state: FindOperatorDto

  """Zipcode"""
  zipcode: FindOperatorDto

  """County"""
  county: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """Dom"""
  dom: FindOperatorDto

  """Listing Date"""
  listing_date: FindOperatorDto

  """Last Photo Date"""
  last_photo_date: FindOperatorDto

  """Last Update Date"""
  last_update_date: FindOperatorDto

  """Latitude"""
  latitude: FindOperatorDto

  """Longitude"""
  longitude: FindOperatorDto

  """List price"""
  list_price: FindOperatorDto

  """Lot size"""
  lot_size: FindOperatorDto

  """Main photo url"""
  main_photo_url: FindOperatorDto

  """Original entry timestamp"""
  original_entry_timestamp: FindOperatorDto

  """Original list price"""
  original_list_price: FindOperatorDto

  """Sqft"""
  sqft: FindOperatorDto

  """Sold date"""
  sold_date: FindOperatorDto

  """Sold Price"""
  sold_price: FindOperatorDto

  """Total floor"""
  total_floor: FindOperatorDto

  """Total garage"""
  total_garage: FindOperatorDto

  """Total parking"""
  total_parking: FindOperatorDto

  """Total photos"""
  total_photos: FindOperatorDto

  """Total rooms"""
  total_rooms: FindOperatorDto

  """Total units"""
  total_units: FindOperatorDto

  """Unit floor"""
  unit_floor: FindOperatorDto

  """Year built"""
  yearbuilt: FindOperatorDto

  """Office id"""
  office_id: FindOperatorDto

  """Agent id"""
  agent_id: FindOperatorDto

  """Co agent id"""
  co_agent_id: FindOperatorDto

  """Co agent name"""
  co_agent_name: FindOperatorDto

  """Co list agent email"""
  co_list_agent_email: FindOperatorDto

  """Co office id"""
  co_office_id: FindOperatorDto

  """Buyer agent id"""
  buyer_agent_id: FindOperatorDto

  """Seller agent id"""
  seller_agent_id: FindOperatorDto

  """Area"""
  area: FindOperatorDto

  """Baths full"""
  baths_full: FindOperatorDto

  """Baths half"""
  baths_half: FindOperatorDto

  """Is openhouse"""
  is_openhouse: FindOperatorDto

  """Is spa"""
  is_spa: FindOperatorDto

  """Is waterfront"""
  is_waterfront: FindOperatorDto

  """MLSP ID of the rets listing."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input RetsListingFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsListingFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsListingEntity!]!
}

input RetsListingMetadataCreateInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Resource"""
  resource: String!

  """Class"""
  class: String!

  """Lookup Name"""
  lookup_name: String!

  """Lookup field"""
  lookup_field: String!

  """Field Name"""
  field_name: String!

  """Long Value"""
  long_value: String

  """Short Value"""
  short_value: String

  """Id Value"""
  id_value: String!
}

type RetsListingMetadataCreateOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Resource"""
  resource: String

  """Class"""
  class: String

  """Lookup Name"""
  lookup_name: String

  """Lookup field"""
  lookup_field: String

  """Field Name"""
  field_name: String

  """Long Value"""
  long_value: String

  """Short Value"""
  short_value: String

  """Id Value"""
  id_value: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input RetsListingMetadataDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingMetadataDeleteInputWhere!]
}

input RetsListingMetadataDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource"""
  resource: FindOperatorDto

  """Class"""
  class: FindOperatorDto

  """Lookup Name"""
  lookup_name: FindOperatorDto

  """Lookup field"""
  lookup_field: FindOperatorDto

  """Field Name"""
  field_name: FindOperatorDto

  """Id Value"""
  id_value: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsListingMetadataDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsListingMetadataEntity {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Resource"""
  resource: String

  """Class"""
  class: String

  """Lookup Name"""
  lookup_name: String

  """Lookup field"""
  lookup_field: String

  """Field Name"""
  field_name: String

  """Long Value"""
  long_value: String

  """Short Value"""
  short_value: String

  """Id Value"""
  id_value: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input RetsListingMetadataFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingMetadataFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsListingMetadataFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsListingMetadataFindInputSortOrder
}

input RetsListingMetadataFindInputGroupBy {
  mlsp_id: Boolean
  resource: Boolean
  class: Boolean
  lookup_name: Boolean
  lookup_field: Boolean
  field_name: Boolean
  id_value: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input RetsListingMetadataFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  resource: RecordSortDirectionEnum
  class: RecordSortDirectionEnum
  lookup_name: RecordSortDirectionEnum
  lookup_field: RecordSortDirectionEnum
  field_name: RecordSortDirectionEnum
  id_value: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input RetsListingMetadataFindInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource"""
  resource: FindOperatorDto

  """Class"""
  class: FindOperatorDto

  """Lookup Name"""
  lookup_name: FindOperatorDto

  """Lookup field"""
  lookup_field: FindOperatorDto

  """Field Name"""
  field_name: FindOperatorDto

  """Id Value"""
  id_value: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

input RetsListingMetadataFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsListingMetadataFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsListingMetadataEntity!]!
}

input RetsListingMetadataRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingMetadataRecoverInputWhere!]
}

input RetsListingMetadataRecoverInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource"""
  resource: FindOperatorDto

  """Class"""
  class: FindOperatorDto

  """Lookup Name"""
  lookup_name: FindOperatorDto

  """Lookup field"""
  lookup_field: FindOperatorDto

  """Field Name"""
  field_name: FindOperatorDto

  """Id Value"""
  id_value: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsListingMetadataRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingMetadataEntity!]!
}

input RetsListingMetadataRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingMetadataRemoveInputWhere!]
}

input RetsListingMetadataRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource"""
  resource: FindOperatorDto

  """Class"""
  class: FindOperatorDto

  """Lookup Name"""
  lookup_name: FindOperatorDto

  """Lookup field"""
  lookup_field: FindOperatorDto

  """Field Name"""
  field_name: FindOperatorDto

  """Id Value"""
  id_value: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsListingMetadataRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingMetadataEntity!]!
}

input RetsListingMetadataRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingMetadataRestoreInputWhere!]
}

input RetsListingMetadataRestoreInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource"""
  resource: FindOperatorDto

  """Class"""
  class: FindOperatorDto

  """Lookup Name"""
  lookup_name: FindOperatorDto

  """Lookup field"""
  lookup_field: FindOperatorDto

  """Field Name"""
  field_name: FindOperatorDto

  """Id Value"""
  id_value: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsListingMetadataRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingMetadataSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingMetadataSoftDeleteInputWhere!]
}

input RetsListingMetadataSoftDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource"""
  resource: FindOperatorDto

  """Class"""
  class: FindOperatorDto

  """Lookup Name"""
  lookup_name: FindOperatorDto

  """Lookup field"""
  lookup_field: FindOperatorDto

  """Field Name"""
  field_name: FindOperatorDto

  """Id Value"""
  id_value: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsListingMetadataSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingMetadataSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingMetadataSoftRemoveInputWhere!]
}

input RetsListingMetadataSoftRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource"""
  resource: FindOperatorDto

  """Class"""
  class: FindOperatorDto

  """Lookup Name"""
  lookup_name: FindOperatorDto

  """Lookup field"""
  lookup_field: FindOperatorDto

  """Field Name"""
  field_name: FindOperatorDto

  """Id Value"""
  id_value: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsListingMetadataSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingMetadataEntity!]!
}

input RetsListingMetadataUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingMetadataUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsListingMetadataUpdateInputSets!
}

input RetsListingMetadataUpdateInputSets {
  """MLS Service Provider ID"""
  mlsp_id: Int

  """Resource"""
  resource: String

  """Class"""
  class: String

  """Lookup Name"""
  lookup_name: String

  """Lookup field"""
  lookup_field: String

  """Field Name"""
  field_name: String

  """Long Value"""
  long_value: String

  """Short Value"""
  short_value: String

  """Id Value"""
  id_value: String
}

input RetsListingMetadataUpdateInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource"""
  resource: FindOperatorDto

  """Class"""
  class: FindOperatorDto

  """Lookup Name"""
  lookup_name: FindOperatorDto

  """Lookup field"""
  lookup_field: FindOperatorDto

  """Field Name"""
  field_name: FindOperatorDto

  """Id Value"""
  id_value: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsListingMetadataUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsListingMetadataEntity!]!
}

input RetsListingMetadataUpsertInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Resource"""
  resource: String!

  """Class"""
  class: String!

  """Lookup Name"""
  lookup_name: String!

  """Lookup field"""
  lookup_field: String!

  """Field Name"""
  field_name: String!

  """Long Value"""
  long_value: String

  """Short Value"""
  short_value: String

  """Id Value"""
  id_value: String!

  """Unique ID of the listing office type, auto generated. undefined"""
  id: Int
}

type RetsListingMetadataUpsertOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Resource"""
  resource: String

  """Class"""
  class: String

  """Lookup Name"""
  lookup_name: String

  """Lookup field"""
  lookup_field: String

  """Field Name"""
  field_name: String

  """Long Value"""
  long_value: String

  """Short Value"""
  short_value: String

  """Id Value"""
  id_value: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsListingOfficeCreateInput {
  """Office ID of Listing Agent"""
  office_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Office Name"""
  office_name: String!

  """Office Email"""
  office_email: String

  """Office Phone"""
  office_phone: String

  """Office Last Updated Date"""
  office_last_updated_date: DateTime
}

type RetsListingOfficeCreateOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """Office ID of Listing Agent"""
  office_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Office Name"""
  office_name: String

  """Office Email"""
  office_email: String

  """Office Phone"""
  office_phone: String

  """Office Last Updated Date"""
  office_last_updated_date: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing office."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingOfficeDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOfficeDeleteInputWhere!]
}

input RetsListingOfficeDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """Office ID of Listing Agent"""
  office_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Office Name"""
  office_name: FindOperatorDto

  """Office Email"""
  office_email: FindOperatorDto

  """Office Phone"""
  office_phone: FindOperatorDto

  """Office Last Updated Date"""
  office_last_updated_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing office."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOfficeDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsListingOfficeEntity {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """Office ID of Listing Agent"""
  office_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Office Name"""
  office_name: String

  """Office Email"""
  office_email: String

  """Office Phone"""
  office_phone: String

  """Office Last Updated Date"""
  office_last_updated_date: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing office."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingOfficeFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOfficeFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsListingOfficeFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsListingOfficeFindInputSortOrder
}

input RetsListingOfficeFindInputGroupBy {
  office_id: Boolean
  mlsp_id: Boolean
  office_name: Boolean
  office_email: Boolean
  office_phone: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input RetsListingOfficeFindInputSortOrder {
  id: RecordSortDirectionEnum
  office_id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  office_name: RecordSortDirectionEnum
  office_email: RecordSortDirectionEnum
  office_phone: RecordSortDirectionEnum
  office_last_updated_date: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input RetsListingOfficeFindInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """Office ID of Listing Agent"""
  office_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Office Name"""
  office_name: FindOperatorDto

  """Office Email"""
  office_email: FindOperatorDto

  """Office Phone"""
  office_phone: FindOperatorDto

  """Office Last Updated Date"""
  office_last_updated_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing office."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input RetsListingOfficeFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsListingOfficeFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsListingOfficeEntity!]!
}

input RetsListingOfficeRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOfficeRecoverInputWhere!]
}

input RetsListingOfficeRecoverInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """Office ID of Listing Agent"""
  office_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Office Name"""
  office_name: FindOperatorDto

  """Office Email"""
  office_email: FindOperatorDto

  """Office Phone"""
  office_phone: FindOperatorDto

  """Office Last Updated Date"""
  office_last_updated_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing office."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOfficeRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingOfficeEntity!]!
}

input RetsListingOfficeRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOfficeRemoveInputWhere!]
}

input RetsListingOfficeRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """Office ID of Listing Agent"""
  office_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Office Name"""
  office_name: FindOperatorDto

  """Office Email"""
  office_email: FindOperatorDto

  """Office Phone"""
  office_phone: FindOperatorDto

  """Office Last Updated Date"""
  office_last_updated_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing office."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOfficeRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingOfficeEntity!]!
}

input RetsListingOfficeRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOfficeRestoreInputWhere!]
}

input RetsListingOfficeRestoreInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """Office ID of Listing Agent"""
  office_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Office Name"""
  office_name: FindOperatorDto

  """Office Email"""
  office_email: FindOperatorDto

  """Office Phone"""
  office_phone: FindOperatorDto

  """Office Last Updated Date"""
  office_last_updated_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing office."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOfficeRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingOfficeSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOfficeSoftDeleteInputWhere!]
}

input RetsListingOfficeSoftDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """Office ID of Listing Agent"""
  office_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Office Name"""
  office_name: FindOperatorDto

  """Office Email"""
  office_email: FindOperatorDto

  """Office Phone"""
  office_phone: FindOperatorDto

  """Office Last Updated Date"""
  office_last_updated_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing office."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOfficeSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingOfficeSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOfficeSoftRemoveInputWhere!]
}

input RetsListingOfficeSoftRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """Office ID of Listing Agent"""
  office_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Office Name"""
  office_name: FindOperatorDto

  """Office Email"""
  office_email: FindOperatorDto

  """Office Phone"""
  office_phone: FindOperatorDto

  """Office Last Updated Date"""
  office_last_updated_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing office."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOfficeSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingOfficeEntity!]!
}

input RetsListingOfficeUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOfficeUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsListingOfficeUpdateInputSets!
}

input RetsListingOfficeUpdateInputSets {
  """Office ID of Listing Agent"""
  office_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Office Name"""
  office_name: String

  """Office Email"""
  office_email: String

  """Office Phone"""
  office_phone: String

  """Office Last Updated Date"""
  office_last_updated_date: DateTime
}

input RetsListingOfficeUpdateInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """Office ID of Listing Agent"""
  office_id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Office Name"""
  office_name: FindOperatorDto

  """Office Email"""
  office_email: FindOperatorDto

  """Office Phone"""
  office_phone: FindOperatorDto

  """Office Last Updated Date"""
  office_last_updated_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing office."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOfficeUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsListingOfficeEntity!]!
}

input RetsListingOfficeUpsertInput {
  """Office ID of Listing Agent"""
  office_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Office Name"""
  office_name: String!

  """Office Email"""
  office_email: String

  """Office Phone"""
  office_phone: String

  """Office Last Updated Date"""
  office_last_updated_date: DateTime

  """Unique ID of the listing office type, auto generated. undefined"""
  id: Int
}

type RetsListingOfficeUpsertOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """Office ID of Listing Agent"""
  office_id: String

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Office Name"""
  office_name: String

  """Office Email"""
  office_email: String

  """Office Phone"""
  office_phone: String

  """Office Last Updated Date"""
  office_last_updated_date: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing office."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsListingOpenHouseCreateInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Unique ID of Listing"""
  mls_num: String!

  """Open house Start Time"""
  oh_begins: DateTime

  """Open house Close Time"""
  oh_close: DateTime

  """Open house Display Time"""
  oh_display_time: DateTime

  """Open house Date"""
  oh_date: DateTime
}

type RetsListingOpenHouseCreateOutput {
  """Unique ID of the market type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """Open house Start Time"""
  oh_begins: DateTime

  """Open house Close Time"""
  oh_close: DateTime

  """Open house Display Time"""
  oh_display_time: DateTime

  """Open house Date"""
  oh_date: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing open house."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingOpenHouseDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOpenHouseDeleteInputWhere!]
}

input RetsListingOpenHouseDeleteInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Open house Start Time"""
  oh_begins: FindOperatorDto

  """Open house Close Time"""
  oh_close: FindOperatorDto

  """Open house Date"""
  oh_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing open house."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOpenHouseDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsListingOpenHouseEntity {
  """Unique ID of the market type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """Open house Start Time"""
  oh_begins: DateTime

  """Open house Close Time"""
  oh_close: DateTime

  """Open house Display Time"""
  oh_display_time: DateTime

  """Open house Date"""
  oh_date: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing open house."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingOpenHouseFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOpenHouseFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsListingOpenHouseFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsListingOpenHouseFindInputSortOrder
}

input RetsListingOpenHouseFindInputGroupBy {
  mlsp_id: Boolean
  oh_begins: Boolean
  oh_close: Boolean
  oh_date: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input RetsListingOpenHouseFindInputSortOrder {
  id: RecordSortDirectionEnum
  oh_begins: RecordSortDirectionEnum
  oh_close: RecordSortDirectionEnum
  oh_date: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input RetsListingOpenHouseFindInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Open house Start Time"""
  oh_begins: FindOperatorDto

  """Open house Close Time"""
  oh_close: FindOperatorDto

  """Open house Date"""
  oh_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing open house."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input RetsListingOpenHouseFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsListingOpenHouseFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsListingOpenHouseEntity!]!
}

input RetsListingOpenHouseRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOpenHouseRecoverInputWhere!]
}

input RetsListingOpenHouseRecoverInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Open house Start Time"""
  oh_begins: FindOperatorDto

  """Open house Close Time"""
  oh_close: FindOperatorDto

  """Open house Date"""
  oh_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing open house."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOpenHouseRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingOpenHouseEntity!]!
}

input RetsListingOpenHouseRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOpenHouseRemoveInputWhere!]
}

input RetsListingOpenHouseRemoveInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Open house Start Time"""
  oh_begins: FindOperatorDto

  """Open house Close Time"""
  oh_close: FindOperatorDto

  """Open house Date"""
  oh_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing open house."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOpenHouseRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingOpenHouseEntity!]!
}

input RetsListingOpenHouseRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOpenHouseRestoreInputWhere!]
}

input RetsListingOpenHouseRestoreInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Open house Start Time"""
  oh_begins: FindOperatorDto

  """Open house Close Time"""
  oh_close: FindOperatorDto

  """Open house Date"""
  oh_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing open house."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOpenHouseRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingOpenHouseSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOpenHouseSoftDeleteInputWhere!]
}

input RetsListingOpenHouseSoftDeleteInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Open house Start Time"""
  oh_begins: FindOperatorDto

  """Open house Close Time"""
  oh_close: FindOperatorDto

  """Open house Date"""
  oh_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing open house."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOpenHouseSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingOpenHouseSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOpenHouseSoftRemoveInputWhere!]
}

input RetsListingOpenHouseSoftRemoveInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Open house Start Time"""
  oh_begins: FindOperatorDto

  """Open house Close Time"""
  oh_close: FindOperatorDto

  """Open house Date"""
  oh_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing open house."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOpenHouseSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingOpenHouseEntity!]!
}

input RetsListingOpenHouseUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingOpenHouseUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsListingOpenHouseUpdateInputSets!
}

input RetsListingOpenHouseUpdateInputSets {
  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """Open house Start Time"""
  oh_begins: DateTime

  """Open house Close Time"""
  oh_close: DateTime

  """Open house Display Time"""
  oh_display_time: DateTime

  """Open house Date"""
  oh_date: DateTime
}

input RetsListingOpenHouseUpdateInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Open house Start Time"""
  oh_begins: FindOperatorDto

  """Open house Close Time"""
  oh_close: FindOperatorDto

  """Open house Date"""
  oh_date: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing open house."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingOpenHouseUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsListingOpenHouseEntity!]!
}

input RetsListingOpenHouseUpsertInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Unique ID of Listing"""
  mls_num: String!

  """Open house Start Time"""
  oh_begins: DateTime

  """Open house Close Time"""
  oh_close: DateTime

  """Open house Display Time"""
  oh_display_time: DateTime

  """Open house Date"""
  oh_date: DateTime

  """Unique ID of the market type, auto generated. undefined"""
  id: Int
}

type RetsListingOpenHouseUpsertOutput {
  """Unique ID of the market type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """Open house Start Time"""
  oh_begins: DateTime

  """Open house Close Time"""
  oh_close: DateTime

  """Open house Display Time"""
  oh_display_time: DateTime

  """Open house Date"""
  oh_date: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing open house."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsListingPhotosCreateInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """MLS Number"""
  mls_num: String!

  """Listing Key"""
  listing_key: String!

  """Media Type"""
  media_type: String

  """Media Item Number"""
  media_item_number: String

  """Media Display Order"""
  media_display_order: Int

  """Media Caption"""
  media_caption: String

  """Media Description"""
  media_description: String

  """Media Url"""
  media_url: String

  """Media Last Update"""
  media_last_update: DateTime
}

type RetsListingPhotosCreateOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """MLS Number"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Media Type"""
  media_type: String

  """Media Item Number"""
  media_item_number: String

  """Media Display Order"""
  media_display_order: Int

  """Media Caption"""
  media_caption: String

  """Media Description"""
  media_description: String

  """Media Url"""
  media_url: String

  """Media Last Update"""
  media_last_update: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing photos."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingPhotosDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingPhotosDeleteInputWhere!]
}

input RetsListingPhotosDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """MLS Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Media Item Number"""
  media_item_number: FindOperatorDto

  """Media Last Update"""
  media_last_update: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing photos."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingPhotosDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsListingPhotosEntity {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """MLS Number"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Media Type"""
  media_type: String

  """Media Item Number"""
  media_item_number: String

  """Media Display Order"""
  media_display_order: Int

  """Media Caption"""
  media_caption: String

  """Media Description"""
  media_description: String

  """Media Url"""
  media_url: String

  """Media Last Update"""
  media_last_update: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing photos."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingPhotosFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingPhotosFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsListingPhotosFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsListingPhotosFindInputSortOrder
}

input RetsListingPhotosFindInputGroupBy {
  mlsp_id: Boolean
  mls_num: Boolean
  listing_key: Boolean
  media_last_update: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input RetsListingPhotosFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  listing_key: RecordSortDirectionEnum
  media_item_number: RecordSortDirectionEnum
  media_last_update: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input RetsListingPhotosFindInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """MLS Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Media Item Number"""
  media_item_number: FindOperatorDto

  """Media Last Update"""
  media_last_update: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing photos."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input RetsListingPhotosFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsListingPhotosFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsListingPhotosEntity!]!
}

input RetsListingPhotosRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingPhotosRecoverInputWhere!]
}

input RetsListingPhotosRecoverInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """MLS Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Media Item Number"""
  media_item_number: FindOperatorDto

  """Media Last Update"""
  media_last_update: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing photos."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingPhotosRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingPhotosEntity!]!
}

input RetsListingPhotosRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingPhotosRemoveInputWhere!]
}

input RetsListingPhotosRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """MLS Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Media Item Number"""
  media_item_number: FindOperatorDto

  """Media Last Update"""
  media_last_update: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing photos."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingPhotosRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingPhotosEntity!]!
}

input RetsListingPhotosRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingPhotosRestoreInputWhere!]
}

input RetsListingPhotosRestoreInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """MLS Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Media Item Number"""
  media_item_number: FindOperatorDto

  """Media Last Update"""
  media_last_update: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing photos."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingPhotosRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingPhotosSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingPhotosSoftDeleteInputWhere!]
}

input RetsListingPhotosSoftDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """MLS Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Media Item Number"""
  media_item_number: FindOperatorDto

  """Media Last Update"""
  media_last_update: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing photos."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingPhotosSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingPhotosSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingPhotosSoftRemoveInputWhere!]
}

input RetsListingPhotosSoftRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """MLS Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Media Item Number"""
  media_item_number: FindOperatorDto

  """Media Last Update"""
  media_last_update: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing photos."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingPhotosSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingPhotosEntity!]!
}

input RetsListingPhotosUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingPhotosUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsListingPhotosUpdateInputSets!
}

input RetsListingPhotosUpdateInputSets {
  """MLS Service Provider ID"""
  mlsp_id: Int

  """MLS Number"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Media Type"""
  media_type: String

  """Media Item Number"""
  media_item_number: String

  """Media Display Order"""
  media_display_order: Int

  """Media Caption"""
  media_caption: String

  """Media Description"""
  media_description: String

  """Media Url"""
  media_url: String

  """Media Last Update"""
  media_last_update: DateTime
}

input RetsListingPhotosUpdateInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """MLS Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Media Item Number"""
  media_item_number: FindOperatorDto

  """Media Last Update"""
  media_last_update: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing photos."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingPhotosUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsListingPhotosEntity!]!
}

input RetsListingPhotosUpsertInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """MLS Number"""
  mls_num: String!

  """Listing Key"""
  listing_key: String!

  """Media Type"""
  media_type: String

  """Media Item Number"""
  media_item_number: String

  """Media Display Order"""
  media_display_order: Int

  """Media Caption"""
  media_caption: String

  """Media Description"""
  media_description: String

  """Media Url"""
  media_url: String

  """Media Last Update"""
  media_last_update: DateTime

  """Unique ID of the listing office type, auto generated. undefined"""
  id: Int
}

type RetsListingPhotosUpsertOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """MLS Number"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Media Type"""
  media_type: String

  """Media Item Number"""
  media_item_number: String

  """Media Display Order"""
  media_display_order: Int

  """Media Caption"""
  media_caption: String

  """Media Description"""
  media_description: String

  """Media Url"""
  media_url: String

  """Media Last Update"""
  media_last_update: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing photos."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsListingRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingRecoverInputWhere!]
}

input RetsListingRecoverInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Listing key"""
  listing_key: FindOperatorDto

  """Price difference"""
  price_diff: FindOperatorDto

  """Picture downloaded"""
  pic_downloaded: FindOperatorDto

  """Picture download error"""
  pic_download_error: FindOperatorDto

  """Latlong downloaded"""
  latlong_downloaded: FindOperatorDto

  """When record is created, date-time will be saved."""
  created_timestamp: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Property status"""
  property_status: FindOperatorDto

  """Property style"""
  property_style: FindOperatorDto

  """Property type"""
  property_type: FindOperatorDto

  """Subtype"""
  subtype: FindOperatorDto

  """Display address"""
  display_address: FindOperatorDto

  """address"""
  address: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Street dir suffix"""
  street_dir_suffix: FindOperatorDto

  """Street name"""
  street_name: FindOperatorDto

  """Street number"""
  street_number: FindOperatorDto

  """Street suffix"""
  street_suffix: FindOperatorDto

  """City name"""
  city_name: FindOperatorDto

  """State"""
  state: FindOperatorDto

  """Zipcode"""
  zipcode: FindOperatorDto

  """County"""
  county: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """Dom"""
  dom: FindOperatorDto

  """Listing Date"""
  listing_date: FindOperatorDto

  """Last Photo Date"""
  last_photo_date: FindOperatorDto

  """Last Update Date"""
  last_update_date: FindOperatorDto

  """Latitude"""
  latitude: FindOperatorDto

  """Longitude"""
  longitude: FindOperatorDto

  """List price"""
  list_price: FindOperatorDto

  """Lot size"""
  lot_size: FindOperatorDto

  """Main photo url"""
  main_photo_url: FindOperatorDto

  """Original entry timestamp"""
  original_entry_timestamp: FindOperatorDto

  """Original list price"""
  original_list_price: FindOperatorDto

  """Sqft"""
  sqft: FindOperatorDto

  """Sold date"""
  sold_date: FindOperatorDto

  """Sold Price"""
  sold_price: FindOperatorDto

  """Total floor"""
  total_floor: FindOperatorDto

  """Total garage"""
  total_garage: FindOperatorDto

  """Total parking"""
  total_parking: FindOperatorDto

  """Total photos"""
  total_photos: FindOperatorDto

  """Total rooms"""
  total_rooms: FindOperatorDto

  """Total units"""
  total_units: FindOperatorDto

  """Unit floor"""
  unit_floor: FindOperatorDto

  """Year built"""
  yearbuilt: FindOperatorDto

  """Office id"""
  office_id: FindOperatorDto

  """Agent id"""
  agent_id: FindOperatorDto

  """Co agent id"""
  co_agent_id: FindOperatorDto

  """Co agent name"""
  co_agent_name: FindOperatorDto

  """Co list agent email"""
  co_list_agent_email: FindOperatorDto

  """Co office id"""
  co_office_id: FindOperatorDto

  """Buyer agent id"""
  buyer_agent_id: FindOperatorDto

  """Seller agent id"""
  seller_agent_id: FindOperatorDto

  """Area"""
  area: FindOperatorDto

  """Baths full"""
  baths_full: FindOperatorDto

  """Baths half"""
  baths_half: FindOperatorDto

  """Is openhouse"""
  is_openhouse: FindOperatorDto

  """Is spa"""
  is_spa: FindOperatorDto

  """Is waterfront"""
  is_waterfront: FindOperatorDto

  """MLSP ID of the rets listing."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingEntity!]!
}

input RetsListingRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingRemoveInputWhere!]
}

input RetsListingRemoveInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Listing key"""
  listing_key: FindOperatorDto

  """Price difference"""
  price_diff: FindOperatorDto

  """Picture downloaded"""
  pic_downloaded: FindOperatorDto

  """Picture download error"""
  pic_download_error: FindOperatorDto

  """Latlong downloaded"""
  latlong_downloaded: FindOperatorDto

  """When record is created, date-time will be saved."""
  created_timestamp: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Property status"""
  property_status: FindOperatorDto

  """Property style"""
  property_style: FindOperatorDto

  """Property type"""
  property_type: FindOperatorDto

  """Subtype"""
  subtype: FindOperatorDto

  """Display address"""
  display_address: FindOperatorDto

  """address"""
  address: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Street dir suffix"""
  street_dir_suffix: FindOperatorDto

  """Street name"""
  street_name: FindOperatorDto

  """Street number"""
  street_number: FindOperatorDto

  """Street suffix"""
  street_suffix: FindOperatorDto

  """City name"""
  city_name: FindOperatorDto

  """State"""
  state: FindOperatorDto

  """Zipcode"""
  zipcode: FindOperatorDto

  """County"""
  county: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """Dom"""
  dom: FindOperatorDto

  """Listing Date"""
  listing_date: FindOperatorDto

  """Last Photo Date"""
  last_photo_date: FindOperatorDto

  """Last Update Date"""
  last_update_date: FindOperatorDto

  """Latitude"""
  latitude: FindOperatorDto

  """Longitude"""
  longitude: FindOperatorDto

  """List price"""
  list_price: FindOperatorDto

  """Lot size"""
  lot_size: FindOperatorDto

  """Main photo url"""
  main_photo_url: FindOperatorDto

  """Original entry timestamp"""
  original_entry_timestamp: FindOperatorDto

  """Original list price"""
  original_list_price: FindOperatorDto

  """Sqft"""
  sqft: FindOperatorDto

  """Sold date"""
  sold_date: FindOperatorDto

  """Sold Price"""
  sold_price: FindOperatorDto

  """Total floor"""
  total_floor: FindOperatorDto

  """Total garage"""
  total_garage: FindOperatorDto

  """Total parking"""
  total_parking: FindOperatorDto

  """Total photos"""
  total_photos: FindOperatorDto

  """Total rooms"""
  total_rooms: FindOperatorDto

  """Total units"""
  total_units: FindOperatorDto

  """Unit floor"""
  unit_floor: FindOperatorDto

  """Year built"""
  yearbuilt: FindOperatorDto

  """Office id"""
  office_id: FindOperatorDto

  """Agent id"""
  agent_id: FindOperatorDto

  """Co agent id"""
  co_agent_id: FindOperatorDto

  """Co agent name"""
  co_agent_name: FindOperatorDto

  """Co list agent email"""
  co_list_agent_email: FindOperatorDto

  """Co office id"""
  co_office_id: FindOperatorDto

  """Buyer agent id"""
  buyer_agent_id: FindOperatorDto

  """Seller agent id"""
  seller_agent_id: FindOperatorDto

  """Area"""
  area: FindOperatorDto

  """Baths full"""
  baths_full: FindOperatorDto

  """Baths half"""
  baths_half: FindOperatorDto

  """Is openhouse"""
  is_openhouse: FindOperatorDto

  """Is spa"""
  is_spa: FindOperatorDto

  """Is waterfront"""
  is_waterfront: FindOperatorDto

  """MLSP ID of the rets listing."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingEntity!]!
}

input RetsListingRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingRestoreInputWhere!]
}

input RetsListingRestoreInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Listing key"""
  listing_key: FindOperatorDto

  """Price difference"""
  price_diff: FindOperatorDto

  """Picture downloaded"""
  pic_downloaded: FindOperatorDto

  """Picture download error"""
  pic_download_error: FindOperatorDto

  """Latlong downloaded"""
  latlong_downloaded: FindOperatorDto

  """When record is created, date-time will be saved."""
  created_timestamp: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Property status"""
  property_status: FindOperatorDto

  """Property style"""
  property_style: FindOperatorDto

  """Property type"""
  property_type: FindOperatorDto

  """Subtype"""
  subtype: FindOperatorDto

  """Display address"""
  display_address: FindOperatorDto

  """address"""
  address: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Street dir suffix"""
  street_dir_suffix: FindOperatorDto

  """Street name"""
  street_name: FindOperatorDto

  """Street number"""
  street_number: FindOperatorDto

  """Street suffix"""
  street_suffix: FindOperatorDto

  """City name"""
  city_name: FindOperatorDto

  """State"""
  state: FindOperatorDto

  """Zipcode"""
  zipcode: FindOperatorDto

  """County"""
  county: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """Dom"""
  dom: FindOperatorDto

  """Listing Date"""
  listing_date: FindOperatorDto

  """Last Photo Date"""
  last_photo_date: FindOperatorDto

  """Last Update Date"""
  last_update_date: FindOperatorDto

  """Latitude"""
  latitude: FindOperatorDto

  """Longitude"""
  longitude: FindOperatorDto

  """List price"""
  list_price: FindOperatorDto

  """Lot size"""
  lot_size: FindOperatorDto

  """Main photo url"""
  main_photo_url: FindOperatorDto

  """Original entry timestamp"""
  original_entry_timestamp: FindOperatorDto

  """Original list price"""
  original_list_price: FindOperatorDto

  """Sqft"""
  sqft: FindOperatorDto

  """Sold date"""
  sold_date: FindOperatorDto

  """Sold Price"""
  sold_price: FindOperatorDto

  """Total floor"""
  total_floor: FindOperatorDto

  """Total garage"""
  total_garage: FindOperatorDto

  """Total parking"""
  total_parking: FindOperatorDto

  """Total photos"""
  total_photos: FindOperatorDto

  """Total rooms"""
  total_rooms: FindOperatorDto

  """Total units"""
  total_units: FindOperatorDto

  """Unit floor"""
  unit_floor: FindOperatorDto

  """Year built"""
  yearbuilt: FindOperatorDto

  """Office id"""
  office_id: FindOperatorDto

  """Agent id"""
  agent_id: FindOperatorDto

  """Co agent id"""
  co_agent_id: FindOperatorDto

  """Co agent name"""
  co_agent_name: FindOperatorDto

  """Co list agent email"""
  co_list_agent_email: FindOperatorDto

  """Co office id"""
  co_office_id: FindOperatorDto

  """Buyer agent id"""
  buyer_agent_id: FindOperatorDto

  """Seller agent id"""
  seller_agent_id: FindOperatorDto

  """Area"""
  area: FindOperatorDto

  """Baths full"""
  baths_full: FindOperatorDto

  """Baths half"""
  baths_half: FindOperatorDto

  """Is openhouse"""
  is_openhouse: FindOperatorDto

  """Is spa"""
  is_spa: FindOperatorDto

  """Is waterfront"""
  is_waterfront: FindOperatorDto

  """MLSP ID of the rets listing."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingRoomCreateInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Listing Key"""
  listing_key: String!

  """Floor Covering"""
  floor_covering: String

  """Input Entry Order"""
  input_entry_order: String

  """Matrix Modified Dater"""
  matrix_modified_date: DateTime

  """Room Comments"""
  room_comments: String

  """Room Depth"""
  room_depth: String

  """Room Dimensions"""
  room_dimensions: String

  """Room Level"""
  room_level: String

  """Room Type"""
  room_type: String

  """Room Width"""
  room_width: String
}

type RetsListingRoomCreateOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Listing Key"""
  listing_key: String

  """Floor Covering"""
  floor_covering: String

  """Input Entry Order"""
  input_entry_order: String

  """Matrix Modified Dater"""
  matrix_modified_date: DateTime

  """Room Comments"""
  room_comments: String

  """Room Depth"""
  room_depth: String

  """Room Dimensions"""
  room_dimensions: String

  """Room Level"""
  room_level: String

  """Room Type"""
  room_type: String

  """Room Width"""
  room_width: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing room."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingRoomDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingRoomDeleteInputWhere!]
}

input RetsListingRoomDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Room Level"""
  room_level: FindOperatorDto

  """Room Type"""
  room_type: FindOperatorDto

  """Room Width"""
  room_width: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing room."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingRoomDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsListingRoomEntity {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Listing Key"""
  listing_key: String

  """Floor Covering"""
  floor_covering: String

  """Input Entry Order"""
  input_entry_order: String

  """Matrix Modified Dater"""
  matrix_modified_date: DateTime

  """Room Comments"""
  room_comments: String

  """Room Depth"""
  room_depth: String

  """Room Dimensions"""
  room_dimensions: String

  """Room Level"""
  room_level: String

  """Room Type"""
  room_type: String

  """Room Width"""
  room_width: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing room."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingRoomFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingRoomFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsListingRoomFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsListingRoomFindInputSortOrder
}

input RetsListingRoomFindInputGroupBy {
  mlsp_id: Boolean
  listing_key: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input RetsListingRoomFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  listing_key: RecordSortDirectionEnum
  room_level: RecordSortDirectionEnum
  room_type: RecordSortDirectionEnum
  room_width: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input RetsListingRoomFindInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Room Level"""
  room_level: FindOperatorDto

  """Room Type"""
  room_type: FindOperatorDto

  """Room Width"""
  room_width: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing room."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input RetsListingRoomFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsListingRoomFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsListingRoomEntity!]!
}

input RetsListingRoomRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingRoomRecoverInputWhere!]
}

input RetsListingRoomRecoverInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Room Level"""
  room_level: FindOperatorDto

  """Room Type"""
  room_type: FindOperatorDto

  """Room Width"""
  room_width: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing room."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingRoomRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingRoomEntity!]!
}

input RetsListingRoomRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingRoomRemoveInputWhere!]
}

input RetsListingRoomRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Room Level"""
  room_level: FindOperatorDto

  """Room Type"""
  room_type: FindOperatorDto

  """Room Width"""
  room_width: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing room."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingRoomRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingRoomEntity!]!
}

input RetsListingRoomRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingRoomRestoreInputWhere!]
}

input RetsListingRoomRestoreInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Room Level"""
  room_level: FindOperatorDto

  """Room Type"""
  room_type: FindOperatorDto

  """Room Width"""
  room_width: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing room."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingRoomRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingRoomSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingRoomSoftDeleteInputWhere!]
}

input RetsListingRoomSoftDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Room Level"""
  room_level: FindOperatorDto

  """Room Type"""
  room_type: FindOperatorDto

  """Room Width"""
  room_width: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing room."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingRoomSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingRoomSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingRoomSoftRemoveInputWhere!]
}

input RetsListingRoomSoftRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Room Level"""
  room_level: FindOperatorDto

  """Room Type"""
  room_type: FindOperatorDto

  """Room Width"""
  room_width: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing room."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingRoomSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingRoomEntity!]!
}

input RetsListingRoomUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingRoomUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsListingRoomUpdateInputSets!
}

input RetsListingRoomUpdateInputSets {
  """MLS Service Provider ID"""
  mlsp_id: Int

  """Listing Key"""
  listing_key: String

  """Floor Covering"""
  floor_covering: String

  """Input Entry Order"""
  input_entry_order: String

  """Matrix Modified Dater"""
  matrix_modified_date: DateTime

  """Room Comments"""
  room_comments: String

  """Room Depth"""
  room_depth: String

  """Room Dimensions"""
  room_dimensions: String

  """Room Level"""
  room_level: String

  """Room Type"""
  room_type: String

  """Room Width"""
  room_width: String
}

input RetsListingRoomUpdateInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Room Level"""
  room_level: FindOperatorDto

  """Room Type"""
  room_type: FindOperatorDto

  """Room Width"""
  room_width: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing room."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingRoomUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsListingRoomEntity!]!
}

input RetsListingRoomUpsertInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Listing Key"""
  listing_key: String!

  """Floor Covering"""
  floor_covering: String

  """Input Entry Order"""
  input_entry_order: String

  """Matrix Modified Dater"""
  matrix_modified_date: DateTime

  """Room Comments"""
  room_comments: String

  """Room Depth"""
  room_depth: String

  """Room Dimensions"""
  room_dimensions: String

  """Room Level"""
  room_level: String

  """Room Type"""
  room_type: String

  """Room Width"""
  room_width: String

  """Unique ID of the listing office type, auto generated. undefined"""
  id: Int
}

type RetsListingRoomUpsertOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Listing Key"""
  listing_key: String

  """Floor Covering"""
  floor_covering: String

  """Input Entry Order"""
  input_entry_order: String

  """Matrix Modified Dater"""
  matrix_modified_date: DateTime

  """Room Comments"""
  room_comments: String

  """Room Depth"""
  room_depth: String

  """Room Dimensions"""
  room_dimensions: String

  """Room Level"""
  room_level: String

  """Room Type"""
  room_type: String

  """Room Width"""
  room_width: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing room."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsListingSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingSoftDeleteInputWhere!]
}

input RetsListingSoftDeleteInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Listing key"""
  listing_key: FindOperatorDto

  """Price difference"""
  price_diff: FindOperatorDto

  """Picture downloaded"""
  pic_downloaded: FindOperatorDto

  """Picture download error"""
  pic_download_error: FindOperatorDto

  """Latlong downloaded"""
  latlong_downloaded: FindOperatorDto

  """When record is created, date-time will be saved."""
  created_timestamp: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Property status"""
  property_status: FindOperatorDto

  """Property style"""
  property_style: FindOperatorDto

  """Property type"""
  property_type: FindOperatorDto

  """Subtype"""
  subtype: FindOperatorDto

  """Display address"""
  display_address: FindOperatorDto

  """address"""
  address: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Street dir suffix"""
  street_dir_suffix: FindOperatorDto

  """Street name"""
  street_name: FindOperatorDto

  """Street number"""
  street_number: FindOperatorDto

  """Street suffix"""
  street_suffix: FindOperatorDto

  """City name"""
  city_name: FindOperatorDto

  """State"""
  state: FindOperatorDto

  """Zipcode"""
  zipcode: FindOperatorDto

  """County"""
  county: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """Dom"""
  dom: FindOperatorDto

  """Listing Date"""
  listing_date: FindOperatorDto

  """Last Photo Date"""
  last_photo_date: FindOperatorDto

  """Last Update Date"""
  last_update_date: FindOperatorDto

  """Latitude"""
  latitude: FindOperatorDto

  """Longitude"""
  longitude: FindOperatorDto

  """List price"""
  list_price: FindOperatorDto

  """Lot size"""
  lot_size: FindOperatorDto

  """Main photo url"""
  main_photo_url: FindOperatorDto

  """Original entry timestamp"""
  original_entry_timestamp: FindOperatorDto

  """Original list price"""
  original_list_price: FindOperatorDto

  """Sqft"""
  sqft: FindOperatorDto

  """Sold date"""
  sold_date: FindOperatorDto

  """Sold Price"""
  sold_price: FindOperatorDto

  """Total floor"""
  total_floor: FindOperatorDto

  """Total garage"""
  total_garage: FindOperatorDto

  """Total parking"""
  total_parking: FindOperatorDto

  """Total photos"""
  total_photos: FindOperatorDto

  """Total rooms"""
  total_rooms: FindOperatorDto

  """Total units"""
  total_units: FindOperatorDto

  """Unit floor"""
  unit_floor: FindOperatorDto

  """Year built"""
  yearbuilt: FindOperatorDto

  """Office id"""
  office_id: FindOperatorDto

  """Agent id"""
  agent_id: FindOperatorDto

  """Co agent id"""
  co_agent_id: FindOperatorDto

  """Co agent name"""
  co_agent_name: FindOperatorDto

  """Co list agent email"""
  co_list_agent_email: FindOperatorDto

  """Co office id"""
  co_office_id: FindOperatorDto

  """Buyer agent id"""
  buyer_agent_id: FindOperatorDto

  """Seller agent id"""
  seller_agent_id: FindOperatorDto

  """Area"""
  area: FindOperatorDto

  """Baths full"""
  baths_full: FindOperatorDto

  """Baths half"""
  baths_half: FindOperatorDto

  """Is openhouse"""
  is_openhouse: FindOperatorDto

  """Is spa"""
  is_spa: FindOperatorDto

  """Is waterfront"""
  is_waterfront: FindOperatorDto

  """MLSP ID of the rets listing."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingSoftRemoveInputWhere!]
}

input RetsListingSoftRemoveInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Listing key"""
  listing_key: FindOperatorDto

  """Price difference"""
  price_diff: FindOperatorDto

  """Picture downloaded"""
  pic_downloaded: FindOperatorDto

  """Picture download error"""
  pic_download_error: FindOperatorDto

  """Latlong downloaded"""
  latlong_downloaded: FindOperatorDto

  """When record is created, date-time will be saved."""
  created_timestamp: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Property status"""
  property_status: FindOperatorDto

  """Property style"""
  property_style: FindOperatorDto

  """Property type"""
  property_type: FindOperatorDto

  """Subtype"""
  subtype: FindOperatorDto

  """Display address"""
  display_address: FindOperatorDto

  """address"""
  address: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Street dir suffix"""
  street_dir_suffix: FindOperatorDto

  """Street name"""
  street_name: FindOperatorDto

  """Street number"""
  street_number: FindOperatorDto

  """Street suffix"""
  street_suffix: FindOperatorDto

  """City name"""
  city_name: FindOperatorDto

  """State"""
  state: FindOperatorDto

  """Zipcode"""
  zipcode: FindOperatorDto

  """County"""
  county: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """Dom"""
  dom: FindOperatorDto

  """Listing Date"""
  listing_date: FindOperatorDto

  """Last Photo Date"""
  last_photo_date: FindOperatorDto

  """Last Update Date"""
  last_update_date: FindOperatorDto

  """Latitude"""
  latitude: FindOperatorDto

  """Longitude"""
  longitude: FindOperatorDto

  """List price"""
  list_price: FindOperatorDto

  """Lot size"""
  lot_size: FindOperatorDto

  """Main photo url"""
  main_photo_url: FindOperatorDto

  """Original entry timestamp"""
  original_entry_timestamp: FindOperatorDto

  """Original list price"""
  original_list_price: FindOperatorDto

  """Sqft"""
  sqft: FindOperatorDto

  """Sold date"""
  sold_date: FindOperatorDto

  """Sold Price"""
  sold_price: FindOperatorDto

  """Total floor"""
  total_floor: FindOperatorDto

  """Total garage"""
  total_garage: FindOperatorDto

  """Total parking"""
  total_parking: FindOperatorDto

  """Total photos"""
  total_photos: FindOperatorDto

  """Total rooms"""
  total_rooms: FindOperatorDto

  """Total units"""
  total_units: FindOperatorDto

  """Unit floor"""
  unit_floor: FindOperatorDto

  """Year built"""
  yearbuilt: FindOperatorDto

  """Office id"""
  office_id: FindOperatorDto

  """Agent id"""
  agent_id: FindOperatorDto

  """Co agent id"""
  co_agent_id: FindOperatorDto

  """Co agent name"""
  co_agent_name: FindOperatorDto

  """Co list agent email"""
  co_list_agent_email: FindOperatorDto

  """Co office id"""
  co_office_id: FindOperatorDto

  """Buyer agent id"""
  buyer_agent_id: FindOperatorDto

  """Seller agent id"""
  seller_agent_id: FindOperatorDto

  """Area"""
  area: FindOperatorDto

  """Baths full"""
  baths_full: FindOperatorDto

  """Baths half"""
  baths_half: FindOperatorDto

  """Is openhouse"""
  is_openhouse: FindOperatorDto

  """Is spa"""
  is_spa: FindOperatorDto

  """Is waterfront"""
  is_waterfront: FindOperatorDto

  """MLSP ID of the rets listing."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingEntity!]!
}

input RetsListingUnitCreateInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Mls Num"""
  mls_num: String!

  """Listing Key"""
  listing_key: String!

  """Unit Type"""
  unit_type: String!

  """Actual Rent"""
  actual_rent: Float

  """Baths"""
  baths: Int

  """Beds"""
  beds: Int

  """Garage Spaces"""
  garage_spaces: Float

  """Pro Forma Rent"""
  pro_forma_rent: Int
}

type RetsListingUnitCreateOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Mls Num"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Unit Type"""
  unit_type: String

  """Actual Rent"""
  actual_rent: Float

  """Baths"""
  baths: Int

  """Beds"""
  beds: Int

  """Garage Spaces"""
  garage_spaces: Float

  """Pro Forma Rent"""
  pro_forma_rent: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing unit."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingUnitDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingUnitDeleteInputWhere!]
}

input RetsListingUnitDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Num"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Unit Type"""
  unit_type: FindOperatorDto

  """Actual Rent"""
  actual_rent: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing unit."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingUnitDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsListingUnitEntity {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Mls Num"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Unit Type"""
  unit_type: String

  """Actual Rent"""
  actual_rent: Float

  """Baths"""
  baths: Int

  """Beds"""
  beds: Int

  """Garage Spaces"""
  garage_spaces: Float

  """Pro Forma Rent"""
  pro_forma_rent: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing unit."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingUnitFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingUnitFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsListingUnitFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsListingUnitFindInputSortOrder
}

input RetsListingUnitFindInputGroupBy {
  mlsp_id: Boolean
  mls_num: Boolean
  listing_key: Boolean
  unit_type: Boolean
  actual_rent: Boolean
  baths: Boolean
  beds: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input RetsListingUnitFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  listing_key: RecordSortDirectionEnum
  unit_type: RecordSortDirectionEnum
  actual_rent: RecordSortDirectionEnum
  baths: RecordSortDirectionEnum
  beds: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input RetsListingUnitFindInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Num"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Unit Type"""
  unit_type: FindOperatorDto

  """Actual Rent"""
  actual_rent: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing unit."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input RetsListingUnitFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsListingUnitFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsListingUnitEntity!]!
}

input RetsListingUnitRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingUnitRecoverInputWhere!]
}

input RetsListingUnitRecoverInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Num"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Unit Type"""
  unit_type: FindOperatorDto

  """Actual Rent"""
  actual_rent: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing unit."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingUnitRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingUnitEntity!]!
}

input RetsListingUnitRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingUnitRemoveInputWhere!]
}

input RetsListingUnitRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Num"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Unit Type"""
  unit_type: FindOperatorDto

  """Actual Rent"""
  actual_rent: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing unit."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingUnitRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingUnitEntity!]!
}

input RetsListingUnitRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingUnitRestoreInputWhere!]
}

input RetsListingUnitRestoreInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Num"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Unit Type"""
  unit_type: FindOperatorDto

  """Actual Rent"""
  actual_rent: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing unit."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingUnitRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingUnitSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingUnitSoftDeleteInputWhere!]
}

input RetsListingUnitSoftDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Num"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Unit Type"""
  unit_type: FindOperatorDto

  """Actual Rent"""
  actual_rent: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing unit."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingUnitSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingUnitSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingUnitSoftRemoveInputWhere!]
}

input RetsListingUnitSoftRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Num"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Unit Type"""
  unit_type: FindOperatorDto

  """Actual Rent"""
  actual_rent: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing unit."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingUnitSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingUnitEntity!]!
}

input RetsListingUnitUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingUnitUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsListingUnitUpdateInputSets!
}

input RetsListingUnitUpdateInputSets {
  """MLS Service Provider ID"""
  mlsp_id: Int

  """Mls Num"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Unit Type"""
  unit_type: String

  """Actual Rent"""
  actual_rent: Float

  """Baths"""
  baths: Int

  """Beds"""
  beds: Int

  """Garage Spaces"""
  garage_spaces: Float

  """Pro Forma Rent"""
  pro_forma_rent: Int
}

input RetsListingUnitUpdateInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Num"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Unit Type"""
  unit_type: FindOperatorDto

  """Actual Rent"""
  actual_rent: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing unit."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingUnitUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsListingUnitEntity!]!
}

input RetsListingUnitUpsertInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Mls Num"""
  mls_num: String!

  """Listing Key"""
  listing_key: String!

  """Unit Type"""
  unit_type: String!

  """Actual Rent"""
  actual_rent: Float

  """Baths"""
  baths: Int

  """Beds"""
  beds: Int

  """Garage Spaces"""
  garage_spaces: Float

  """Pro Forma Rent"""
  pro_forma_rent: Int

  """Unique ID of the listing office type, auto generated. undefined"""
  id: Int
}

type RetsListingUnitUpsertOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Mls Num"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Unit Type"""
  unit_type: String

  """Actual Rent"""
  actual_rent: Float

  """Baths"""
  baths: Int

  """Beds"""
  beds: Int

  """Garage Spaces"""
  garage_spaces: Float

  """Pro Forma Rent"""
  pro_forma_rent: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing unit."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsListingUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsListingUpdateInputSets!
}

input RetsListingUpdateInputSets {
  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """Listing key"""
  listing_key: String

  """Price difference"""
  price_diff: Float

  """Picture downloaded"""
  pic_downloaded: DateTime

  """Picture download error"""
  pic_download_error: DateTime

  """Picture updated"""
  pic_updated: DateTime

  """Third Party api platform"""
  latlong_tppltf_id: Int

  """Latlong downloaded"""
  latlong_downloaded: DateTime

  """When record is created, date-time will be saved."""
  created_timestamp: DateTime

  """Property status"""
  property_status: String

  """Property style"""
  property_style: String

  """Property type"""
  property_type: String

  """Subtype"""
  subtype: String

  """Display address"""
  display_address: String

  """address"""
  address: String

  """Unit no"""
  unit_no: String

  """Street dir prefix"""
  street_dir_prefix: String

  """Street dir suffix"""
  street_dir_suffix: String

  """Street number modifier"""
  street_number_modifier: String

  """Street name"""
  street_name: String

  """Street number"""
  street_number: String

  """Street suffix"""
  street_suffix: String

  """City name"""
  city_name: String

  """State"""
  state: String

  """Zipcode"""
  zipcode: String

  """County"""
  county: String

  """Sub Condo Name"""
  sub_condo_name: String

  """Subdivision"""
  subdivision: String

  """Baths"""
  baths: Int

  """Beds"""
  beds: Int

  """Dom"""
  dom: Int

  """Listing Date"""
  listing_date: DateTime

  """Last Photo Date"""
  last_photo_date: DateTime

  """Last Update Date"""
  last_update_date: DateTime

  """Latitude"""
  latitude: Float

  """Longitude"""
  longitude: Float

  """List price"""
  list_price: Float

  """Lot size"""
  lot_size: Float

  """Main sqft"""
  main_sqft: Float

  """Main photo url"""
  main_photo_url: String

  """Original entry timestamp"""
  original_entry_timestamp: DateTime

  """Original list price"""
  original_list_price: Float

  """Property description"""
  property_desc: String

  """Sqft"""
  sqft: Float

  """Sold date"""
  sold_date: DateTime

  """Sold Price"""
  sold_price: Float

  """Stories"""
  stories: Int

  """Tax year"""
  tax_year: Int

  """Tax"""
  tax: Float

  """Total floor"""
  total_floor: Int

  """Total garage"""
  total_garage: Float

  """Total parking"""
  total_parking: Float

  """Total photos"""
  total_photos: Int

  """Total rooms"""
  total_rooms: Int

  """Total units"""
  total_units: Int

  """Unit floor"""
  unit_floor: Int

  """Year built"""
  yearbuilt: Int

  """Office id"""
  office_id: String

  """Agent id"""
  agent_id: String

  """Co agent id"""
  co_agent_id: String

  """Co agent name"""
  co_agent_name: String

  """Co list agent email"""
  co_list_agent_email: String

  """Co list agent full name"""
  co_list_agent_full_name: String

  """Co office id"""
  co_office_id: String

  """Co office name"""
  co_office_name: String

  """Buyer agent id"""
  buyer_agent_id: String

  """Seller agent id"""
  seller_agent_id: String

  """Area"""
  area: String

  """Baths full"""
  baths_full: Int

  """Baths half"""
  baths_half: Int

  """Elementary school"""
  elementary_school: String

  """Garage"""
  garage: Float

  """Heating"""
  heating: String

  """High school"""
  high_school: String

  """Is openhouse"""
  is_openhouse: String

  """Is reo"""
  is_reo: String

  """Is shortsale"""
  is_shortsale: String

  """Is spa"""
  is_spa: String

  """Is waterfront"""
  is_waterfront: String

  """Middle school"""
  middle_school: String

  """Parking features"""
  parking_features: String
}

input RetsListingUpdateInputWhere {
  """Unique ID of the market type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Unique ID of Listing"""
  mls_num: FindOperatorDto

  """Listing key"""
  listing_key: FindOperatorDto

  """Price difference"""
  price_diff: FindOperatorDto

  """Picture downloaded"""
  pic_downloaded: FindOperatorDto

  """Picture download error"""
  pic_download_error: FindOperatorDto

  """Latlong downloaded"""
  latlong_downloaded: FindOperatorDto

  """When record is created, date-time will be saved."""
  created_timestamp: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Property status"""
  property_status: FindOperatorDto

  """Property style"""
  property_style: FindOperatorDto

  """Property type"""
  property_type: FindOperatorDto

  """Subtype"""
  subtype: FindOperatorDto

  """Display address"""
  display_address: FindOperatorDto

  """address"""
  address: FindOperatorDto

  """Unit no"""
  unit_no: FindOperatorDto

  """Street dir suffix"""
  street_dir_suffix: FindOperatorDto

  """Street name"""
  street_name: FindOperatorDto

  """Street number"""
  street_number: FindOperatorDto

  """Street suffix"""
  street_suffix: FindOperatorDto

  """City name"""
  city_name: FindOperatorDto

  """State"""
  state: FindOperatorDto

  """Zipcode"""
  zipcode: FindOperatorDto

  """County"""
  county: FindOperatorDto

  """Baths"""
  baths: FindOperatorDto

  """Beds"""
  beds: FindOperatorDto

  """Dom"""
  dom: FindOperatorDto

  """Listing Date"""
  listing_date: FindOperatorDto

  """Last Photo Date"""
  last_photo_date: FindOperatorDto

  """Last Update Date"""
  last_update_date: FindOperatorDto

  """Latitude"""
  latitude: FindOperatorDto

  """Longitude"""
  longitude: FindOperatorDto

  """List price"""
  list_price: FindOperatorDto

  """Lot size"""
  lot_size: FindOperatorDto

  """Main photo url"""
  main_photo_url: FindOperatorDto

  """Original entry timestamp"""
  original_entry_timestamp: FindOperatorDto

  """Original list price"""
  original_list_price: FindOperatorDto

  """Sqft"""
  sqft: FindOperatorDto

  """Sold date"""
  sold_date: FindOperatorDto

  """Sold Price"""
  sold_price: FindOperatorDto

  """Total floor"""
  total_floor: FindOperatorDto

  """Total garage"""
  total_garage: FindOperatorDto

  """Total parking"""
  total_parking: FindOperatorDto

  """Total photos"""
  total_photos: FindOperatorDto

  """Total rooms"""
  total_rooms: FindOperatorDto

  """Total units"""
  total_units: FindOperatorDto

  """Unit floor"""
  unit_floor: FindOperatorDto

  """Year built"""
  yearbuilt: FindOperatorDto

  """Office id"""
  office_id: FindOperatorDto

  """Agent id"""
  agent_id: FindOperatorDto

  """Co agent id"""
  co_agent_id: FindOperatorDto

  """Co agent name"""
  co_agent_name: FindOperatorDto

  """Co list agent email"""
  co_list_agent_email: FindOperatorDto

  """Co office id"""
  co_office_id: FindOperatorDto

  """Buyer agent id"""
  buyer_agent_id: FindOperatorDto

  """Seller agent id"""
  seller_agent_id: FindOperatorDto

  """Area"""
  area: FindOperatorDto

  """Baths full"""
  baths_full: FindOperatorDto

  """Baths half"""
  baths_half: FindOperatorDto

  """Is openhouse"""
  is_openhouse: FindOperatorDto

  """Is spa"""
  is_spa: FindOperatorDto

  """Is waterfront"""
  is_waterfront: FindOperatorDto

  """MLSP ID of the rets listing."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsListingEntity!]!
}

input RetsListingUpsertInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Unique ID of Listing"""
  mls_num: String!

  """Listing key"""
  listing_key: String!

  """Price difference"""
  price_diff: Float!

  """Picture downloaded"""
  pic_downloaded: DateTime

  """Picture download error"""
  pic_download_error: DateTime

  """Picture updated"""
  pic_updated: DateTime

  """Third Party api platform"""
  latlong_tppltf_id: Int

  """Latlong downloaded"""
  latlong_downloaded: DateTime

  """When record is created, date-time will be saved."""
  created_timestamp: DateTime

  """Property status"""
  property_status: String

  """Property style"""
  property_style: String

  """Property type"""
  property_type: String!

  """Subtype"""
  subtype: String

  """Display address"""
  display_address: String!

  """address"""
  address: String!

  """Unit no"""
  unit_no: String

  """Street dir prefix"""
  street_dir_prefix: String

  """Street dir suffix"""
  street_dir_suffix: String

  """Street number modifier"""
  street_number_modifier: String

  """Street name"""
  street_name: String!

  """Street number"""
  street_number: String!

  """Street suffix"""
  street_suffix: String

  """City name"""
  city_name: String!

  """State"""
  state: String!

  """Zipcode"""
  zipcode: String!

  """County"""
  county: String

  """Sub Condo Name"""
  sub_condo_name: String

  """Subdivision"""
  subdivision: String

  """Baths"""
  baths: Int!

  """Beds"""
  beds: Int!

  """Dom"""
  dom: Int

  """Listing Date"""
  listing_date: DateTime!

  """Last Photo Date"""
  last_photo_date: DateTime

  """Last Update Date"""
  last_update_date: DateTime

  """Latitude"""
  latitude: Float!

  """Longitude"""
  longitude: Float!

  """List price"""
  list_price: Float!

  """Lot size"""
  lot_size: Float

  """Main sqft"""
  main_sqft: Float

  """Main photo url"""
  main_photo_url: String

  """Original entry timestamp"""
  original_entry_timestamp: DateTime

  """Original list price"""
  original_list_price: Float!

  """Property description"""
  property_desc: String!

  """Sqft"""
  sqft: Float!

  """Sold date"""
  sold_date: DateTime

  """Sold Price"""
  sold_price: Float

  """Stories"""
  stories: Int

  """Tax year"""
  tax_year: Int

  """Tax"""
  tax: Float

  """Total floor"""
  total_floor: Int

  """Total garage"""
  total_garage: Float!

  """Total parking"""
  total_parking: Float!

  """Total photos"""
  total_photos: Int!

  """Total rooms"""
  total_rooms: Int!

  """Total units"""
  total_units: Int!

  """Unit floor"""
  unit_floor: Int

  """Year built"""
  yearbuilt: Int

  """Office id"""
  office_id: String

  """Agent id"""
  agent_id: String!

  """Co agent id"""
  co_agent_id: String

  """Co agent name"""
  co_agent_name: String

  """Co list agent email"""
  co_list_agent_email: String

  """Co list agent full name"""
  co_list_agent_full_name: String

  """Co office id"""
  co_office_id: String

  """Co office name"""
  co_office_name: String

  """Buyer agent id"""
  buyer_agent_id: String

  """Seller agent id"""
  seller_agent_id: String

  """Area"""
  area: String

  """Baths full"""
  baths_full: Int

  """Baths half"""
  baths_half: Int

  """Elementary school"""
  elementary_school: String!

  """Garage"""
  garage: Float

  """Heating"""
  heating: String

  """High school"""
  high_school: String

  """Is openhouse"""
  is_openhouse: String

  """Is reo"""
  is_reo: String

  """Is shortsale"""
  is_shortsale: String

  """Is spa"""
  is_spa: String

  """Is waterfront"""
  is_waterfront: String

  """Middle school"""
  middle_school: String

  """Parking features"""
  parking_features: String

  """Unique ID of the market type, auto generated. undefined"""
  id: Int
}

type RetsListingUpsertOutput {
  """Unique ID of the market type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Unique ID of Listing"""
  mls_num: String

  """Listing key"""
  listing_key: String

  """Price difference"""
  price_diff: Float

  """Picture downloaded"""
  pic_downloaded: DateTime

  """Picture download error"""
  pic_download_error: DateTime

  """Picture updated"""
  pic_updated: DateTime

  """Latlong downloaded"""
  latlong_downloaded: DateTime

  """Third Party api platform"""
  latlong_tppltf_id: Int

  """When record is created, date-time will be saved."""
  created_timestamp: DateTime

  """Property status"""
  property_status: String

  """Property style"""
  property_style: String

  """Property type"""
  property_type: String

  """Subtype"""
  subtype: String

  """Display address"""
  display_address: String

  """address"""
  address: String

  """Unit no"""
  unit_no: String

  """Street dir prefix"""
  street_dir_prefix: String

  """Street dir suffix"""
  street_dir_suffix: String

  """Street number modifier"""
  street_number_modifier: String

  """Street name"""
  street_name: String

  """Street number"""
  street_number: String

  """Street suffix"""
  street_suffix: String

  """City name"""
  city_name: String

  """State"""
  state: String

  """Zipcode"""
  zipcode: String

  """County"""
  county: String

  """Sub Condo Name"""
  sub_condo_name: String

  """Subdivision"""
  subdivision: String

  """Baths"""
  baths: Int

  """Beds"""
  beds: Int

  """Dom"""
  dom: Int

  """Listing Date"""
  listing_date: DateTime

  """Last Photo Date"""
  last_photo_date: DateTime

  """Last Update Date"""
  last_update_date: DateTime

  """Latitude"""
  latitude: Float

  """Longitude"""
  longitude: Float

  """List price"""
  list_price: Float!

  """Lot size"""
  lot_size: Float

  """Main sqft"""
  main_sqft: Float

  """Main photo url"""
  main_photo_url: String

  """Original entry timestamp"""
  original_entry_timestamp: DateTime

  """Original list price"""
  original_list_price: Float

  """Property description"""
  property_desc: String

  """Sqft"""
  sqft: Float

  """Sold date"""
  sold_date: DateTime

  """Sold Price"""
  sold_price: Float

  """Stories"""
  stories: Int

  """Tax year"""
  tax_year: Int

  """Tax"""
  tax: Float

  """Total floor"""
  total_floor: Int

  """Total garage"""
  total_garage: Float

  """Total parking"""
  total_parking: Float

  """Total photos"""
  total_photos: Int

  """Total rooms"""
  total_rooms: Int

  """Total units"""
  total_units: Int

  """Unit floor"""
  unit_floor: Int

  """Year built"""
  yearbuilt: Int

  """Office id"""
  office_id: String

  """Agent id"""
  agent_id: String

  """Co agent id"""
  co_agent_id: String

  """Co agent name"""
  co_agent_name: String

  """Co list agent email"""
  co_list_agent_email: String

  """Co list agent full name"""
  co_list_agent_full_name: String

  """Co office id"""
  co_office_id: String

  """Co office name"""
  co_office_name: String

  """Buyer agent id"""
  buyer_agent_id: String

  """Seller agent id"""
  seller_agent_id: String

  """Area"""
  area: String

  """Baths full"""
  baths_full: Int

  """Baths half"""
  baths_half: Int

  """Elementary school"""
  elementary_school: String

  """Garage"""
  garage: Float

  """Heating"""
  heating: String

  """High school"""
  high_school: String

  """Is openhouse"""
  is_openhouse: String

  """Is reo"""
  is_reo: String

  """Is shortsale"""
  is_shortsale: String

  """Is spa"""
  is_spa: String

  """Is waterfront"""
  is_waterfront: String

  """Middle school"""
  middle_school: String

  """Parking features"""
  parking_features: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing."""
  fr_mlsp_id: RetsMlsProviderEntity

  """Third party platform of the rets listing."""
  fr_third_party_platform: ThirdPartyPlatformEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsListingVirtualToursCreateInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Mls Number"""
  mls_num: String!

  """Listing Key"""
  listing_key: String!

  """Tour Url"""
  tour_url: String!

  """Tour Last Modified"""
  tour_last_modified: DateTime!
}

type RetsListingVirtualToursCreateOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Mls Number"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Tour Url"""
  tour_url: String

  """Tour Last Modified"""
  tour_last_modified: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing virtual tours."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingVirtualToursDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingVirtualToursDeleteInputWhere!]
}

input RetsListingVirtualToursDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Tour Url"""
  tour_url: FindOperatorDto

  """Tour Last Modified"""
  tour_last_modified: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing virtual tours."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingVirtualToursDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsListingVirtualToursEntity {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Mls Number"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Tour Url"""
  tour_url: String

  """Tour Last Modified"""
  tour_last_modified: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing virtual tours."""
  fr_mlsp_id: RetsMlsProviderEntity
}

input RetsListingVirtualToursFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingVirtualToursFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsListingVirtualToursFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsListingVirtualToursFindInputSortOrder
}

input RetsListingVirtualToursFindInputGroupBy {
  mlsp_id: Boolean
  mls_num: Boolean
  listing_key: Boolean
  tour_url: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input RetsListingVirtualToursFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  mls_num: RecordSortDirectionEnum
  listing_key: RecordSortDirectionEnum
  tour_url: RecordSortDirectionEnum
  tour_last_modified: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input RetsListingVirtualToursFindInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Tour Url"""
  tour_url: FindOperatorDto

  """Tour Last Modified"""
  tour_last_modified: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing virtual tours."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input RetsListingVirtualToursFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsListingVirtualToursFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsListingVirtualToursEntity!]!
}

input RetsListingVirtualToursRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingVirtualToursRecoverInputWhere!]
}

input RetsListingVirtualToursRecoverInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Tour Url"""
  tour_url: FindOperatorDto

  """Tour Last Modified"""
  tour_last_modified: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing virtual tours."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingVirtualToursRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingVirtualToursEntity!]!
}

input RetsListingVirtualToursRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingVirtualToursRemoveInputWhere!]
}

input RetsListingVirtualToursRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Tour Url"""
  tour_url: FindOperatorDto

  """Tour Last Modified"""
  tour_last_modified: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing virtual tours."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingVirtualToursRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingVirtualToursEntity!]!
}

input RetsListingVirtualToursRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingVirtualToursRestoreInputWhere!]
}

input RetsListingVirtualToursRestoreInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Tour Url"""
  tour_url: FindOperatorDto

  """Tour Last Modified"""
  tour_last_modified: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing virtual tours."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingVirtualToursRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingVirtualToursSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingVirtualToursSoftDeleteInputWhere!]
}

input RetsListingVirtualToursSoftDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Tour Url"""
  tour_url: FindOperatorDto

  """Tour Last Modified"""
  tour_last_modified: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing virtual tours."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingVirtualToursSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsListingVirtualToursSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingVirtualToursSoftRemoveInputWhere!]
}

input RetsListingVirtualToursSoftRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Tour Url"""
  tour_url: FindOperatorDto

  """Tour Last Modified"""
  tour_last_modified: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing virtual tours."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingVirtualToursSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsListingVirtualToursEntity!]!
}

input RetsListingVirtualToursUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsListingVirtualToursUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsListingVirtualToursUpdateInputSets!
}

input RetsListingVirtualToursUpdateInputSets {
  """MLS Service Provider ID"""
  mlsp_id: Int

  """Mls Number"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Tour Url"""
  tour_url: String

  """Tour Last Modified"""
  tour_last_modified: DateTime
}

input RetsListingVirtualToursUpdateInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Mls Number"""
  mls_num: FindOperatorDto

  """Listing Key"""
  listing_key: FindOperatorDto

  """Tour Url"""
  tour_url: FindOperatorDto

  """Tour Last Modified"""
  tour_last_modified: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the rets listing virtual tours."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type RetsListingVirtualToursUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsListingVirtualToursEntity!]!
}

input RetsListingVirtualToursUpsertInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Mls Number"""
  mls_num: String!

  """Listing Key"""
  listing_key: String!

  """Tour Url"""
  tour_url: String!

  """Tour Last Modified"""
  tour_last_modified: DateTime!

  """Unique ID of the listing office type, auto generated. undefined"""
  id: Int
}

type RetsListingVirtualToursUpsertOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Mls Number"""
  mls_num: String

  """Listing Key"""
  listing_key: String

  """Tour Url"""
  tour_url: String

  """Tour Last Modified"""
  tour_last_modified: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the rets listing virtual tours."""
  fr_mlsp_id: RetsMlsProviderEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsMlsProviderConfigCreateInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Resource associated with the MLS provider configuration."""
  resource: String!

  """Class of the MLS provider configuration."""
  class: String!

  """Select query of MLS provider configuration."""
  select_query: String

  """Field list of MLS provider configuration."""
  field_list: String

  """Lookup list of MLS provider configuration."""
  lookup_list: String

  """Look up field list of MLS provider configuration."""
  lookup_field_list: String

  """Mapped list of MLS provider configuration."""
  mapped_list: String
}

type RetsMlsProviderConfigCreateOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Resource associated with the MLS provider configuration."""
  resource: String

  """Class of the MLS provider configuration."""
  class: String

  """Select query of MLS provider configuration."""
  select_query: String

  """Field list of MLS provider configuration."""
  field_list: String

  """Lookup list of MLS provider configuration."""
  lookup_list: String

  """Look up field list of MLS provider configuration."""
  lookup_field_list: String

  """Mapped list of MLS provider configuration."""
  mapped_list: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input RetsMlsProviderConfigDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderConfigDeleteInputWhere!]
}

input RetsMlsProviderConfigDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource associated with the MLS provider configuration."""
  resource: FindOperatorDto

  """Class of the MLS provider configuration."""
  class: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsMlsProviderConfigDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsMlsProviderConfigEntity {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Resource associated with the MLS provider configuration."""
  resource: String

  """Class of the MLS provider configuration."""
  class: String

  """Select query of MLS provider configuration."""
  select_query: String

  """Field list of MLS provider configuration."""
  field_list: String

  """Lookup list of MLS provider configuration."""
  lookup_list: String

  """Look up field list of MLS provider configuration."""
  lookup_field_list: String

  """Mapped list of MLS provider configuration."""
  mapped_list: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime
}

input RetsMlsProviderConfigFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderConfigFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsMlsProviderConfigFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsMlsProviderConfigFindInputSortOrder
}

input RetsMlsProviderConfigFindInputGroupBy {
  mlsp_id: Boolean
  resource: Boolean
  class: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input RetsMlsProviderConfigFindInputSortOrder {
  id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  resource: RecordSortDirectionEnum
  class: RecordSortDirectionEnum

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

input RetsMlsProviderConfigFindInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource associated with the MLS provider configuration."""
  resource: FindOperatorDto

  """Class of the MLS provider configuration."""
  class: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

input RetsMlsProviderConfigFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsMlsProviderConfigFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsMlsProviderConfigEntity!]!
}

input RetsMlsProviderConfigRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderConfigRecoverInputWhere!]
}

input RetsMlsProviderConfigRecoverInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource associated with the MLS provider configuration."""
  resource: FindOperatorDto

  """Class of the MLS provider configuration."""
  class: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsMlsProviderConfigRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsMlsProviderConfigEntity!]!
}

input RetsMlsProviderConfigRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderConfigRemoveInputWhere!]
}

input RetsMlsProviderConfigRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource associated with the MLS provider configuration."""
  resource: FindOperatorDto

  """Class of the MLS provider configuration."""
  class: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsMlsProviderConfigRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsMlsProviderConfigEntity!]!
}

input RetsMlsProviderConfigRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderConfigRestoreInputWhere!]
}

input RetsMlsProviderConfigRestoreInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource associated with the MLS provider configuration."""
  resource: FindOperatorDto

  """Class of the MLS provider configuration."""
  class: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsMlsProviderConfigRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsMlsProviderConfigSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderConfigSoftDeleteInputWhere!]
}

input RetsMlsProviderConfigSoftDeleteInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource associated with the MLS provider configuration."""
  resource: FindOperatorDto

  """Class of the MLS provider configuration."""
  class: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsMlsProviderConfigSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsMlsProviderConfigSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderConfigSoftRemoveInputWhere!]
}

input RetsMlsProviderConfigSoftRemoveInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource associated with the MLS provider configuration."""
  resource: FindOperatorDto

  """Class of the MLS provider configuration."""
  class: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsMlsProviderConfigSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsMlsProviderConfigEntity!]!
}

input RetsMlsProviderConfigUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderConfigUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsMlsProviderConfigUpdateInputSets!
}

input RetsMlsProviderConfigUpdateInputSets {
  """MLS Service Provider ID"""
  mlsp_id: Int

  """Resource associated with the MLS provider configuration."""
  resource: String

  """Class of the MLS provider configuration."""
  class: String

  """Select query of MLS provider configuration."""
  select_query: String

  """Field list of MLS provider configuration."""
  field_list: String

  """Lookup list of MLS provider configuration."""
  lookup_list: String

  """Look up field list of MLS provider configuration."""
  lookup_field_list: String

  """Mapped list of MLS provider configuration."""
  mapped_list: String
}

input RetsMlsProviderConfigUpdateInputWhere {
  """Unique ID of the listing office type, auto generated."""
  id: FindOperatorDto

  """MLS Service Provider ID"""
  mlsp_id: FindOperatorDto

  """Resource associated with the MLS provider configuration."""
  resource: FindOperatorDto

  """Class of the MLS provider configuration."""
  class: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type RetsMlsProviderConfigUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsMlsProviderConfigEntity!]!
}

input RetsMlsProviderConfigUpsertInput {
  """MLS Service Provider ID"""
  mlsp_id: Int!

  """Resource associated with the MLS provider configuration."""
  resource: String!

  """Class of the MLS provider configuration."""
  class: String!

  """Select query of MLS provider configuration."""
  select_query: String

  """Field list of MLS provider configuration."""
  field_list: String

  """Lookup list of MLS provider configuration."""
  lookup_list: String

  """Look up field list of MLS provider configuration."""
  lookup_field_list: String

  """Mapped list of MLS provider configuration."""
  mapped_list: String

  """Unique ID of the listing office type, auto generated. undefined"""
  id: Int
}

type RetsMlsProviderConfigUpsertOutput {
  """Unique ID of the listing office type, auto generated."""
  id: Int

  """MLS Service Provider ID"""
  mlsp_id: Int

  """Resource associated with the MLS provider configuration."""
  resource: String

  """Class of the MLS provider configuration."""
  class: String

  """Select query of MLS provider configuration."""
  select_query: String

  """Field list of MLS provider configuration."""
  field_list: String

  """Lookup list of MLS provider configuration."""
  lookup_list: String

  """Look up field list of MLS provider configuration."""
  lookup_field_list: String

  """Mapped list of MLS provider configuration."""
  mapped_list: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input RetsMlsProviderCreateInput {
  """Market Name"""
  market_name: String!

  """A descriptive title of the market."""
  market_title: String

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: YesNoEnum!

  """The host or domain name of the server hosting the MLS system."""
  host: String!

  """The username used to authenticate the connection to the MLS system."""
  user: String!

  """
  The password associated with the username for authenticating the connection.
  """
  passwd: String!

  """Rets user agent."""
  rets_user_agent: String!

  """Rets user agent password."""
  rets_user_agent_pwd: String

  """Indicates whether the API is active or inactive."""
  is_API: YesNoEnum!

  """A unique identifier for the client using the MLS API."""
  client_id: String

  """A secret key associated with the Client ID."""
  client_secret: String

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: String

  """A token used to authenticate browser-based requests to the MLS system."""
  browser_token: String

  """The version of the RETS"""
  rets_version: String!

  """Format"""
  format: String!

  """A short disclaimer that is displayed to users."""
  disclaimer_short: String

  """A more detailed or extended version of the disclaimer."""
  disclaimer_big: String

  """An icon or image associated with the disclaimer."""
  disclaimer_icon: String

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: YesNoEnum!

  """Indicates whether the market is active or inactive."""
  active: YesNoEnum!

  """Indicates whether property data download is enabled or not."""
  prop_data_download: String!

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: String!

  """Indicates whether office data download is enabled or not."""
  office_data_download: String!

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: String!
}

type RetsMlsProviderCreateOutput {
  """Unique ID of the rets MLS provider, auto generated."""
  id: Int

  """Market Name"""
  market_name: String

  """A descriptive title of the market."""
  market_title: String

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: YesNoEnum

  """The host or domain name of the server hosting the MLS system."""
  host: String

  """The username used to authenticate the connection to the MLS system."""
  user: String

  """
  The password associated with the username for authenticating the connection.
  """
  passwd: String

  """Rets user agent."""
  rets_user_agent: String

  """Rets user agent password."""
  rets_user_agent_pwd: String

  """Indicates whether the API is active or inactive."""
  is_API: YesNoEnum

  """A unique identifier for the client using the MLS API."""
  client_id: String

  """A secret key associated with the Client ID."""
  client_secret: String

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: String

  """A token used to authenticate browser-based requests to the MLS system."""
  browser_token: String

  """The version of the RETS"""
  rets_version: String

  """Format"""
  format: String

  """A short disclaimer that is displayed to users."""
  disclaimer_short: String

  """A more detailed or extended version of the disclaimer."""
  disclaimer_big: String

  """An icon or image associated with the disclaimer."""
  disclaimer_icon: String

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: YesNoEnum

  """Indicates whether the market is active or inactive."""
  active: YesNoEnum

  """Indicates whether property data download is enabled or not."""
  prop_data_download: String

  """
  The date and time when the property data download process was last executed.
  """
  prop_last_run_date: String

  """
  The date when the most recent property data record was added or updated.
  """
  prop_last_record_date: String

  """The date and time when the ID-related data process was last executed."""
  id_last_run_date: String

  """
  The date when the most recent ID-related data record was added or updated.
  """
  id_last_record_date: String

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: String

  """
  The date and time when the agent data download process was last executed.
  """
  agent_last_run_date: String

  """Indicates whether office data download is enabled or not."""
  office_data_download: String

  """
  The date and time when the office last run date process was last executed.
  """
  office_last_run_date: String

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: String

  """
  The date and time when the picture data download process was last executed.
  """
  pic_last_run_datetime: DateTime

  """Token URL for accessing the MLS system's API."""
  token_url: String

  """The expiration time of the authentication token."""
  token_expire_time: DateTime

  """MLSP ID of the user favourite property."""
  fr_user_favourite_mlsp_id: [UserFavouritePropertyEntity!]

  """MLSP ID of the trigger search by address."""
  fr_search_by_addr_mlsp_id: [ProcessedSearchByAddressEntity!]

  """MLSP ID of the trigger search by city."""
  fr_search_by_city_mlsp_id: [ProcessedSearchByCityEntity!]

  """MLSP ID of the trigger search by subdivision."""
  fr_search_by_subdivision_mlsp_id: [ProcessedSearchBySubdivisionEntity!]

  """MLSP ID of the trigger search by zipcode."""
  fr_search_by_zipcode_mlsp_id: [ProcessedSearchByZipcodeEntity!]

  """MLSP ID of the trigger search by mls."""
  fr_search_by_mls_mlsp_id: [ProcessedSearchByMlsEntity!]

  """Rets listing ID of the trigger search by mls."""
  fr_rets_listing_id: [RetsListingEntity!]

  """Rets listing additional info ID of the trigger search by mls."""
  fr_rets_lis_addi_info_id: [RetsListingAdditionalInfoEntity!]

  """Rets listing agent id of the trigger search by mls."""
  fr_rets_list_agent_id: [RetsListingAgentEntity!]

  """Rets listing office id of the trigger search by mls."""
  fr_rets_list_office_id: [RetsListingOfficeEntity!]

  """Rets listing open house id of the trigger search by mls."""
  fr_rets_list_open_house_id: [RetsListingOpenHouseEntity!]

  """Rets listing photos id of the trigger search by mls."""
  fr_rets_list_photos_id: [RetsListingPhotosEntity!]

  """Rets listing room id of the trigger search by mls."""
  fr_rets_list_room_id: [RetsListingRoomEntity!]

  """Rets listing unit id of the trigger search by mls."""
  fr_rets_list_unit_id: [RetsListingUnitEntity!]

  """Rets listing virtual tour id of the trigger search by mls."""
  fr_rets_list_virtual_tours_id: [RetsListingVirtualToursEntity!]
}

input RetsMlsProviderDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderDeleteInputWhere!]
}

input RetsMlsProviderDeleteInputWhere {
  """Unique ID of the rets MLS provider, auto generated."""
  id: FindOperatorDto

  """Market Name"""
  market_name: FindOperatorDto

  """A descriptive title of the market."""
  market_title: FindOperatorDto

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: FindOperatorDto

  """The username used to authenticate the connection to the MLS system."""
  user: FindOperatorDto

  """Rets user agent."""
  rets_user_agent: FindOperatorDto

  """Indicates whether the API is active or inactive."""
  is_API: FindOperatorDto

  """A unique identifier for the client using the MLS API."""
  client_id: FindOperatorDto

  """A secret key associated with the Client ID."""
  client_secret: FindOperatorDto

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: FindOperatorDto

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: FindOperatorDto

  """Indicates whether the market is active or inactive."""
  active: FindOperatorDto

  """
  The date and time when the property data download process was last executed.
  """
  prop_last_run_date: FindOperatorDto

  """
  The date when the most recent property data record was added or updated.
  """
  prop_last_record_date: FindOperatorDto

  """The date and time when the ID-related data process was last executed."""
  id_last_run_date: FindOperatorDto

  """
  The date when the most recent ID-related data record was added or updated.
  """
  id_last_record_date: FindOperatorDto

  """Indicates whether a property data job is currently running."""
  prop_data_job_running: FindOperatorDto

  """Indicates whether the property ID job is currently running."""
  prop_id_job_running: FindOperatorDto

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: FindOperatorDto

  """
  The date and time when the agent data download process was last executed.
  """
  agent_last_run_date: FindOperatorDto

  """Indicates whether office data download is enabled or not."""
  office_data_download: FindOperatorDto

  """
  The date and time when the office last run date process was last executed.
  """
  office_last_run_date: FindOperatorDto

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: FindOperatorDto

  """Indicates whether the picture data job is currently running or not."""
  pic_data_job_running: FindOperatorDto

  """Indicates the last successful data synchronization."""
  data_last_sync_success: FindOperatorDto

  """The ID of the last successful synchronization event."""
  id_last_sync_success: FindOperatorDto

  """The expiration time of the authentication token."""
  token_expire_time: FindOperatorDto

  """The total count of synchronization runs for the ID data."""
  id_srun_total_count: FindOperatorDto

  """
  The current count of ongoing or completed synchronization runs for the ID data.
  """
  id_srun_cur_count: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_user_favourite_mlsp_id: [UserFavouritePropertyFindInputWhere!]

  """MLSP ID of the trigger search by address."""
  fr_search_by_addr_mlsp_id: [ProcessedSearchByAddressFindInputWhere!]

  """MLSP ID of the trigger search by city."""
  fr_search_by_city_mlsp_id: [ProcessedSearchByCityFindInputWhere!]

  """MLSP ID of the trigger search by subdivision."""
  fr_search_by_subdivision_mlsp_id: [ProcessedSearchBySubdivisionFindInputWhere!]

  """MLSP ID of the trigger search by zipcode."""
  fr_search_by_zipcode_mlsp_id: [ProcessedSearchByZipcodeFindInputWhere!]

  """MLSP ID of the trigger search by mls."""
  fr_search_by_mls_mlsp_id: [ProcessedSearchByMlsFindInputWhere!]

  """Rets listing ID of the trigger search by mls."""
  fr_rets_listing_id: [RetsListingFindInputWhere!]

  """Rets listing additional info ID of the trigger search by mls."""
  fr_rets_lis_addi_info_id: [RetsListingAdditionalInfoFindInputWhere!]

  """Rets listing agent id of the trigger search by mls."""
  fr_rets_list_agent_id: [RetsListingAgentFindInputWhere!]

  """Rets listing office id of the trigger search by mls."""
  fr_rets_list_office_id: [RetsListingOfficeFindInputWhere!]

  """Rets listing open house id of the trigger search by mls."""
  fr_rets_list_open_house_id: [RetsListingOpenHouseFindInputWhere!]

  """Rets listing photos id of the trigger search by mls."""
  fr_rets_list_photos_id: [RetsListingPhotosFindInputWhere!]

  """Rets listing room id of the trigger search by mls."""
  fr_rets_list_room_id: [RetsListingRoomFindInputWhere!]

  """Rets listing unit id of the trigger search by mls."""
  fr_rets_list_unit_id: [RetsListingUnitFindInputWhere!]

  """Rets listing virtual tour id of the trigger search by mls."""
  fr_rets_list_virtual_tours_id: [RetsListingVirtualToursFindInputWhere!]
}

type RetsMlsProviderDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type RetsMlsProviderEntity {
  """Unique ID of the rets MLS provider, auto generated."""
  id: Int

  """Market Name"""
  market_name: String

  """A descriptive title of the market."""
  market_title: String

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: YesNoEnum

  """The host or domain name of the server hosting the MLS system."""
  host: String

  """The username used to authenticate the connection to the MLS system."""
  user: String

  """
  The password associated with the username for authenticating the connection.
  """
  passwd: String

  """Rets user agent."""
  rets_user_agent: String

  """Rets user agent password."""
  rets_user_agent_pwd: String

  """Indicates whether the API is active or inactive."""
  is_API: YesNoEnum

  """A unique identifier for the client using the MLS API."""
  client_id: String

  """A secret key associated with the Client ID."""
  client_secret: String

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: String

  """A token used to authenticate browser-based requests to the MLS system."""
  browser_token: String

  """The version of the RETS"""
  rets_version: String

  """Format"""
  format: String

  """A short disclaimer that is displayed to users."""
  disclaimer_short: String

  """A more detailed or extended version of the disclaimer."""
  disclaimer_big: String

  """An icon or image associated with the disclaimer."""
  disclaimer_icon: String

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: YesNoEnum

  """Indicates whether the market is active or inactive."""
  active: YesNoEnum

  """Indicates whether property data download is enabled or not."""
  prop_data_download: String

  """
  The date and time when the property data download process was last executed.
  """
  prop_last_run_date: String

  """
  The date when the most recent property data record was added or updated.
  """
  prop_last_record_date: String

  """The date and time when the ID-related data process was last executed."""
  id_last_run_date: String

  """
  The date when the most recent ID-related data record was added or updated.
  """
  id_last_record_date: String

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: String

  """
  The date and time when the agent data download process was last executed.
  """
  agent_last_run_date: String

  """Indicates whether office data download is enabled or not."""
  office_data_download: String

  """
  The date and time when the office last run date process was last executed.
  """
  office_last_run_date: String

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: String

  """
  The date and time when the picture data download process was last executed.
  """
  pic_last_run_datetime: DateTime

  """Token URL for accessing the MLS system's API."""
  token_url: String

  """The expiration time of the authentication token."""
  token_expire_time: DateTime

  """MLSP ID of the user favourite property."""
  fr_user_favourite_mlsp_id: [UserFavouritePropertyEntity!]

  """MLSP ID of the trigger search by address."""
  fr_search_by_addr_mlsp_id: [ProcessedSearchByAddressEntity!]

  """MLSP ID of the trigger search by city."""
  fr_search_by_city_mlsp_id: [ProcessedSearchByCityEntity!]

  """MLSP ID of the trigger search by subdivision."""
  fr_search_by_subdivision_mlsp_id: [ProcessedSearchBySubdivisionEntity!]

  """MLSP ID of the trigger search by zipcode."""
  fr_search_by_zipcode_mlsp_id: [ProcessedSearchByZipcodeEntity!]

  """MLSP ID of the trigger search by mls."""
  fr_search_by_mls_mlsp_id: [ProcessedSearchByMlsEntity!]

  """Rets listing ID of the trigger search by mls."""
  fr_rets_listing_id: [RetsListingEntity!]

  """Rets listing additional info ID of the trigger search by mls."""
  fr_rets_lis_addi_info_id: [RetsListingAdditionalInfoEntity!]

  """Rets listing agent id of the trigger search by mls."""
  fr_rets_list_agent_id: [RetsListingAgentEntity!]

  """Rets listing office id of the trigger search by mls."""
  fr_rets_list_office_id: [RetsListingOfficeEntity!]

  """Rets listing open house id of the trigger search by mls."""
  fr_rets_list_open_house_id: [RetsListingOpenHouseEntity!]

  """Rets listing photos id of the trigger search by mls."""
  fr_rets_list_photos_id: [RetsListingPhotosEntity!]

  """Rets listing room id of the trigger search by mls."""
  fr_rets_list_room_id: [RetsListingRoomEntity!]

  """Rets listing unit id of the trigger search by mls."""
  fr_rets_list_unit_id: [RetsListingUnitEntity!]

  """Rets listing virtual tour id of the trigger search by mls."""
  fr_rets_list_virtual_tours_id: [RetsListingVirtualToursEntity!]
}

input RetsMlsProviderFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: RetsMlsProviderFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: RetsMlsProviderFindInputSortOrder
}

input RetsMlsProviderFindInputGroupBy {
  market_name: Boolean
  market_title: Boolean
  market_active: Boolean
  host: Boolean
  user: Boolean
  rets_user_agent: Boolean
  is_API: Boolean
  rets_version: Boolean
  format: Boolean
  is_pic_url_supported: Boolean
  active: Boolean
  prop_data_download: Boolean
  prop_data_job_running: Boolean
  prop_id_job_running: Boolean
  pic_data_job_running: Boolean
  data_last_sync_success: Boolean
  id_last_sync_success: Boolean
}

input RetsMlsProviderFindInputSortOrder {
  id: RecordSortDirectionEnum
  market_name: RecordSortDirectionEnum
  market_title: RecordSortDirectionEnum
  market_active: RecordSortDirectionEnum
  user: RecordSortDirectionEnum
  rets_user_agent: RecordSortDirectionEnum
  is_API: RecordSortDirectionEnum
  client_id: RecordSortDirectionEnum
  client_secret: RecordSortDirectionEnum
  server_token: RecordSortDirectionEnum
  is_pic_url_supported: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  prop_last_run_date: RecordSortDirectionEnum
  prop_last_record_date: RecordSortDirectionEnum
  id_last_run_date: RecordSortDirectionEnum
  id_last_record_date: RecordSortDirectionEnum
  prop_data_job_running: RecordSortDirectionEnum
  prop_id_job_running: RecordSortDirectionEnum
  agent_last_run_date: RecordSortDirectionEnum
  office_last_run_date: RecordSortDirectionEnum
  pic_last_run_datetime: RecordSortDirectionEnum
  pic_data_job_running: RecordSortDirectionEnum
  data_last_sync_success: RecordSortDirectionEnum
  id_last_sync_success: RecordSortDirectionEnum
}

input RetsMlsProviderFindInputWhere {
  """Unique ID of the rets MLS provider, auto generated."""
  id: FindOperatorDto

  """Market Name"""
  market_name: FindOperatorDto

  """A descriptive title of the market."""
  market_title: FindOperatorDto

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: FindOperatorDto

  """The username used to authenticate the connection to the MLS system."""
  user: FindOperatorDto

  """Rets user agent."""
  rets_user_agent: FindOperatorDto

  """Indicates whether the API is active or inactive."""
  is_API: FindOperatorDto

  """A unique identifier for the client using the MLS API."""
  client_id: FindOperatorDto

  """A secret key associated with the Client ID."""
  client_secret: FindOperatorDto

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: FindOperatorDto

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: FindOperatorDto

  """Indicates whether the market is active or inactive."""
  active: FindOperatorDto

  """
  The date and time when the property data download process was last executed.
  """
  prop_last_run_date: FindOperatorDto

  """
  The date when the most recent property data record was added or updated.
  """
  prop_last_record_date: FindOperatorDto

  """The date and time when the ID-related data process was last executed."""
  id_last_run_date: FindOperatorDto

  """
  The date when the most recent ID-related data record was added or updated.
  """
  id_last_record_date: FindOperatorDto

  """Indicates whether a property data job is currently running."""
  prop_data_job_running: FindOperatorDto

  """Indicates whether the property ID job is currently running."""
  prop_id_job_running: FindOperatorDto

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: FindOperatorDto

  """
  The date and time when the agent data download process was last executed.
  """
  agent_last_run_date: FindOperatorDto

  """Indicates whether office data download is enabled or not."""
  office_data_download: FindOperatorDto

  """
  The date and time when the office last run date process was last executed.
  """
  office_last_run_date: FindOperatorDto

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: FindOperatorDto

  """Indicates whether the picture data job is currently running or not."""
  pic_data_job_running: FindOperatorDto

  """Indicates the last successful data synchronization."""
  data_last_sync_success: FindOperatorDto

  """The ID of the last successful synchronization event."""
  id_last_sync_success: FindOperatorDto

  """The expiration time of the authentication token."""
  token_expire_time: FindOperatorDto

  """The total count of synchronization runs for the ID data."""
  id_srun_total_count: FindOperatorDto

  """
  The current count of ongoing or completed synchronization runs for the ID data.
  """
  id_srun_cur_count: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_user_favourite_mlsp_id: [UserFavouritePropertyFindInputWhere!]

  """MLSP ID of the trigger search by address."""
  fr_search_by_addr_mlsp_id: [ProcessedSearchByAddressFindInputWhere!]

  """MLSP ID of the trigger search by city."""
  fr_search_by_city_mlsp_id: [ProcessedSearchByCityFindInputWhere!]

  """MLSP ID of the trigger search by subdivision."""
  fr_search_by_subdivision_mlsp_id: [ProcessedSearchBySubdivisionFindInputWhere!]

  """MLSP ID of the trigger search by zipcode."""
  fr_search_by_zipcode_mlsp_id: [ProcessedSearchByZipcodeFindInputWhere!]

  """MLSP ID of the trigger search by mls."""
  fr_search_by_mls_mlsp_id: [ProcessedSearchByMlsFindInputWhere!]

  """Rets listing ID of the trigger search by mls."""
  fr_rets_listing_id: [RetsListingFindInputWhere!]

  """Rets listing additional info ID of the trigger search by mls."""
  fr_rets_lis_addi_info_id: [RetsListingAdditionalInfoFindInputWhere!]

  """Rets listing agent id of the trigger search by mls."""
  fr_rets_list_agent_id: [RetsListingAgentFindInputWhere!]

  """Rets listing office id of the trigger search by mls."""
  fr_rets_list_office_id: [RetsListingOfficeFindInputWhere!]

  """Rets listing open house id of the trigger search by mls."""
  fr_rets_list_open_house_id: [RetsListingOpenHouseFindInputWhere!]

  """Rets listing photos id of the trigger search by mls."""
  fr_rets_list_photos_id: [RetsListingPhotosFindInputWhere!]

  """Rets listing room id of the trigger search by mls."""
  fr_rets_list_room_id: [RetsListingRoomFindInputWhere!]

  """Rets listing unit id of the trigger search by mls."""
  fr_rets_list_unit_id: [RetsListingUnitFindInputWhere!]

  """Rets listing virtual tour id of the trigger search by mls."""
  fr_rets_list_virtual_tours_id: [RetsListingVirtualToursFindInputWhere!]
}

input RetsMlsProviderFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type RetsMlsProviderFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [RetsMlsProviderEntity!]!
}

input RetsMlsProviderRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderRecoverInputWhere!]
}

input RetsMlsProviderRecoverInputWhere {
  """Unique ID of the rets MLS provider, auto generated."""
  id: FindOperatorDto

  """Market Name"""
  market_name: FindOperatorDto

  """A descriptive title of the market."""
  market_title: FindOperatorDto

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: FindOperatorDto

  """The username used to authenticate the connection to the MLS system."""
  user: FindOperatorDto

  """Rets user agent."""
  rets_user_agent: FindOperatorDto

  """Indicates whether the API is active or inactive."""
  is_API: FindOperatorDto

  """A unique identifier for the client using the MLS API."""
  client_id: FindOperatorDto

  """A secret key associated with the Client ID."""
  client_secret: FindOperatorDto

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: FindOperatorDto

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: FindOperatorDto

  """Indicates whether the market is active or inactive."""
  active: FindOperatorDto

  """
  The date and time when the property data download process was last executed.
  """
  prop_last_run_date: FindOperatorDto

  """
  The date when the most recent property data record was added or updated.
  """
  prop_last_record_date: FindOperatorDto

  """The date and time when the ID-related data process was last executed."""
  id_last_run_date: FindOperatorDto

  """
  The date when the most recent ID-related data record was added or updated.
  """
  id_last_record_date: FindOperatorDto

  """Indicates whether a property data job is currently running."""
  prop_data_job_running: FindOperatorDto

  """Indicates whether the property ID job is currently running."""
  prop_id_job_running: FindOperatorDto

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: FindOperatorDto

  """
  The date and time when the agent data download process was last executed.
  """
  agent_last_run_date: FindOperatorDto

  """Indicates whether office data download is enabled or not."""
  office_data_download: FindOperatorDto

  """
  The date and time when the office last run date process was last executed.
  """
  office_last_run_date: FindOperatorDto

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: FindOperatorDto

  """Indicates whether the picture data job is currently running or not."""
  pic_data_job_running: FindOperatorDto

  """Indicates the last successful data synchronization."""
  data_last_sync_success: FindOperatorDto

  """The ID of the last successful synchronization event."""
  id_last_sync_success: FindOperatorDto

  """The expiration time of the authentication token."""
  token_expire_time: FindOperatorDto

  """The total count of synchronization runs for the ID data."""
  id_srun_total_count: FindOperatorDto

  """
  The current count of ongoing or completed synchronization runs for the ID data.
  """
  id_srun_cur_count: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_user_favourite_mlsp_id: [UserFavouritePropertyFindInputWhere!]

  """MLSP ID of the trigger search by address."""
  fr_search_by_addr_mlsp_id: [ProcessedSearchByAddressFindInputWhere!]

  """MLSP ID of the trigger search by city."""
  fr_search_by_city_mlsp_id: [ProcessedSearchByCityFindInputWhere!]

  """MLSP ID of the trigger search by subdivision."""
  fr_search_by_subdivision_mlsp_id: [ProcessedSearchBySubdivisionFindInputWhere!]

  """MLSP ID of the trigger search by zipcode."""
  fr_search_by_zipcode_mlsp_id: [ProcessedSearchByZipcodeFindInputWhere!]

  """MLSP ID of the trigger search by mls."""
  fr_search_by_mls_mlsp_id: [ProcessedSearchByMlsFindInputWhere!]

  """Rets listing ID of the trigger search by mls."""
  fr_rets_listing_id: [RetsListingFindInputWhere!]

  """Rets listing additional info ID of the trigger search by mls."""
  fr_rets_lis_addi_info_id: [RetsListingAdditionalInfoFindInputWhere!]

  """Rets listing agent id of the trigger search by mls."""
  fr_rets_list_agent_id: [RetsListingAgentFindInputWhere!]

  """Rets listing office id of the trigger search by mls."""
  fr_rets_list_office_id: [RetsListingOfficeFindInputWhere!]

  """Rets listing open house id of the trigger search by mls."""
  fr_rets_list_open_house_id: [RetsListingOpenHouseFindInputWhere!]

  """Rets listing photos id of the trigger search by mls."""
  fr_rets_list_photos_id: [RetsListingPhotosFindInputWhere!]

  """Rets listing room id of the trigger search by mls."""
  fr_rets_list_room_id: [RetsListingRoomFindInputWhere!]

  """Rets listing unit id of the trigger search by mls."""
  fr_rets_list_unit_id: [RetsListingUnitFindInputWhere!]

  """Rets listing virtual tour id of the trigger search by mls."""
  fr_rets_list_virtual_tours_id: [RetsListingVirtualToursFindInputWhere!]
}

type RetsMlsProviderRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsMlsProviderEntity!]!
}

input RetsMlsProviderRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderRemoveInputWhere!]
}

input RetsMlsProviderRemoveInputWhere {
  """Unique ID of the rets MLS provider, auto generated."""
  id: FindOperatorDto

  """Market Name"""
  market_name: FindOperatorDto

  """A descriptive title of the market."""
  market_title: FindOperatorDto

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: FindOperatorDto

  """The username used to authenticate the connection to the MLS system."""
  user: FindOperatorDto

  """Rets user agent."""
  rets_user_agent: FindOperatorDto

  """Indicates whether the API is active or inactive."""
  is_API: FindOperatorDto

  """A unique identifier for the client using the MLS API."""
  client_id: FindOperatorDto

  """A secret key associated with the Client ID."""
  client_secret: FindOperatorDto

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: FindOperatorDto

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: FindOperatorDto

  """Indicates whether the market is active or inactive."""
  active: FindOperatorDto

  """
  The date and time when the property data download process was last executed.
  """
  prop_last_run_date: FindOperatorDto

  """
  The date when the most recent property data record was added or updated.
  """
  prop_last_record_date: FindOperatorDto

  """The date and time when the ID-related data process was last executed."""
  id_last_run_date: FindOperatorDto

  """
  The date when the most recent ID-related data record was added or updated.
  """
  id_last_record_date: FindOperatorDto

  """Indicates whether a property data job is currently running."""
  prop_data_job_running: FindOperatorDto

  """Indicates whether the property ID job is currently running."""
  prop_id_job_running: FindOperatorDto

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: FindOperatorDto

  """
  The date and time when the agent data download process was last executed.
  """
  agent_last_run_date: FindOperatorDto

  """Indicates whether office data download is enabled or not."""
  office_data_download: FindOperatorDto

  """
  The date and time when the office last run date process was last executed.
  """
  office_last_run_date: FindOperatorDto

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: FindOperatorDto

  """Indicates whether the picture data job is currently running or not."""
  pic_data_job_running: FindOperatorDto

  """Indicates the last successful data synchronization."""
  data_last_sync_success: FindOperatorDto

  """The ID of the last successful synchronization event."""
  id_last_sync_success: FindOperatorDto

  """The expiration time of the authentication token."""
  token_expire_time: FindOperatorDto

  """The total count of synchronization runs for the ID data."""
  id_srun_total_count: FindOperatorDto

  """
  The current count of ongoing or completed synchronization runs for the ID data.
  """
  id_srun_cur_count: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_user_favourite_mlsp_id: [UserFavouritePropertyFindInputWhere!]

  """MLSP ID of the trigger search by address."""
  fr_search_by_addr_mlsp_id: [ProcessedSearchByAddressFindInputWhere!]

  """MLSP ID of the trigger search by city."""
  fr_search_by_city_mlsp_id: [ProcessedSearchByCityFindInputWhere!]

  """MLSP ID of the trigger search by subdivision."""
  fr_search_by_subdivision_mlsp_id: [ProcessedSearchBySubdivisionFindInputWhere!]

  """MLSP ID of the trigger search by zipcode."""
  fr_search_by_zipcode_mlsp_id: [ProcessedSearchByZipcodeFindInputWhere!]

  """MLSP ID of the trigger search by mls."""
  fr_search_by_mls_mlsp_id: [ProcessedSearchByMlsFindInputWhere!]

  """Rets listing ID of the trigger search by mls."""
  fr_rets_listing_id: [RetsListingFindInputWhere!]

  """Rets listing additional info ID of the trigger search by mls."""
  fr_rets_lis_addi_info_id: [RetsListingAdditionalInfoFindInputWhere!]

  """Rets listing agent id of the trigger search by mls."""
  fr_rets_list_agent_id: [RetsListingAgentFindInputWhere!]

  """Rets listing office id of the trigger search by mls."""
  fr_rets_list_office_id: [RetsListingOfficeFindInputWhere!]

  """Rets listing open house id of the trigger search by mls."""
  fr_rets_list_open_house_id: [RetsListingOpenHouseFindInputWhere!]

  """Rets listing photos id of the trigger search by mls."""
  fr_rets_list_photos_id: [RetsListingPhotosFindInputWhere!]

  """Rets listing room id of the trigger search by mls."""
  fr_rets_list_room_id: [RetsListingRoomFindInputWhere!]

  """Rets listing unit id of the trigger search by mls."""
  fr_rets_list_unit_id: [RetsListingUnitFindInputWhere!]

  """Rets listing virtual tour id of the trigger search by mls."""
  fr_rets_list_virtual_tours_id: [RetsListingVirtualToursFindInputWhere!]
}

type RetsMlsProviderRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsMlsProviderEntity!]!
}

input RetsMlsProviderRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderRestoreInputWhere!]
}

input RetsMlsProviderRestoreInputWhere {
  """Unique ID of the rets MLS provider, auto generated."""
  id: FindOperatorDto

  """Market Name"""
  market_name: FindOperatorDto

  """A descriptive title of the market."""
  market_title: FindOperatorDto

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: FindOperatorDto

  """The username used to authenticate the connection to the MLS system."""
  user: FindOperatorDto

  """Rets user agent."""
  rets_user_agent: FindOperatorDto

  """Indicates whether the API is active or inactive."""
  is_API: FindOperatorDto

  """A unique identifier for the client using the MLS API."""
  client_id: FindOperatorDto

  """A secret key associated with the Client ID."""
  client_secret: FindOperatorDto

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: FindOperatorDto

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: FindOperatorDto

  """Indicates whether the market is active or inactive."""
  active: FindOperatorDto

  """
  The date and time when the property data download process was last executed.
  """
  prop_last_run_date: FindOperatorDto

  """
  The date when the most recent property data record was added or updated.
  """
  prop_last_record_date: FindOperatorDto

  """The date and time when the ID-related data process was last executed."""
  id_last_run_date: FindOperatorDto

  """
  The date when the most recent ID-related data record was added or updated.
  """
  id_last_record_date: FindOperatorDto

  """Indicates whether a property data job is currently running."""
  prop_data_job_running: FindOperatorDto

  """Indicates whether the property ID job is currently running."""
  prop_id_job_running: FindOperatorDto

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: FindOperatorDto

  """
  The date and time when the agent data download process was last executed.
  """
  agent_last_run_date: FindOperatorDto

  """Indicates whether office data download is enabled or not."""
  office_data_download: FindOperatorDto

  """
  The date and time when the office last run date process was last executed.
  """
  office_last_run_date: FindOperatorDto

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: FindOperatorDto

  """Indicates whether the picture data job is currently running or not."""
  pic_data_job_running: FindOperatorDto

  """Indicates the last successful data synchronization."""
  data_last_sync_success: FindOperatorDto

  """The ID of the last successful synchronization event."""
  id_last_sync_success: FindOperatorDto

  """The expiration time of the authentication token."""
  token_expire_time: FindOperatorDto

  """The total count of synchronization runs for the ID data."""
  id_srun_total_count: FindOperatorDto

  """
  The current count of ongoing or completed synchronization runs for the ID data.
  """
  id_srun_cur_count: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_user_favourite_mlsp_id: [UserFavouritePropertyFindInputWhere!]

  """MLSP ID of the trigger search by address."""
  fr_search_by_addr_mlsp_id: [ProcessedSearchByAddressFindInputWhere!]

  """MLSP ID of the trigger search by city."""
  fr_search_by_city_mlsp_id: [ProcessedSearchByCityFindInputWhere!]

  """MLSP ID of the trigger search by subdivision."""
  fr_search_by_subdivision_mlsp_id: [ProcessedSearchBySubdivisionFindInputWhere!]

  """MLSP ID of the trigger search by zipcode."""
  fr_search_by_zipcode_mlsp_id: [ProcessedSearchByZipcodeFindInputWhere!]

  """MLSP ID of the trigger search by mls."""
  fr_search_by_mls_mlsp_id: [ProcessedSearchByMlsFindInputWhere!]

  """Rets listing ID of the trigger search by mls."""
  fr_rets_listing_id: [RetsListingFindInputWhere!]

  """Rets listing additional info ID of the trigger search by mls."""
  fr_rets_lis_addi_info_id: [RetsListingAdditionalInfoFindInputWhere!]

  """Rets listing agent id of the trigger search by mls."""
  fr_rets_list_agent_id: [RetsListingAgentFindInputWhere!]

  """Rets listing office id of the trigger search by mls."""
  fr_rets_list_office_id: [RetsListingOfficeFindInputWhere!]

  """Rets listing open house id of the trigger search by mls."""
  fr_rets_list_open_house_id: [RetsListingOpenHouseFindInputWhere!]

  """Rets listing photos id of the trigger search by mls."""
  fr_rets_list_photos_id: [RetsListingPhotosFindInputWhere!]

  """Rets listing room id of the trigger search by mls."""
  fr_rets_list_room_id: [RetsListingRoomFindInputWhere!]

  """Rets listing unit id of the trigger search by mls."""
  fr_rets_list_unit_id: [RetsListingUnitFindInputWhere!]

  """Rets listing virtual tour id of the trigger search by mls."""
  fr_rets_list_virtual_tours_id: [RetsListingVirtualToursFindInputWhere!]
}

type RetsMlsProviderRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsMlsProviderSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderSoftDeleteInputWhere!]
}

input RetsMlsProviderSoftDeleteInputWhere {
  """Unique ID of the rets MLS provider, auto generated."""
  id: FindOperatorDto

  """Market Name"""
  market_name: FindOperatorDto

  """A descriptive title of the market."""
  market_title: FindOperatorDto

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: FindOperatorDto

  """The username used to authenticate the connection to the MLS system."""
  user: FindOperatorDto

  """Rets user agent."""
  rets_user_agent: FindOperatorDto

  """Indicates whether the API is active or inactive."""
  is_API: FindOperatorDto

  """A unique identifier for the client using the MLS API."""
  client_id: FindOperatorDto

  """A secret key associated with the Client ID."""
  client_secret: FindOperatorDto

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: FindOperatorDto

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: FindOperatorDto

  """Indicates whether the market is active or inactive."""
  active: FindOperatorDto

  """
  The date and time when the property data download process was last executed.
  """
  prop_last_run_date: FindOperatorDto

  """
  The date when the most recent property data record was added or updated.
  """
  prop_last_record_date: FindOperatorDto

  """The date and time when the ID-related data process was last executed."""
  id_last_run_date: FindOperatorDto

  """
  The date when the most recent ID-related data record was added or updated.
  """
  id_last_record_date: FindOperatorDto

  """Indicates whether a property data job is currently running."""
  prop_data_job_running: FindOperatorDto

  """Indicates whether the property ID job is currently running."""
  prop_id_job_running: FindOperatorDto

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: FindOperatorDto

  """
  The date and time when the agent data download process was last executed.
  """
  agent_last_run_date: FindOperatorDto

  """Indicates whether office data download is enabled or not."""
  office_data_download: FindOperatorDto

  """
  The date and time when the office last run date process was last executed.
  """
  office_last_run_date: FindOperatorDto

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: FindOperatorDto

  """Indicates whether the picture data job is currently running or not."""
  pic_data_job_running: FindOperatorDto

  """Indicates the last successful data synchronization."""
  data_last_sync_success: FindOperatorDto

  """The ID of the last successful synchronization event."""
  id_last_sync_success: FindOperatorDto

  """The expiration time of the authentication token."""
  token_expire_time: FindOperatorDto

  """The total count of synchronization runs for the ID data."""
  id_srun_total_count: FindOperatorDto

  """
  The current count of ongoing or completed synchronization runs for the ID data.
  """
  id_srun_cur_count: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_user_favourite_mlsp_id: [UserFavouritePropertyFindInputWhere!]

  """MLSP ID of the trigger search by address."""
  fr_search_by_addr_mlsp_id: [ProcessedSearchByAddressFindInputWhere!]

  """MLSP ID of the trigger search by city."""
  fr_search_by_city_mlsp_id: [ProcessedSearchByCityFindInputWhere!]

  """MLSP ID of the trigger search by subdivision."""
  fr_search_by_subdivision_mlsp_id: [ProcessedSearchBySubdivisionFindInputWhere!]

  """MLSP ID of the trigger search by zipcode."""
  fr_search_by_zipcode_mlsp_id: [ProcessedSearchByZipcodeFindInputWhere!]

  """MLSP ID of the trigger search by mls."""
  fr_search_by_mls_mlsp_id: [ProcessedSearchByMlsFindInputWhere!]

  """Rets listing ID of the trigger search by mls."""
  fr_rets_listing_id: [RetsListingFindInputWhere!]

  """Rets listing additional info ID of the trigger search by mls."""
  fr_rets_lis_addi_info_id: [RetsListingAdditionalInfoFindInputWhere!]

  """Rets listing agent id of the trigger search by mls."""
  fr_rets_list_agent_id: [RetsListingAgentFindInputWhere!]

  """Rets listing office id of the trigger search by mls."""
  fr_rets_list_office_id: [RetsListingOfficeFindInputWhere!]

  """Rets listing open house id of the trigger search by mls."""
  fr_rets_list_open_house_id: [RetsListingOpenHouseFindInputWhere!]

  """Rets listing photos id of the trigger search by mls."""
  fr_rets_list_photos_id: [RetsListingPhotosFindInputWhere!]

  """Rets listing room id of the trigger search by mls."""
  fr_rets_list_room_id: [RetsListingRoomFindInputWhere!]

  """Rets listing unit id of the trigger search by mls."""
  fr_rets_list_unit_id: [RetsListingUnitFindInputWhere!]

  """Rets listing virtual tour id of the trigger search by mls."""
  fr_rets_list_virtual_tours_id: [RetsListingVirtualToursFindInputWhere!]
}

type RetsMlsProviderSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input RetsMlsProviderSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderSoftRemoveInputWhere!]
}

input RetsMlsProviderSoftRemoveInputWhere {
  """Unique ID of the rets MLS provider, auto generated."""
  id: FindOperatorDto

  """Market Name"""
  market_name: FindOperatorDto

  """A descriptive title of the market."""
  market_title: FindOperatorDto

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: FindOperatorDto

  """The username used to authenticate the connection to the MLS system."""
  user: FindOperatorDto

  """Rets user agent."""
  rets_user_agent: FindOperatorDto

  """Indicates whether the API is active or inactive."""
  is_API: FindOperatorDto

  """A unique identifier for the client using the MLS API."""
  client_id: FindOperatorDto

  """A secret key associated with the Client ID."""
  client_secret: FindOperatorDto

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: FindOperatorDto

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: FindOperatorDto

  """Indicates whether the market is active or inactive."""
  active: FindOperatorDto

  """
  The date and time when the property data download process was last executed.
  """
  prop_last_run_date: FindOperatorDto

  """
  The date when the most recent property data record was added or updated.
  """
  prop_last_record_date: FindOperatorDto

  """The date and time when the ID-related data process was last executed."""
  id_last_run_date: FindOperatorDto

  """
  The date when the most recent ID-related data record was added or updated.
  """
  id_last_record_date: FindOperatorDto

  """Indicates whether a property data job is currently running."""
  prop_data_job_running: FindOperatorDto

  """Indicates whether the property ID job is currently running."""
  prop_id_job_running: FindOperatorDto

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: FindOperatorDto

  """
  The date and time when the agent data download process was last executed.
  """
  agent_last_run_date: FindOperatorDto

  """Indicates whether office data download is enabled or not."""
  office_data_download: FindOperatorDto

  """
  The date and time when the office last run date process was last executed.
  """
  office_last_run_date: FindOperatorDto

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: FindOperatorDto

  """Indicates whether the picture data job is currently running or not."""
  pic_data_job_running: FindOperatorDto

  """Indicates the last successful data synchronization."""
  data_last_sync_success: FindOperatorDto

  """The ID of the last successful synchronization event."""
  id_last_sync_success: FindOperatorDto

  """The expiration time of the authentication token."""
  token_expire_time: FindOperatorDto

  """The total count of synchronization runs for the ID data."""
  id_srun_total_count: FindOperatorDto

  """
  The current count of ongoing or completed synchronization runs for the ID data.
  """
  id_srun_cur_count: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_user_favourite_mlsp_id: [UserFavouritePropertyFindInputWhere!]

  """MLSP ID of the trigger search by address."""
  fr_search_by_addr_mlsp_id: [ProcessedSearchByAddressFindInputWhere!]

  """MLSP ID of the trigger search by city."""
  fr_search_by_city_mlsp_id: [ProcessedSearchByCityFindInputWhere!]

  """MLSP ID of the trigger search by subdivision."""
  fr_search_by_subdivision_mlsp_id: [ProcessedSearchBySubdivisionFindInputWhere!]

  """MLSP ID of the trigger search by zipcode."""
  fr_search_by_zipcode_mlsp_id: [ProcessedSearchByZipcodeFindInputWhere!]

  """MLSP ID of the trigger search by mls."""
  fr_search_by_mls_mlsp_id: [ProcessedSearchByMlsFindInputWhere!]

  """Rets listing ID of the trigger search by mls."""
  fr_rets_listing_id: [RetsListingFindInputWhere!]

  """Rets listing additional info ID of the trigger search by mls."""
  fr_rets_lis_addi_info_id: [RetsListingAdditionalInfoFindInputWhere!]

  """Rets listing agent id of the trigger search by mls."""
  fr_rets_list_agent_id: [RetsListingAgentFindInputWhere!]

  """Rets listing office id of the trigger search by mls."""
  fr_rets_list_office_id: [RetsListingOfficeFindInputWhere!]

  """Rets listing open house id of the trigger search by mls."""
  fr_rets_list_open_house_id: [RetsListingOpenHouseFindInputWhere!]

  """Rets listing photos id of the trigger search by mls."""
  fr_rets_list_photos_id: [RetsListingPhotosFindInputWhere!]

  """Rets listing room id of the trigger search by mls."""
  fr_rets_list_room_id: [RetsListingRoomFindInputWhere!]

  """Rets listing unit id of the trigger search by mls."""
  fr_rets_list_unit_id: [RetsListingUnitFindInputWhere!]

  """Rets listing virtual tour id of the trigger search by mls."""
  fr_rets_list_virtual_tours_id: [RetsListingVirtualToursFindInputWhere!]
}

type RetsMlsProviderSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [RetsMlsProviderEntity!]!
}

input RetsMlsProviderUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [RetsMlsProviderUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: RetsMlsProviderUpdateInputSets!
}

input RetsMlsProviderUpdateInputSets {
  """Market Name"""
  market_name: String

  """A descriptive title of the market."""
  market_title: String

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: YesNoEnum

  """The host or domain name of the server hosting the MLS system."""
  host: String

  """The username used to authenticate the connection to the MLS system."""
  user: String

  """
  The password associated with the username for authenticating the connection.
  """
  passwd: String

  """Rets user agent."""
  rets_user_agent: String

  """Rets user agent password."""
  rets_user_agent_pwd: String

  """Indicates whether the API is active or inactive."""
  is_API: YesNoEnum

  """A unique identifier for the client using the MLS API."""
  client_id: String

  """A secret key associated with the Client ID."""
  client_secret: String

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: String

  """A token used to authenticate browser-based requests to the MLS system."""
  browser_token: String

  """The version of the RETS"""
  rets_version: String

  """Format"""
  format: String

  """A short disclaimer that is displayed to users."""
  disclaimer_short: String

  """A more detailed or extended version of the disclaimer."""
  disclaimer_big: String

  """An icon or image associated with the disclaimer."""
  disclaimer_icon: String

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: YesNoEnum

  """Indicates whether the market is active or inactive."""
  active: YesNoEnum

  """Indicates whether property data download is enabled or not."""
  prop_data_download: String

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: String

  """Indicates whether office data download is enabled or not."""
  office_data_download: String

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: String
}

input RetsMlsProviderUpdateInputWhere {
  """Unique ID of the rets MLS provider, auto generated."""
  id: FindOperatorDto

  """Market Name"""
  market_name: FindOperatorDto

  """A descriptive title of the market."""
  market_title: FindOperatorDto

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: FindOperatorDto

  """The username used to authenticate the connection to the MLS system."""
  user: FindOperatorDto

  """Rets user agent."""
  rets_user_agent: FindOperatorDto

  """Indicates whether the API is active or inactive."""
  is_API: FindOperatorDto

  """A unique identifier for the client using the MLS API."""
  client_id: FindOperatorDto

  """A secret key associated with the Client ID."""
  client_secret: FindOperatorDto

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: FindOperatorDto

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: FindOperatorDto

  """Indicates whether the market is active or inactive."""
  active: FindOperatorDto

  """
  The date and time when the property data download process was last executed.
  """
  prop_last_run_date: FindOperatorDto

  """
  The date when the most recent property data record was added or updated.
  """
  prop_last_record_date: FindOperatorDto

  """The date and time when the ID-related data process was last executed."""
  id_last_run_date: FindOperatorDto

  """
  The date when the most recent ID-related data record was added or updated.
  """
  id_last_record_date: FindOperatorDto

  """Indicates whether a property data job is currently running."""
  prop_data_job_running: FindOperatorDto

  """Indicates whether the property ID job is currently running."""
  prop_id_job_running: FindOperatorDto

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: FindOperatorDto

  """
  The date and time when the agent data download process was last executed.
  """
  agent_last_run_date: FindOperatorDto

  """Indicates whether office data download is enabled or not."""
  office_data_download: FindOperatorDto

  """
  The date and time when the office last run date process was last executed.
  """
  office_last_run_date: FindOperatorDto

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: FindOperatorDto

  """Indicates whether the picture data job is currently running or not."""
  pic_data_job_running: FindOperatorDto

  """Indicates the last successful data synchronization."""
  data_last_sync_success: FindOperatorDto

  """The ID of the last successful synchronization event."""
  id_last_sync_success: FindOperatorDto

  """The expiration time of the authentication token."""
  token_expire_time: FindOperatorDto

  """The total count of synchronization runs for the ID data."""
  id_srun_total_count: FindOperatorDto

  """
  The current count of ongoing or completed synchronization runs for the ID data.
  """
  id_srun_cur_count: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_user_favourite_mlsp_id: [UserFavouritePropertyFindInputWhere!]

  """MLSP ID of the trigger search by address."""
  fr_search_by_addr_mlsp_id: [ProcessedSearchByAddressFindInputWhere!]

  """MLSP ID of the trigger search by city."""
  fr_search_by_city_mlsp_id: [ProcessedSearchByCityFindInputWhere!]

  """MLSP ID of the trigger search by subdivision."""
  fr_search_by_subdivision_mlsp_id: [ProcessedSearchBySubdivisionFindInputWhere!]

  """MLSP ID of the trigger search by zipcode."""
  fr_search_by_zipcode_mlsp_id: [ProcessedSearchByZipcodeFindInputWhere!]

  """MLSP ID of the trigger search by mls."""
  fr_search_by_mls_mlsp_id: [ProcessedSearchByMlsFindInputWhere!]

  """Rets listing ID of the trigger search by mls."""
  fr_rets_listing_id: [RetsListingFindInputWhere!]

  """Rets listing additional info ID of the trigger search by mls."""
  fr_rets_lis_addi_info_id: [RetsListingAdditionalInfoFindInputWhere!]

  """Rets listing agent id of the trigger search by mls."""
  fr_rets_list_agent_id: [RetsListingAgentFindInputWhere!]

  """Rets listing office id of the trigger search by mls."""
  fr_rets_list_office_id: [RetsListingOfficeFindInputWhere!]

  """Rets listing open house id of the trigger search by mls."""
  fr_rets_list_open_house_id: [RetsListingOpenHouseFindInputWhere!]

  """Rets listing photos id of the trigger search by mls."""
  fr_rets_list_photos_id: [RetsListingPhotosFindInputWhere!]

  """Rets listing room id of the trigger search by mls."""
  fr_rets_list_room_id: [RetsListingRoomFindInputWhere!]

  """Rets listing unit id of the trigger search by mls."""
  fr_rets_list_unit_id: [RetsListingUnitFindInputWhere!]

  """Rets listing virtual tour id of the trigger search by mls."""
  fr_rets_list_virtual_tours_id: [RetsListingVirtualToursFindInputWhere!]
}

type RetsMlsProviderUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [RetsMlsProviderEntity!]!
}

input RetsMlsProviderUpsertInput {
  """Market Name"""
  market_name: String!

  """A descriptive title of the market."""
  market_title: String

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: YesNoEnum!

  """The host or domain name of the server hosting the MLS system."""
  host: String!

  """The username used to authenticate the connection to the MLS system."""
  user: String!

  """
  The password associated with the username for authenticating the connection.
  """
  passwd: String!

  """Rets user agent."""
  rets_user_agent: String!

  """Rets user agent password."""
  rets_user_agent_pwd: String

  """Indicates whether the API is active or inactive."""
  is_API: YesNoEnum!

  """A unique identifier for the client using the MLS API."""
  client_id: String

  """A secret key associated with the Client ID."""
  client_secret: String

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: String

  """A token used to authenticate browser-based requests to the MLS system."""
  browser_token: String

  """The version of the RETS"""
  rets_version: String!

  """Format"""
  format: String!

  """A short disclaimer that is displayed to users."""
  disclaimer_short: String

  """A more detailed or extended version of the disclaimer."""
  disclaimer_big: String

  """An icon or image associated with the disclaimer."""
  disclaimer_icon: String

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: YesNoEnum!

  """Indicates whether the market is active or inactive."""
  active: YesNoEnum!

  """Indicates whether property data download is enabled or not."""
  prop_data_download: String!

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: String!

  """Indicates whether office data download is enabled or not."""
  office_data_download: String!

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: String!

  """Unique ID of the rets MLS provider, auto generated. undefined"""
  id: Int
}

type RetsMlsProviderUpsertOutput {
  """Unique ID of the rets MLS provider, auto generated."""
  id: Int

  """Market Name"""
  market_name: String

  """A descriptive title of the market."""
  market_title: String

  """
  Indicates whether the market is active or inactive. A value of true represents an active market, while false indicates that the market is currently inactive or no longer in use.
  """
  market_active: YesNoEnum

  """The host or domain name of the server hosting the MLS system."""
  host: String

  """The username used to authenticate the connection to the MLS system."""
  user: String

  """
  The password associated with the username for authenticating the connection.
  """
  passwd: String

  """Rets user agent."""
  rets_user_agent: String

  """Rets user agent password."""
  rets_user_agent_pwd: String

  """Indicates whether the API is active or inactive."""
  is_API: YesNoEnum

  """A unique identifier for the client using the MLS API."""
  client_id: String

  """A secret key associated with the Client ID."""
  client_secret: String

  """
  A token provided by the server for authenticating requests from the client to the MLS API.
  """
  server_token: String

  """A token used to authenticate browser-based requests to the MLS system."""
  browser_token: String

  """The version of the RETS"""
  rets_version: String

  """Format"""
  format: String

  """A short disclaimer that is displayed to users."""
  disclaimer_short: String

  """A more detailed or extended version of the disclaimer."""
  disclaimer_big: String

  """An icon or image associated with the disclaimer."""
  disclaimer_icon: String

  """Indicates whether Picture URL supported or not."""
  is_pic_url_supported: YesNoEnum

  """Indicates whether the market is active or inactive."""
  active: YesNoEnum

  """Indicates whether property data download is enabled or not."""
  prop_data_download: String

  """
  The date and time when the property data download process was last executed.
  """
  prop_last_run_date: String

  """
  The date when the most recent property data record was added or updated.
  """
  prop_last_record_date: String

  """The date and time when the ID-related data process was last executed."""
  id_last_run_date: String

  """
  The date when the most recent ID-related data record was added or updated.
  """
  id_last_record_date: String

  """Indicates whether agent data download is enabled or not."""
  agent_data_download: String

  """
  The date and time when the agent data download process was last executed.
  """
  agent_last_run_date: String

  """Indicates whether office data download is enabled or not."""
  office_data_download: String

  """
  The date and time when the office last run date process was last executed.
  """
  office_last_run_date: String

  """Indicates whether picture data download is enabled or not."""
  pic_data_download: String

  """
  The date and time when the picture data download process was last executed.
  """
  pic_last_run_datetime: DateTime

  """Token URL for accessing the MLS system's API."""
  token_url: String

  """The expiration time of the authentication token."""
  token_expire_time: DateTime

  """MLSP ID of the user favourite property."""
  fr_user_favourite_mlsp_id: [UserFavouritePropertyEntity!]

  """MLSP ID of the trigger search by address."""
  fr_search_by_addr_mlsp_id: [ProcessedSearchByAddressEntity!]

  """MLSP ID of the trigger search by city."""
  fr_search_by_city_mlsp_id: [ProcessedSearchByCityEntity!]

  """MLSP ID of the trigger search by subdivision."""
  fr_search_by_subdivision_mlsp_id: [ProcessedSearchBySubdivisionEntity!]

  """MLSP ID of the trigger search by zipcode."""
  fr_search_by_zipcode_mlsp_id: [ProcessedSearchByZipcodeEntity!]

  """MLSP ID of the trigger search by mls."""
  fr_search_by_mls_mlsp_id: [ProcessedSearchByMlsEntity!]

  """Rets listing ID of the trigger search by mls."""
  fr_rets_listing_id: [RetsListingEntity!]

  """Rets listing additional info ID of the trigger search by mls."""
  fr_rets_lis_addi_info_id: [RetsListingAdditionalInfoEntity!]

  """Rets listing agent id of the trigger search by mls."""
  fr_rets_list_agent_id: [RetsListingAgentEntity!]

  """Rets listing office id of the trigger search by mls."""
  fr_rets_list_office_id: [RetsListingOfficeEntity!]

  """Rets listing open house id of the trigger search by mls."""
  fr_rets_list_open_house_id: [RetsListingOpenHouseEntity!]

  """Rets listing photos id of the trigger search by mls."""
  fr_rets_list_photos_id: [RetsListingPhotosEntity!]

  """Rets listing room id of the trigger search by mls."""
  fr_rets_list_room_id: [RetsListingRoomEntity!]

  """Rets listing unit id of the trigger search by mls."""
  fr_rets_list_unit_id: [RetsListingUnitEntity!]

  """Rets listing virtual tour id of the trigger search by mls."""
  fr_rets_list_virtual_tours_id: [RetsListingVirtualToursEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input SessionCreateInput {
  """Authentication id of the user."""
  auth_id: Int!

  """Registered device id used by user."""
  device_id: Int!

  """Is user logged in or not flag."""
  logged_in: YesNoEnum! = NO

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum! = NO

  """JWT token of the user session."""
  jwt: String

  """Session data storage in JSON format for the user."""
  data: String
}

type SessionCreateOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Authentication id of the user."""
  auth_id: Int

  """Registered device id used by user."""
  device_id: Int

  """Is user logged in or not flag."""
  logged_in: YesNoEnum

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum

  """JWT token of the user session."""
  jwt: JWT

  """Session data storage in JSON format for the user."""
  data: String

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: DeviceEntity

  """Authentication info of the session user."""
  fr_user_auth: UserAuthenticationEntity

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaEntity!]
}

input SessionDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionDeleteInputWhere!]
}

input SessionDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Authentication id of the user."""
  auth_id: FindOperatorDto

  """Registered device id used by user."""
  device_id: FindOperatorDto

  """Is user logged in or not flag."""
  logged_in: FindOperatorDto

  """Keep user logged in or not flag."""
  keep_logged: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: [DeviceFindInputWhere!]

  """Authentication info of the session user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaFindInputWhere!]
}

type SessionDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type SessionEntity {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Authentication id of the user."""
  auth_id: Int

  """Registered device id used by user."""
  device_id: Int

  """Is user logged in or not flag."""
  logged_in: YesNoEnum

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum

  """JWT token of the user session."""
  jwt: JWT

  """Session data storage in JSON format for the user."""
  data: String

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: DeviceEntity

  """Authentication info of the session user."""
  fr_user_auth: UserAuthenticationEntity

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaEntity!]
}

input SessionFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: SessionFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: SessionFindInputSortOrder
}

input SessionFindInputGroupBy {
  auth_id: Boolean
  device_id: Boolean
  logged_in: Boolean
  keep_logged: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input SessionFindInputSortOrder {
  id: RecordSortDirectionEnum
  auth_id: RecordSortDirectionEnum
  device_id: RecordSortDirectionEnum
  logged_in: RecordSortDirectionEnum
  keep_logged: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input SessionFindInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Authentication id of the user."""
  auth_id: FindOperatorDto

  """Registered device id used by user."""
  device_id: FindOperatorDto

  """Is user logged in or not flag."""
  logged_in: FindOperatorDto

  """Keep user logged in or not flag."""
  keep_logged: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: [DeviceFindInputWhere!]

  """Authentication info of the session user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaFindInputWhere!]
}

input SessionFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type SessionFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [SessionFindOutputRows!]!
}

type SessionFindOutputRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Authentication id of the user."""
  auth_id: Int

  """Registered device id used by user."""
  device_id: Int

  """Is user logged in or not flag."""
  logged_in: YesNoEnum

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum

  """JWT token of the user session."""
  jwt: JWT

  """Session data storage in JSON format for the user."""
  data: String

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: DeviceEntity

  """Authentication info of the session user."""
  fr_user_auth: UserAuthenticationEntity

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaEntity!]
}

input SessionMetaCreateInput {
  """Session client id."""
  sess_id: Int!

  """IP address of the user."""
  ip: String!

  """Latitude of the user."""
  latitude: Float!

  """Longitude of the user."""
  longitude: Float!

  """Is user location tracked or not."""
  tracked: DateTime

  """Latitude of the user when location is tracked."""
  tracked_latitude: Float!

  """Longitude of the user when location is tracked."""
  tracked_longitude: Float!
}

type SessionMetaCreateOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Session client id."""
  sess_id: Int

  """IP address of the user."""
  ip: String

  """Latitude of the user."""
  latitude: Float

  """Longitude of the user."""
  longitude: Float

  """Is user location tracked or not."""
  tracked: DateTime

  """Latitude of the user when location is tracked."""
  tracked_latitude: Float

  """Longitude of the user when location is tracked."""
  tracked_longitude: Float

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """Session information of the session meta."""
  fr_session: SessionEntity
}

input SessionMetaDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionMetaDeleteInputWhere!]
}

input SessionMetaDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Session client id."""
  sess_id: FindOperatorDto

  """IP address of the user."""
  ip: FindOperatorDto

  """Latitude of the user."""
  latitude: FindOperatorDto

  """Longitude of the user."""
  longitude: FindOperatorDto

  """Is user location tracked or not."""
  tracked: FindOperatorDto

  """Latitude of the user when location is tracked."""
  tracked_latitude: FindOperatorDto

  """Longitude of the user when location is tracked."""
  tracked_longitude: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto
}

type SessionMetaDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type SessionMetaEntity {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Session client id."""
  sess_id: Int

  """IP address of the user."""
  ip: String

  """Latitude of the user."""
  latitude: Float

  """Longitude of the user."""
  longitude: Float

  """Is user location tracked or not."""
  tracked: DateTime

  """Latitude of the user when location is tracked."""
  tracked_latitude: Float

  """Longitude of the user when location is tracked."""
  tracked_longitude: Float

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """Session information of the session meta."""
  fr_session: SessionEntity
}

input SessionMetaFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionMetaFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: SessionMetaFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: SessionMetaFindInputSortOrder
}

input SessionMetaFindInputGroupBy {
  sess_id: Boolean
  ip: Boolean
  latitude: Boolean
  longitude: Boolean
  tracked: Boolean
  tracked_latitude: Boolean
  tracked_longitude: Boolean
}

input SessionMetaFindInputSortOrder {
  id: RecordSortDirectionEnum
  sess_id: RecordSortDirectionEnum
  ip: RecordSortDirectionEnum
  latitude: RecordSortDirectionEnum
  longitude: RecordSortDirectionEnum
  tracked: RecordSortDirectionEnum
  tracked_latitude: RecordSortDirectionEnum
  tracked_longitude: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
}

input SessionMetaFindInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Session client id."""
  sess_id: FindOperatorDto

  """IP address of the user."""
  ip: FindOperatorDto

  """Latitude of the user."""
  latitude: FindOperatorDto

  """Longitude of the user."""
  longitude: FindOperatorDto

  """Is user location tracked or not."""
  tracked: FindOperatorDto

  """Latitude of the user when location is tracked."""
  tracked_latitude: FindOperatorDto

  """Longitude of the user when location is tracked."""
  tracked_longitude: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto
}

input SessionMetaFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type SessionMetaFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [SessionMetaEntity!]!
}

input SessionMetaRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionMetaRecoverInputWhere!]
}

input SessionMetaRecoverInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Session client id."""
  sess_id: FindOperatorDto

  """IP address of the user."""
  ip: FindOperatorDto

  """Latitude of the user."""
  latitude: FindOperatorDto

  """Longitude of the user."""
  longitude: FindOperatorDto

  """Is user location tracked or not."""
  tracked: FindOperatorDto

  """Latitude of the user when location is tracked."""
  tracked_latitude: FindOperatorDto

  """Longitude of the user when location is tracked."""
  tracked_longitude: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto
}

type SessionMetaRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SessionMetaRecoverOutputAffectedRows!]!
}

type SessionMetaRecoverOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Session client id."""
  sess_id: Int

  """IP address of the user."""
  ip: String

  """Latitude of the user."""
  latitude: Float

  """Longitude of the user."""
  longitude: Float

  """Is user location tracked or not."""
  tracked: DateTime

  """Latitude of the user when location is tracked."""
  tracked_latitude: Float

  """Longitude of the user when location is tracked."""
  tracked_longitude: Float

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """Session information of the session meta."""
  fr_session: SessionEntity
}

input SessionMetaRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionMetaRemoveInputWhere!]
}

input SessionMetaRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Session client id."""
  sess_id: FindOperatorDto

  """IP address of the user."""
  ip: FindOperatorDto

  """Latitude of the user."""
  latitude: FindOperatorDto

  """Longitude of the user."""
  longitude: FindOperatorDto

  """Is user location tracked or not."""
  tracked: FindOperatorDto

  """Latitude of the user when location is tracked."""
  tracked_latitude: FindOperatorDto

  """Longitude of the user when location is tracked."""
  tracked_longitude: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto
}

type SessionMetaRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SessionMetaRemoveOutputAffectedRows!]!
}

type SessionMetaRemoveOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Session client id."""
  sess_id: Int

  """IP address of the user."""
  ip: String

  """Latitude of the user."""
  latitude: Float

  """Longitude of the user."""
  longitude: Float

  """Is user location tracked or not."""
  tracked: DateTime

  """Latitude of the user when location is tracked."""
  tracked_latitude: Float

  """Longitude of the user when location is tracked."""
  tracked_longitude: Float

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """Session information of the session meta."""
  fr_session: SessionEntity
}

input SessionMetaRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionMetaRestoreInputWhere!]
}

input SessionMetaRestoreInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Session client id."""
  sess_id: FindOperatorDto

  """IP address of the user."""
  ip: FindOperatorDto

  """Latitude of the user."""
  latitude: FindOperatorDto

  """Longitude of the user."""
  longitude: FindOperatorDto

  """Is user location tracked or not."""
  tracked: FindOperatorDto

  """Latitude of the user when location is tracked."""
  tracked_latitude: FindOperatorDto

  """Longitude of the user when location is tracked."""
  tracked_longitude: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto
}

type SessionMetaRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SessionMetaSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionMetaSoftDeleteInputWhere!]
}

input SessionMetaSoftDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Session client id."""
  sess_id: FindOperatorDto

  """IP address of the user."""
  ip: FindOperatorDto

  """Latitude of the user."""
  latitude: FindOperatorDto

  """Longitude of the user."""
  longitude: FindOperatorDto

  """Is user location tracked or not."""
  tracked: FindOperatorDto

  """Latitude of the user when location is tracked."""
  tracked_latitude: FindOperatorDto

  """Longitude of the user when location is tracked."""
  tracked_longitude: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto
}

type SessionMetaSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SessionMetaSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionMetaSoftRemoveInputWhere!]
}

input SessionMetaSoftRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Session client id."""
  sess_id: FindOperatorDto

  """IP address of the user."""
  ip: FindOperatorDto

  """Latitude of the user."""
  latitude: FindOperatorDto

  """Longitude of the user."""
  longitude: FindOperatorDto

  """Is user location tracked or not."""
  tracked: FindOperatorDto

  """Latitude of the user when location is tracked."""
  tracked_latitude: FindOperatorDto

  """Longitude of the user when location is tracked."""
  tracked_longitude: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto
}

type SessionMetaSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SessionMetaSoftRemoveOutputAffectedRows!]!
}

type SessionMetaSoftRemoveOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Session client id."""
  sess_id: Int

  """IP address of the user."""
  ip: String

  """Latitude of the user."""
  latitude: Float

  """Longitude of the user."""
  longitude: Float

  """Is user location tracked or not."""
  tracked: DateTime

  """Latitude of the user when location is tracked."""
  tracked_latitude: Float

  """Longitude of the user when location is tracked."""
  tracked_longitude: Float

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """Session information of the session meta."""
  fr_session: SessionEntity
}

input SessionMetaUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionMetaUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: SessionMetaUpdateInputSets!
}

input SessionMetaUpdateInputSets {
  """Session client id."""
  sess_id: Int

  """IP address of the user."""
  ip: String

  """Latitude of the user."""
  latitude: Float

  """Longitude of the user."""
  longitude: Float

  """Is user location tracked or not."""
  tracked: DateTime

  """Latitude of the user when location is tracked."""
  tracked_latitude: Float

  """Longitude of the user when location is tracked."""
  tracked_longitude: Float
}

input SessionMetaUpdateInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Session client id."""
  sess_id: FindOperatorDto

  """IP address of the user."""
  ip: FindOperatorDto

  """Latitude of the user."""
  latitude: FindOperatorDto

  """Longitude of the user."""
  longitude: FindOperatorDto

  """Is user location tracked or not."""
  tracked: FindOperatorDto

  """Latitude of the user when location is tracked."""
  tracked_latitude: FindOperatorDto

  """Longitude of the user when location is tracked."""
  tracked_longitude: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto
}

type SessionMetaUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [SessionMetaUpdateOutputAffectedRows!]!
}

type SessionMetaUpdateOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Session client id."""
  sess_id: Int

  """IP address of the user."""
  ip: String

  """Latitude of the user."""
  latitude: Float

  """Longitude of the user."""
  longitude: Float

  """Is user location tracked or not."""
  tracked: DateTime

  """Latitude of the user when location is tracked."""
  tracked_latitude: Float

  """Longitude of the user when location is tracked."""
  tracked_longitude: Float

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """Session information of the session meta."""
  fr_session: SessionEntity
}

input SessionMetaUpsertInput {
  """Session client id."""
  sess_id: Int!

  """IP address of the user."""
  ip: String!

  """Latitude of the user."""
  latitude: Float!

  """Longitude of the user."""
  longitude: Float!

  """Is user location tracked or not."""
  tracked: DateTime

  """Latitude of the user when location is tracked."""
  tracked_latitude: Float!

  """Longitude of the user when location is tracked."""
  tracked_longitude: Float!

  """Unique ID of the entity, auto generated. undefined"""
  id: Int
}

type SessionMetaUpsertOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Session client id."""
  sess_id: Int

  """IP address of the user."""
  ip: String

  """Latitude of the user."""
  latitude: Float

  """Longitude of the user."""
  longitude: Float

  """Is user location tracked or not."""
  tracked: DateTime

  """Latitude of the user when location is tracked."""
  tracked_latitude: Float

  """Longitude of the user when location is tracked."""
  tracked_longitude: Float

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """Session information of the session meta."""
  fr_session: SessionEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input SessionRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionRecoverInputWhere!]
}

input SessionRecoverInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Authentication id of the user."""
  auth_id: FindOperatorDto

  """Registered device id used by user."""
  device_id: FindOperatorDto

  """Is user logged in or not flag."""
  logged_in: FindOperatorDto

  """Keep user logged in or not flag."""
  keep_logged: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: [DeviceFindInputWhere!]

  """Authentication info of the session user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaFindInputWhere!]
}

type SessionRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SessionRecoverOutputAffectedRows!]!
}

type SessionRecoverOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Authentication id of the user."""
  auth_id: Int

  """Registered device id used by user."""
  device_id: Int

  """Is user logged in or not flag."""
  logged_in: YesNoEnum

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum

  """JWT token of the user session."""
  jwt: JWT

  """Session data storage in JSON format for the user."""
  data: String

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: DeviceEntity

  """Authentication info of the session user."""
  fr_user_auth: UserAuthenticationEntity

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaEntity!]
}

input SessionRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionRemoveInputWhere!]
}

input SessionRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Authentication id of the user."""
  auth_id: FindOperatorDto

  """Registered device id used by user."""
  device_id: FindOperatorDto

  """Is user logged in or not flag."""
  logged_in: FindOperatorDto

  """Keep user logged in or not flag."""
  keep_logged: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: [DeviceFindInputWhere!]

  """Authentication info of the session user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaFindInputWhere!]
}

type SessionRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SessionRemoveOutputAffectedRows!]!
}

type SessionRemoveOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Authentication id of the user."""
  auth_id: Int

  """Registered device id used by user."""
  device_id: Int

  """Is user logged in or not flag."""
  logged_in: YesNoEnum

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum

  """JWT token of the user session."""
  jwt: JWT

  """Session data storage in JSON format for the user."""
  data: String

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: DeviceEntity

  """Authentication info of the session user."""
  fr_user_auth: UserAuthenticationEntity

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaEntity!]
}

input SessionRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionRestoreInputWhere!]
}

input SessionRestoreInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Authentication id of the user."""
  auth_id: FindOperatorDto

  """Registered device id used by user."""
  device_id: FindOperatorDto

  """Is user logged in or not flag."""
  logged_in: FindOperatorDto

  """Keep user logged in or not flag."""
  keep_logged: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: [DeviceFindInputWhere!]

  """Authentication info of the session user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaFindInputWhere!]
}

type SessionRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SessionSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionSoftDeleteInputWhere!]
}

input SessionSoftDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Authentication id of the user."""
  auth_id: FindOperatorDto

  """Registered device id used by user."""
  device_id: FindOperatorDto

  """Is user logged in or not flag."""
  logged_in: FindOperatorDto

  """Keep user logged in or not flag."""
  keep_logged: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: [DeviceFindInputWhere!]

  """Authentication info of the session user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaFindInputWhere!]
}

type SessionSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SessionSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionSoftRemoveInputWhere!]
}

input SessionSoftRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Authentication id of the user."""
  auth_id: FindOperatorDto

  """Registered device id used by user."""
  device_id: FindOperatorDto

  """Is user logged in or not flag."""
  logged_in: FindOperatorDto

  """Keep user logged in or not flag."""
  keep_logged: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: [DeviceFindInputWhere!]

  """Authentication info of the session user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaFindInputWhere!]
}

type SessionSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SessionSoftRemoveOutputAffectedRows!]!
}

type SessionSoftRemoveOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Authentication id of the user."""
  auth_id: Int

  """Registered device id used by user."""
  device_id: Int

  """Is user logged in or not flag."""
  logged_in: YesNoEnum

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum

  """JWT token of the user session."""
  jwt: JWT

  """Session data storage in JSON format for the user."""
  data: String

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: DeviceEntity

  """Authentication info of the session user."""
  fr_user_auth: UserAuthenticationEntity

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaEntity!]
}

input SessionUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SessionUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: SessionUpdateInputSets!
}

input SessionUpdateInputSets {
  """Authentication id of the user."""
  auth_id: Int

  """Registered device id used by user."""
  device_id: Int

  """Is user logged in or not flag."""
  logged_in: YesNoEnum = NO

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum = NO

  """JWT token of the user session."""
  jwt: String

  """Session data storage in JSON format for the user."""
  data: String
}

input SessionUpdateInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """Authentication id of the user."""
  auth_id: FindOperatorDto

  """Registered device id used by user."""
  device_id: FindOperatorDto

  """Is user logged in or not flag."""
  logged_in: FindOperatorDto

  """Keep user logged in or not flag."""
  keep_logged: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: [DeviceFindInputWhere!]

  """Authentication info of the session user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaFindInputWhere!]
}

type SessionUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [SessionUpdateOutputAffectedRows!]!
}

type SessionUpdateOutputAffectedRows {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Authentication id of the user."""
  auth_id: Int

  """Registered device id used by user."""
  device_id: Int

  """Is user logged in or not flag."""
  logged_in: YesNoEnum

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum

  """JWT token of the user session."""
  jwt: JWT

  """Session data storage in JSON format for the user."""
  data: String

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: DeviceEntity

  """Authentication info of the session user."""
  fr_user_auth: UserAuthenticationEntity

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaEntity!]
}

input SessionUpsertInput {
  """Authentication id of the user."""
  auth_id: Int!

  """Registered device id used by user."""
  device_id: Int!

  """Is user logged in or not flag."""
  logged_in: YesNoEnum! = NO

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum! = NO

  """JWT token of the user session."""
  jwt: String

  """Session data storage in JSON format for the user."""
  data: String

  """Unique ID of the entity, auto generated. undefined"""
  id: Int
}

type SessionUpsertOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """Authentication id of the user."""
  auth_id: Int

  """Registered device id used by user."""
  device_id: Int

  """Is user logged in or not flag."""
  logged_in: YesNoEnum

  """Keep user logged in or not flag."""
  keep_logged: YesNoEnum

  """JWT token of the user session."""
  jwt: JWT

  """Session data storage in JSON format for the user."""
  data: String

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """
  Master device info of the session user. Make sure that this is not directly connected with UserDeviceEntity.
  """
  fr_device: DeviceEntity

  """Authentication info of the session user."""
  fr_user_auth: UserAuthenticationEntity

  """Session meta info of the session user."""
  fr_session_metas: [SessionMetaEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input SettingCategoryCreateInput {
  """Title of the setting category."""
  title: String!

  """Description of the setting category."""
  desc: String
}

type SettingCategoryCreateOutput {
  """Unique ID of the setting category, auto generated."""
  id: Int

  """Title of the setting category."""
  title: String

  """Description of the setting category."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Setting of Setting category"""
  fr_setting: [SettingEntity!]
}

input SettingCategoryDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingCategoryDeleteInputWhere!]
}

input SettingCategoryDeleteInputWhere {
  """Unique ID of the setting category, auto generated."""
  id: FindOperatorDto

  """Title of the setting category."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting of Setting category"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingCategoryDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type SettingCategoryEntity {
  """Unique ID of the setting category, auto generated."""
  id: Int

  """Title of the setting category."""
  title: String

  """Description of the setting category."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Setting of Setting category"""
  fr_setting: [SettingEntity!]
}

input SettingCategoryFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingCategoryFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: SettingCategoryFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: SettingCategoryFindInputSortOrder
}

input SettingCategoryFindInputGroupBy {
  title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input SettingCategoryFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input SettingCategoryFindInputWhere {
  """Unique ID of the setting category, auto generated."""
  id: FindOperatorDto

  """Title of the setting category."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting of Setting category"""
  fr_setting: [SettingFindInputWhere!]
}

input SettingCategoryFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type SettingCategoryFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [SettingCategoryEntity!]!
}

input SettingCategoryRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingCategoryRecoverInputWhere!]
}

input SettingCategoryRecoverInputWhere {
  """Unique ID of the setting category, auto generated."""
  id: FindOperatorDto

  """Title of the setting category."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting of Setting category"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingCategoryRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingCategoryEntity!]!
}

input SettingCategoryRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingCategoryRemoveInputWhere!]
}

input SettingCategoryRemoveInputWhere {
  """Unique ID of the setting category, auto generated."""
  id: FindOperatorDto

  """Title of the setting category."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting of Setting category"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingCategoryRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingCategoryEntity!]!
}

input SettingCategoryRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingCategoryRestoreInputWhere!]
}

input SettingCategoryRestoreInputWhere {
  """Unique ID of the setting category, auto generated."""
  id: FindOperatorDto

  """Title of the setting category."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting of Setting category"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingCategoryRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SettingCategorySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingCategorySoftDeleteInputWhere!]
}

input SettingCategorySoftDeleteInputWhere {
  """Unique ID of the setting category, auto generated."""
  id: FindOperatorDto

  """Title of the setting category."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting of Setting category"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingCategorySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SettingCategorySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingCategorySoftRemoveInputWhere!]
}

input SettingCategorySoftRemoveInputWhere {
  """Unique ID of the setting category, auto generated."""
  id: FindOperatorDto

  """Title of the setting category."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting of Setting category"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingCategorySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingCategoryEntity!]!
}

input SettingCategoryUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingCategoryUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: SettingCategoryUpdateInputSets!
}

input SettingCategoryUpdateInputSets {
  """Title of the setting category."""
  title: String

  """Description of the setting category."""
  desc: String
}

input SettingCategoryUpdateInputWhere {
  """Unique ID of the setting category, auto generated."""
  id: FindOperatorDto

  """Title of the setting category."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting of Setting category"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingCategoryUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [SettingCategoryEntity!]!
}

input SettingCategoryUpsertInput {
  """Title of the setting category."""
  title: String!

  """Description of the setting category."""
  desc: String

  """Unique ID of the setting category, auto generated. undefined"""
  id: Int
}

type SettingCategoryUpsertOutput {
  """Unique ID of the setting category, auto generated."""
  id: Int

  """Title of the setting category."""
  title: String

  """Description of the setting category."""
  desc: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Setting of Setting category"""
  fr_setting: [SettingEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input SettingCreateInput {
  """Key of the setting."""
  key: String!

  """Category ID of the setting category."""
  settc_id: Int!

  """Type ID of the setting type."""
  settty_id: Int!

  """Form control type ID of the form control type."""
  frmfield_id: Int!

  """Device ID of the device."""
  device_id: Int

  """Static data ID of the static data."""
  sd_id: Int

  """Slug name of the static data."""
  sd_name: String

  """Static data value ID."""
  default_sdv_id: Int

  """Static data value slug."""
  default_sdv_key: String

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: String

  """
  Default value when any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  default_plain_value: String

  """Access whether config is available for end user or internal purpose."""
  access_type: AccessTypeEnum! = PUBLIC

  """title of the setting."""
  title: String!

  """Display title of the setting."""
  display_title: String!

  """Guideline of the setting."""
  guideline: String!
}

type SettingCreateOutput {
  """Unique ID of the staticvalue, auto generated."""
  id: Int

  """Key of the setting."""
  key: String

  """Type ID of the setting type."""
  settty_id: Int

  """Category ID of the setting category."""
  settc_id: Int

  """Form control type ID of the form control type."""
  frmfield_id: Int

  """Device ID of the device."""
  device_id: Int

  """Static data ID of the static data."""
  sd_id: Int

  """Slug name of the static data."""
  sd_name: String

  """Static data value ID."""
  default_sdv_id: Int

  """Static data value slug."""
  default_sdv_key: String

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: String

  """
  Default value when any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  default_plain_value: String

  """Access whether config is available for end user or internal purpose."""
  access_type: AccessTypeEnum

  """title of the setting."""
  title: String

  """Display title of the setting."""
  display_title: String

  """Guideline of the setting."""
  guideline: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """catetegorys of Setting"""
  fr_setting_categorys: SettingCategoryEntity

  """Setting type of setting"""
  fr_setting_types: SettingTypeEntity

  """Setting control type of setting"""
  fr_form_fields: FormFieldEntity

  """devices of setting"""
  fr_devices: DeviceEntity

  """Static datas of setting """
  fr_static_datas: StaticDataEntity

  """Static data value preference of setting """
  fr_static_data_values: StaticDataValueEntity

  """Setting preference of setting """
  fr_setting_preference: [SettingPreferenceEntity!]
}

input SettingDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingDeleteInputWhere!]
}

input SettingDeleteInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Key of the setting."""
  key: FindOperatorDto

  """Category ID of the setting category."""
  settc_id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """Form control type ID of the form control type."""
  frmfield_id: FindOperatorDto

  """Device ID of the device."""
  device_id: FindOperatorDto

  """Static data ID of the static data."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  default_sdv_id: FindOperatorDto

  """Static data value slug."""
  default_sdv_key: FindOperatorDto

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: FindOperatorDto

  """Access whether config is available for end user or internal purpose."""
  access_type: FindOperatorDto

  """title of the setting."""
  title: FindOperatorDto

  """Display title of the setting."""
  display_title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """catetegorys of Setting"""
  fr_setting_categorys: [SettingCategoryFindInputWhere!]

  """Setting type of setting"""
  fr_setting_types: [SettingTypeFindInputWhere!]

  """Setting control type of setting"""
  fr_form_fields: [FormFieldFindInputWhere!]

  """devices of setting"""
  fr_devices: [DeviceFindInputWhere!]

  """Static datas of setting """
  fr_static_datas: [StaticDataFindInputWhere!]

  """Setting preference of setting """
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Static data value preference of setting """
  fr_static_data_values: [StaticDataValueFindInputWhere!]
}

type SettingDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type SettingEntity {
  """Unique ID of the staticvalue, auto generated."""
  id: Int

  """Key of the setting."""
  key: String

  """Type ID of the setting type."""
  settty_id: Int

  """Category ID of the setting category."""
  settc_id: Int

  """Form control type ID of the form control type."""
  frmfield_id: Int

  """Device ID of the device."""
  device_id: Int

  """Static data ID of the static data."""
  sd_id: Int

  """Slug name of the static data."""
  sd_name: String

  """Static data value ID."""
  default_sdv_id: Int

  """Static data value slug."""
  default_sdv_key: String

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: String

  """
  Default value when any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  default_plain_value: String

  """Access whether config is available for end user or internal purpose."""
  access_type: AccessTypeEnum

  """title of the setting."""
  title: String

  """Display title of the setting."""
  display_title: String

  """Guideline of the setting."""
  guideline: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """catetegorys of Setting"""
  fr_setting_categorys: SettingCategoryEntity

  """Setting type of setting"""
  fr_setting_types: SettingTypeEntity

  """Setting control type of setting"""
  fr_form_fields: FormFieldEntity

  """devices of setting"""
  fr_devices: DeviceEntity

  """Static datas of setting """
  fr_static_datas: StaticDataEntity

  """Static data value preference of setting """
  fr_static_data_values: StaticDataValueEntity

  """Setting preference of setting """
  fr_setting_preference: [SettingPreferenceEntity!]
}

input SettingFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: SettingFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: SettingFindInputSortOrder
}

input SettingFindInputGroupBy {
  key: Boolean
  settc_id: Boolean
  settty_id: Boolean
  frmfield_id: Boolean
  device_id: Boolean
  sd_id: Boolean
  sd_name: Boolean
  default_sdv_id: Boolean
  default_sdv_key: Boolean
  default_sdt_key: Boolean
  access_type: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input SettingFindInputSortOrder {
  id: RecordSortDirectionEnum
  key: RecordSortDirectionEnum
  settc_id: RecordSortDirectionEnum
  settty_id: RecordSortDirectionEnum
  frmfield_id: RecordSortDirectionEnum
  device_id: RecordSortDirectionEnum
  sd_id: RecordSortDirectionEnum
  sd_name: RecordSortDirectionEnum
  default_sdv_id: RecordSortDirectionEnum
  default_sdv_key: RecordSortDirectionEnum
  default_sdt_key: RecordSortDirectionEnum
  access_type: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  display_title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input SettingFindInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Key of the setting."""
  key: FindOperatorDto

  """Category ID of the setting category."""
  settc_id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """Form control type ID of the form control type."""
  frmfield_id: FindOperatorDto

  """Device ID of the device."""
  device_id: FindOperatorDto

  """Static data ID of the static data."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  default_sdv_id: FindOperatorDto

  """Static data value slug."""
  default_sdv_key: FindOperatorDto

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: FindOperatorDto

  """Access whether config is available for end user or internal purpose."""
  access_type: FindOperatorDto

  """title of the setting."""
  title: FindOperatorDto

  """Display title of the setting."""
  display_title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """catetegorys of Setting"""
  fr_setting_categorys: [SettingCategoryFindInputWhere!]

  """Setting type of setting"""
  fr_setting_types: [SettingTypeFindInputWhere!]

  """Setting control type of setting"""
  fr_form_fields: [FormFieldFindInputWhere!]

  """devices of setting"""
  fr_devices: [DeviceFindInputWhere!]

  """Static datas of setting """
  fr_static_datas: [StaticDataFindInputWhere!]

  """Setting preference of setting """
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Static data value preference of setting """
  fr_static_data_values: [StaticDataValueFindInputWhere!]
}

input SettingFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type SettingFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [SettingEntity!]!
}

input SettingJsonInput {
  """Choose setting type to retrive settings."""
  setting_type: [SettingTypeEnum!]

  """
  Choose response json type. There are total 3 types of architecture. Default is RAW.
  """
  json_type: SettingJsonTypeEnum
}

"""SettingType to retrive specific settings with specific format of JSON"""
enum SettingJsonTypeEnum {
  """
  Single dymential setting. Response json will be single dimensional { key: setting }. This is default.
  """
  RAW

  """
  All settings grouped by setting type. Response json will be two dimensional {settype: { key: setting }}.
  """
  BY_SETTYPE

  """
  All settings grouped by setting category. Setting type will be added by default so response will be three dimensional {settype: { categoty: { key: setting }}}.
  """
  BY_CATEGORY
}

input SettingPreferenceCreateInput {
  """Type ID of the setting type."""
  settty_id: Int!

  """Setting ID of the setting."""
  sett_id: Int!

  """Setting slug."""
  sett_key: String!

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: String

  """Static data id in case if any applicable."""
  sd_id: Int

  """Static data slug in case if any applicable."""
  sd_name: String

  """Static data value ID."""
  sdv_id: Int

  """Static data value slug."""
  sdv_key: String

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: String

  """
  When any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  plain_value: String
}

type SettingPreferenceCreateOutput {
  """Unique ID of the staticvalue, auto generated."""
  id: Int

  """Type ID of the setting type."""
  settty_id: Int

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: String

  """Setting ID of the setting."""
  sett_id: Int

  """Setting slug."""
  sett_key: String

  """Static data id in case if any applicable."""
  sd_id: Int

  """Static data slug in case if any applicable."""
  sd_name: String

  """Static data value ID."""
  sdv_id: Int

  """Static data value slug."""
  sdv_key: String

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: String

  """
  When any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  plain_value: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Setting type of setting preference"""
  fr_setting_type: SettingTypeEntity

  """Static data of setting preference"""
  fr_static_data: StaticDataEntity

  """Static data values of setting preference"""
  fr_static_data_values: StaticDataValueEntity

  """Setting of setting preference"""
  fr_setting: SettingEntity
}

input SettingPreferenceDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingPreferenceDeleteInputWhere!]
}

input SettingPreferenceDeleteInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: FindOperatorDto

  """Setting ID of the setting."""
  sett_id: FindOperatorDto

  """Setting slug."""
  sett_key: FindOperatorDto

  """Static data id in case if any applicable."""
  sd_id: FindOperatorDto

  """Static data slug in case if any applicable."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  sdv_id: FindOperatorDto

  """Static data value slug."""
  sdv_key: FindOperatorDto

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting type of setting preference"""
  fr_setting_type: [SettingTypeFindInputWhere!]

  """Static data of setting preference"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Static data values of setting preference"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting of setting preference"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingPreferenceDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type SettingPreferenceEntity {
  """Unique ID of the staticvalue, auto generated."""
  id: Int

  """Type ID of the setting type."""
  settty_id: Int

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: String

  """Setting ID of the setting."""
  sett_id: Int

  """Setting slug."""
  sett_key: String

  """Static data id in case if any applicable."""
  sd_id: Int

  """Static data slug in case if any applicable."""
  sd_name: String

  """Static data value ID."""
  sdv_id: Int

  """Static data value slug."""
  sdv_key: String

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: String

  """
  When any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  plain_value: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Setting type of setting preference"""
  fr_setting_type: SettingTypeEntity

  """Static data of setting preference"""
  fr_static_data: StaticDataEntity

  """Static data values of setting preference"""
  fr_static_data_values: StaticDataValueEntity

  """Setting of setting preference"""
  fr_setting: SettingEntity
}

input SettingPreferenceFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingPreferenceFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: SettingPreferenceFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: SettingPreferenceFindInputSortOrder
}

input SettingPreferenceFindInputGroupBy {
  settty_id: Boolean
  record_id: Boolean
  sett_id: Boolean
  sett_key: Boolean
  sd_id: Boolean
  sd_name: Boolean
  sdv_id: Boolean
  sdv_key: Boolean
  sdt_key: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input SettingPreferenceFindInputSortOrder {
  id: RecordSortDirectionEnum
  settty_id: RecordSortDirectionEnum
  record_id: RecordSortDirectionEnum
  sett_id: RecordSortDirectionEnum
  sett_key: RecordSortDirectionEnum
  sd_id: RecordSortDirectionEnum
  sd_name: RecordSortDirectionEnum
  sdv_id: RecordSortDirectionEnum
  sdv_key: RecordSortDirectionEnum
  sdt_key: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input SettingPreferenceFindInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: FindOperatorDto

  """Setting ID of the setting."""
  sett_id: FindOperatorDto

  """Setting slug."""
  sett_key: FindOperatorDto

  """Static data id in case if any applicable."""
  sd_id: FindOperatorDto

  """Static data slug in case if any applicable."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  sdv_id: FindOperatorDto

  """Static data value slug."""
  sdv_key: FindOperatorDto

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting type of setting preference"""
  fr_setting_type: [SettingTypeFindInputWhere!]

  """Static data of setting preference"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Static data values of setting preference"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting of setting preference"""
  fr_setting: [SettingFindInputWhere!]
}

input SettingPreferenceFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type SettingPreferenceFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [SettingPreferenceEntity!]!
}

input SettingPreferenceJsonInput {
  """Choose setting type to retrive data."""
  setting_type: SettingTypeEnum!

  """
  In case of record setting pass the id of the record. For example, for user setting user_id or multiple id in as array.
  """
  record_id: [String!]
}

input SettingPreferenceRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingPreferenceRecoverInputWhere!]
}

input SettingPreferenceRecoverInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: FindOperatorDto

  """Setting ID of the setting."""
  sett_id: FindOperatorDto

  """Setting slug."""
  sett_key: FindOperatorDto

  """Static data id in case if any applicable."""
  sd_id: FindOperatorDto

  """Static data slug in case if any applicable."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  sdv_id: FindOperatorDto

  """Static data value slug."""
  sdv_key: FindOperatorDto

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting type of setting preference"""
  fr_setting_type: [SettingTypeFindInputWhere!]

  """Static data of setting preference"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Static data values of setting preference"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting of setting preference"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingPreferenceRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingPreferenceEntity!]!
}

input SettingPreferenceRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingPreferenceRemoveInputWhere!]
}

input SettingPreferenceRemoveInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: FindOperatorDto

  """Setting ID of the setting."""
  sett_id: FindOperatorDto

  """Setting slug."""
  sett_key: FindOperatorDto

  """Static data id in case if any applicable."""
  sd_id: FindOperatorDto

  """Static data slug in case if any applicable."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  sdv_id: FindOperatorDto

  """Static data value slug."""
  sdv_key: FindOperatorDto

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting type of setting preference"""
  fr_setting_type: [SettingTypeFindInputWhere!]

  """Static data of setting preference"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Static data values of setting preference"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting of setting preference"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingPreferenceRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingPreferenceEntity!]!
}

input SettingPreferenceRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingPreferenceRestoreInputWhere!]
}

input SettingPreferenceRestoreInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: FindOperatorDto

  """Setting ID of the setting."""
  sett_id: FindOperatorDto

  """Setting slug."""
  sett_key: FindOperatorDto

  """Static data id in case if any applicable."""
  sd_id: FindOperatorDto

  """Static data slug in case if any applicable."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  sdv_id: FindOperatorDto

  """Static data value slug."""
  sdv_key: FindOperatorDto

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting type of setting preference"""
  fr_setting_type: [SettingTypeFindInputWhere!]

  """Static data of setting preference"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Static data values of setting preference"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting of setting preference"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingPreferenceRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SettingPreferenceSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingPreferenceSoftDeleteInputWhere!]
}

input SettingPreferenceSoftDeleteInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: FindOperatorDto

  """Setting ID of the setting."""
  sett_id: FindOperatorDto

  """Setting slug."""
  sett_key: FindOperatorDto

  """Static data id in case if any applicable."""
  sd_id: FindOperatorDto

  """Static data slug in case if any applicable."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  sdv_id: FindOperatorDto

  """Static data value slug."""
  sdv_key: FindOperatorDto

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting type of setting preference"""
  fr_setting_type: [SettingTypeFindInputWhere!]

  """Static data of setting preference"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Static data values of setting preference"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting of setting preference"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingPreferenceSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SettingPreferenceSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingPreferenceSoftRemoveInputWhere!]
}

input SettingPreferenceSoftRemoveInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: FindOperatorDto

  """Setting ID of the setting."""
  sett_id: FindOperatorDto

  """Setting slug."""
  sett_key: FindOperatorDto

  """Static data id in case if any applicable."""
  sd_id: FindOperatorDto

  """Static data slug in case if any applicable."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  sdv_id: FindOperatorDto

  """Static data value slug."""
  sdv_key: FindOperatorDto

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting type of setting preference"""
  fr_setting_type: [SettingTypeFindInputWhere!]

  """Static data of setting preference"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Static data values of setting preference"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting of setting preference"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingPreferenceSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingPreferenceEntity!]!
}

input SettingPreferenceUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingPreferenceUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: SettingPreferenceUpdateInputSets!
}

input SettingPreferenceUpdateInputSets {
  """Type ID of the setting type."""
  settty_id: Int

  """Setting ID of the setting."""
  sett_id: Int

  """Setting slug."""
  sett_key: String

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: String

  """Static data id in case if any applicable."""
  sd_id: Int

  """Static data slug in case if any applicable."""
  sd_name: String

  """Static data value ID."""
  sdv_id: Int

  """Static data value slug."""
  sdv_key: String

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: String

  """
  When any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  plain_value: String
}

input SettingPreferenceUpdateInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: FindOperatorDto

  """Setting ID of the setting."""
  sett_id: FindOperatorDto

  """Setting slug."""
  sett_key: FindOperatorDto

  """Static data id in case if any applicable."""
  sd_id: FindOperatorDto

  """Static data slug in case if any applicable."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  sdv_id: FindOperatorDto

  """Static data value slug."""
  sdv_key: FindOperatorDto

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting type of setting preference"""
  fr_setting_type: [SettingTypeFindInputWhere!]

  """Static data of setting preference"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Static data values of setting preference"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting of setting preference"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingPreferenceUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [SettingPreferenceEntity!]!
}

input SettingPreferenceUpsertInput {
  """Type ID of the setting type."""
  settty_id: Int!

  """Setting ID of the setting."""
  sett_id: Int!

  """Setting slug."""
  sett_key: String!

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: String

  """Static data id in case if any applicable."""
  sd_id: Int

  """Static data slug in case if any applicable."""
  sd_name: String

  """Static data value ID."""
  sdv_id: Int

  """Static data value slug."""
  sdv_key: String

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: String

  """
  When any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  plain_value: String

  """Unique ID of the staticvalue, auto generated. undefined"""
  id: Int
}

type SettingPreferenceUpsertOutput {
  """Unique ID of the staticvalue, auto generated."""
  id: Int

  """Type ID of the setting type."""
  settty_id: Int

  """
  This is kind of if settty_for_table_field has country table id filed then that id field value will be saved here like 17. This means settings for country_id 17 same way if user table has id field and here in this field 10 is saved means settings for user_id 10. This can be null if there is global settings available.
  """
  record_id: String

  """Setting ID of the setting."""
  sett_id: Int

  """Setting slug."""
  sett_key: String

  """Static data id in case if any applicable."""
  sd_id: Int

  """Static data slug in case if any applicable."""
  sd_name: String

  """Static data value ID."""
  sdv_id: Int

  """Static data value slug."""
  sdv_key: String

  """
  Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  sdt_key: String

  """
  When any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  plain_value: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Setting type of setting preference"""
  fr_setting_type: SettingTypeEntity

  """Static data of setting preference"""
  fr_static_data: StaticDataEntity

  """Static data values of setting preference"""
  fr_static_data_values: StaticDataValueEntity

  """Setting of setting preference"""
  fr_setting: SettingEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input SettingRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingRecoverInputWhere!]
}

input SettingRecoverInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Key of the setting."""
  key: FindOperatorDto

  """Category ID of the setting category."""
  settc_id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """Form control type ID of the form control type."""
  frmfield_id: FindOperatorDto

  """Device ID of the device."""
  device_id: FindOperatorDto

  """Static data ID of the static data."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  default_sdv_id: FindOperatorDto

  """Static data value slug."""
  default_sdv_key: FindOperatorDto

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: FindOperatorDto

  """Access whether config is available for end user or internal purpose."""
  access_type: FindOperatorDto

  """title of the setting."""
  title: FindOperatorDto

  """Display title of the setting."""
  display_title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """catetegorys of Setting"""
  fr_setting_categorys: [SettingCategoryFindInputWhere!]

  """Setting type of setting"""
  fr_setting_types: [SettingTypeFindInputWhere!]

  """Setting control type of setting"""
  fr_form_fields: [FormFieldFindInputWhere!]

  """devices of setting"""
  fr_devices: [DeviceFindInputWhere!]

  """Static datas of setting """
  fr_static_datas: [StaticDataFindInputWhere!]

  """Setting preference of setting """
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Static data value preference of setting """
  fr_static_data_values: [StaticDataValueFindInputWhere!]
}

type SettingRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingEntity!]!
}

input SettingRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingRemoveInputWhere!]
}

input SettingRemoveInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Key of the setting."""
  key: FindOperatorDto

  """Category ID of the setting category."""
  settc_id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """Form control type ID of the form control type."""
  frmfield_id: FindOperatorDto

  """Device ID of the device."""
  device_id: FindOperatorDto

  """Static data ID of the static data."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  default_sdv_id: FindOperatorDto

  """Static data value slug."""
  default_sdv_key: FindOperatorDto

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: FindOperatorDto

  """Access whether config is available for end user or internal purpose."""
  access_type: FindOperatorDto

  """title of the setting."""
  title: FindOperatorDto

  """Display title of the setting."""
  display_title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """catetegorys of Setting"""
  fr_setting_categorys: [SettingCategoryFindInputWhere!]

  """Setting type of setting"""
  fr_setting_types: [SettingTypeFindInputWhere!]

  """Setting control type of setting"""
  fr_form_fields: [FormFieldFindInputWhere!]

  """devices of setting"""
  fr_devices: [DeviceFindInputWhere!]

  """Static datas of setting """
  fr_static_datas: [StaticDataFindInputWhere!]

  """Setting preference of setting """
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Static data value preference of setting """
  fr_static_data_values: [StaticDataValueFindInputWhere!]
}

type SettingRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingEntity!]!
}

input SettingRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingRestoreInputWhere!]
}

input SettingRestoreInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Key of the setting."""
  key: FindOperatorDto

  """Category ID of the setting category."""
  settc_id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """Form control type ID of the form control type."""
  frmfield_id: FindOperatorDto

  """Device ID of the device."""
  device_id: FindOperatorDto

  """Static data ID of the static data."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  default_sdv_id: FindOperatorDto

  """Static data value slug."""
  default_sdv_key: FindOperatorDto

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: FindOperatorDto

  """Access whether config is available for end user or internal purpose."""
  access_type: FindOperatorDto

  """title of the setting."""
  title: FindOperatorDto

  """Display title of the setting."""
  display_title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """catetegorys of Setting"""
  fr_setting_categorys: [SettingCategoryFindInputWhere!]

  """Setting type of setting"""
  fr_setting_types: [SettingTypeFindInputWhere!]

  """Setting control type of setting"""
  fr_form_fields: [FormFieldFindInputWhere!]

  """devices of setting"""
  fr_devices: [DeviceFindInputWhere!]

  """Static datas of setting """
  fr_static_datas: [StaticDataFindInputWhere!]

  """Setting preference of setting """
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Static data value preference of setting """
  fr_static_data_values: [StaticDataValueFindInputWhere!]
}

type SettingRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SettingSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingSoftDeleteInputWhere!]
}

input SettingSoftDeleteInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Key of the setting."""
  key: FindOperatorDto

  """Category ID of the setting category."""
  settc_id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """Form control type ID of the form control type."""
  frmfield_id: FindOperatorDto

  """Device ID of the device."""
  device_id: FindOperatorDto

  """Static data ID of the static data."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  default_sdv_id: FindOperatorDto

  """Static data value slug."""
  default_sdv_key: FindOperatorDto

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: FindOperatorDto

  """Access whether config is available for end user or internal purpose."""
  access_type: FindOperatorDto

  """title of the setting."""
  title: FindOperatorDto

  """Display title of the setting."""
  display_title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """catetegorys of Setting"""
  fr_setting_categorys: [SettingCategoryFindInputWhere!]

  """Setting type of setting"""
  fr_setting_types: [SettingTypeFindInputWhere!]

  """Setting control type of setting"""
  fr_form_fields: [FormFieldFindInputWhere!]

  """devices of setting"""
  fr_devices: [DeviceFindInputWhere!]

  """Static datas of setting """
  fr_static_datas: [StaticDataFindInputWhere!]

  """Setting preference of setting """
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Static data value preference of setting """
  fr_static_data_values: [StaticDataValueFindInputWhere!]
}

type SettingSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SettingSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingSoftRemoveInputWhere!]
}

input SettingSoftRemoveInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Key of the setting."""
  key: FindOperatorDto

  """Category ID of the setting category."""
  settc_id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """Form control type ID of the form control type."""
  frmfield_id: FindOperatorDto

  """Device ID of the device."""
  device_id: FindOperatorDto

  """Static data ID of the static data."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  default_sdv_id: FindOperatorDto

  """Static data value slug."""
  default_sdv_key: FindOperatorDto

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: FindOperatorDto

  """Access whether config is available for end user or internal purpose."""
  access_type: FindOperatorDto

  """title of the setting."""
  title: FindOperatorDto

  """Display title of the setting."""
  display_title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """catetegorys of Setting"""
  fr_setting_categorys: [SettingCategoryFindInputWhere!]

  """Setting type of setting"""
  fr_setting_types: [SettingTypeFindInputWhere!]

  """Setting control type of setting"""
  fr_form_fields: [FormFieldFindInputWhere!]

  """devices of setting"""
  fr_devices: [DeviceFindInputWhere!]

  """Static datas of setting """
  fr_static_datas: [StaticDataFindInputWhere!]

  """Setting preference of setting """
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Static data value preference of setting """
  fr_static_data_values: [StaticDataValueFindInputWhere!]
}

type SettingSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingEntity!]!
}

input SettingTypeCreateInput {
  """Title of the setting type."""
  title: String!

  """Reference table of the setting type."""
  for_table: String

  """Reference table field of the setting type."""
  for_table_field: String
}

type SettingTypeCreateOutput {
  """Unique ID of the setting type, auto generated."""
  id: Int

  """Title of the setting type."""
  title: String

  """Reference table of the setting type."""
  for_table: String

  """Reference table field of the setting type."""
  for_table_field: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Setting preference of Setting type"""
  fr_setting_preference: [SettingPreferenceEntity!]

  """Setting of Setting type"""
  fr_setting: [SettingEntity!]
}

input SettingTypeDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingTypeDeleteInputWhere!]
}

input SettingTypeDeleteInputWhere {
  """Unique ID of the setting type, auto generated."""
  id: FindOperatorDto

  """Title of the setting type."""
  title: FindOperatorDto

  """Reference table of the setting type."""
  for_table: FindOperatorDto

  """Reference table field of the setting type."""
  for_table_field: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting preference of Setting type"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Setting type"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingTypeDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type SettingTypeEntity {
  """Unique ID of the setting type, auto generated."""
  id: Int

  """Title of the setting type."""
  title: String

  """Reference table of the setting type."""
  for_table: String

  """Reference table field of the setting type."""
  for_table_field: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Setting preference of Setting type"""
  fr_setting_preference: [SettingPreferenceEntity!]

  """Setting of Setting type"""
  fr_setting: [SettingEntity!]
}

"""SettingType to retrive specific settings"""
enum SettingTypeEnum {
  """These are global settings of the application."""
  SYSTEM_SETTINGS

  """
  These settings are used for development purpose and not applicable to end user or admin.
  """
  DEVELOPER_SETTINGS

  """
  These settings are for administrative panle and will be maanged by super admin, admin or webmaster as per access permission.
  """
  BACK_OFFICE_SETTINGS

  """
  These settings are for end user and will be maanged by end user after signup. Need to send user id in record_id if you choose this setting type.
  """
  USER_SETTINGS

  """
  These settings are for end user role/authorisation maanged by end user after signup. Need to send user authorisation id in record_id if you choose this setting type.
  """
  USER_AUTHORISATION_SETTINGS
}

input SettingTypeFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingTypeFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: SettingTypeFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: SettingTypeFindInputSortOrder
}

input SettingTypeFindInputGroupBy {
  title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input SettingTypeFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input SettingTypeFindInputWhere {
  """Unique ID of the setting type, auto generated."""
  id: FindOperatorDto

  """Title of the setting type."""
  title: FindOperatorDto

  """Reference table of the setting type."""
  for_table: FindOperatorDto

  """Reference table field of the setting type."""
  for_table_field: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting preference of Setting type"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Setting type"""
  fr_setting: [SettingFindInputWhere!]
}

input SettingTypeFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type SettingTypeFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [SettingTypeEntity!]!
}

input SettingTypeRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingTypeRecoverInputWhere!]
}

input SettingTypeRecoverInputWhere {
  """Unique ID of the setting type, auto generated."""
  id: FindOperatorDto

  """Title of the setting type."""
  title: FindOperatorDto

  """Reference table of the setting type."""
  for_table: FindOperatorDto

  """Reference table field of the setting type."""
  for_table_field: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting preference of Setting type"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Setting type"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingTypeRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingTypeEntity!]!
}

input SettingTypeRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingTypeRemoveInputWhere!]
}

input SettingTypeRemoveInputWhere {
  """Unique ID of the setting type, auto generated."""
  id: FindOperatorDto

  """Title of the setting type."""
  title: FindOperatorDto

  """Reference table of the setting type."""
  for_table: FindOperatorDto

  """Reference table field of the setting type."""
  for_table_field: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting preference of Setting type"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Setting type"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingTypeRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingTypeEntity!]!
}

input SettingTypeRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingTypeRestoreInputWhere!]
}

input SettingTypeRestoreInputWhere {
  """Unique ID of the setting type, auto generated."""
  id: FindOperatorDto

  """Title of the setting type."""
  title: FindOperatorDto

  """Reference table of the setting type."""
  for_table: FindOperatorDto

  """Reference table field of the setting type."""
  for_table_field: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting preference of Setting type"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Setting type"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingTypeRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SettingTypeSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingTypeSoftDeleteInputWhere!]
}

input SettingTypeSoftDeleteInputWhere {
  """Unique ID of the setting type, auto generated."""
  id: FindOperatorDto

  """Title of the setting type."""
  title: FindOperatorDto

  """Reference table of the setting type."""
  for_table: FindOperatorDto

  """Reference table field of the setting type."""
  for_table_field: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting preference of Setting type"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Setting type"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingTypeSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SettingTypeSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingTypeSoftRemoveInputWhere!]
}

input SettingTypeSoftRemoveInputWhere {
  """Unique ID of the setting type, auto generated."""
  id: FindOperatorDto

  """Title of the setting type."""
  title: FindOperatorDto

  """Reference table of the setting type."""
  for_table: FindOperatorDto

  """Reference table field of the setting type."""
  for_table_field: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting preference of Setting type"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Setting type"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingTypeSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SettingTypeEntity!]!
}

input SettingTypeUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingTypeUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: SettingTypeUpdateInputSets!
}

input SettingTypeUpdateInputSets {
  """Title of the setting type."""
  title: String

  """Reference table of the setting type."""
  for_table: String

  """Reference table field of the setting type."""
  for_table_field: String
}

input SettingTypeUpdateInputWhere {
  """Unique ID of the setting type, auto generated."""
  id: FindOperatorDto

  """Title of the setting type."""
  title: FindOperatorDto

  """Reference table of the setting type."""
  for_table: FindOperatorDto

  """Reference table field of the setting type."""
  for_table_field: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Setting preference of Setting type"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Setting type"""
  fr_setting: [SettingFindInputWhere!]
}

type SettingTypeUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [SettingTypeEntity!]!
}

input SettingTypeUpsertInput {
  """Title of the setting type."""
  title: String!

  """Reference table of the setting type."""
  for_table: String

  """Reference table field of the setting type."""
  for_table_field: String

  """Unique ID of the setting type, auto generated. undefined"""
  id: Int
}

type SettingTypeUpsertOutput {
  """Unique ID of the setting type, auto generated."""
  id: Int

  """Title of the setting type."""
  title: String

  """Reference table of the setting type."""
  for_table: String

  """Reference table field of the setting type."""
  for_table_field: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Setting preference of Setting type"""
  fr_setting_preference: [SettingPreferenceEntity!]

  """Setting of Setting type"""
  fr_setting: [SettingEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input SettingUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SettingUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: SettingUpdateInputSets!
}

input SettingUpdateInputSets {
  """Key of the setting."""
  key: String

  """Category ID of the setting category."""
  settc_id: Int

  """Type ID of the setting type."""
  settty_id: Int

  """Form control type ID of the form control type."""
  frmfield_id: Int

  """Device ID of the device."""
  device_id: Int

  """Static data ID of the static data."""
  sd_id: Int

  """Slug name of the static data."""
  sd_name: String

  """Static data value ID."""
  default_sdv_id: Int

  """Static data value slug."""
  default_sdv_key: String

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: String

  """
  Default value when any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  default_plain_value: String

  """Access whether config is available for end user or internal purpose."""
  access_type: AccessTypeEnum = PUBLIC

  """title of the setting."""
  title: String

  """Display title of the setting."""
  display_title: String

  """Guideline of the setting."""
  guideline: String
}

input SettingUpdateInputWhere {
  """Unique ID of the staticvalue, auto generated."""
  id: FindOperatorDto

  """Key of the setting."""
  key: FindOperatorDto

  """Category ID of the setting category."""
  settc_id: FindOperatorDto

  """Type ID of the setting type."""
  settty_id: FindOperatorDto

  """Form control type ID of the form control type."""
  frmfield_id: FindOperatorDto

  """Device ID of the device."""
  device_id: FindOperatorDto

  """Static data ID of the static data."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Static data value ID."""
  default_sdv_id: FindOperatorDto

  """Static data value slug."""
  default_sdv_key: FindOperatorDto

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: FindOperatorDto

  """Access whether config is available for end user or internal purpose."""
  access_type: FindOperatorDto

  """title of the setting."""
  title: FindOperatorDto

  """Display title of the setting."""
  display_title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """catetegorys of Setting"""
  fr_setting_categorys: [SettingCategoryFindInputWhere!]

  """Setting type of setting"""
  fr_setting_types: [SettingTypeFindInputWhere!]

  """Setting control type of setting"""
  fr_form_fields: [FormFieldFindInputWhere!]

  """devices of setting"""
  fr_devices: [DeviceFindInputWhere!]

  """Static datas of setting """
  fr_static_datas: [StaticDataFindInputWhere!]

  """Setting preference of setting """
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Static data value preference of setting """
  fr_static_data_values: [StaticDataValueFindInputWhere!]
}

type SettingUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [SettingEntity!]!
}

input SettingUpsertInput {
  """Key of the setting."""
  key: String!

  """Category ID of the setting category."""
  settc_id: Int!

  """Type ID of the setting type."""
  settty_id: Int!

  """Form control type ID of the form control type."""
  frmfield_id: Int!

  """Device ID of the device."""
  device_id: Int

  """Static data ID of the static data."""
  sd_id: Int

  """Slug name of the static data."""
  sd_name: String

  """Static data value ID."""
  default_sdv_id: Int

  """Static data value slug."""
  default_sdv_key: String

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: String

  """
  Default value when any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  default_plain_value: String

  """Access whether config is available for end user or internal purpose."""
  access_type: AccessTypeEnum! = PUBLIC

  """title of the setting."""
  title: String!

  """Display title of the setting."""
  display_title: String!

  """Guideline of the setting."""
  guideline: String!

  """Unique ID of the staticvalue, auto generated. undefined"""
  id: Int
}

type SettingUpsertOutput {
  """Unique ID of the staticvalue, auto generated."""
  id: Int

  """Key of the setting."""
  key: String

  """Type ID of the setting type."""
  settty_id: Int

  """Category ID of the setting category."""
  settc_id: Int

  """Form control type ID of the form control type."""
  frmfield_id: Int

  """Device ID of the device."""
  device_id: Int

  """Static data ID of the static data."""
  sd_id: Int

  """Slug name of the static data."""
  sd_name: String

  """Static data value ID."""
  default_sdv_id: Int

  """Static data value slug."""
  default_sdv_key: String

  """
  Default value for Settings entity field sett_ref_value_field value in targeted table in setting entity field ref_table_name.
  """
  default_sdt_key: String

  """
  Default value when any setting has no static data or no reference table relation for setting value it is possible to have some text as a value of config and that time this field will hold the actual value of setting.
  """
  default_plain_value: String

  """Access whether config is available for end user or internal purpose."""
  access_type: AccessTypeEnum

  """title of the setting."""
  title: String

  """Display title of the setting."""
  display_title: String

  """Guideline of the setting."""
  guideline: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """catetegorys of Setting"""
  fr_setting_categorys: SettingCategoryEntity

  """Setting type of setting"""
  fr_setting_types: SettingTypeEntity

  """Setting control type of setting"""
  fr_form_fields: FormFieldEntity

  """devices of setting"""
  fr_devices: DeviceEntity

  """Static datas of setting """
  fr_static_datas: StaticDataEntity

  """Static data value preference of setting """
  fr_static_data_values: StaticDataValueEntity

  """Setting preference of setting """
  fr_setting_preference: [SettingPreferenceEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

type SnapshotListDto {
  """Formal message snapshot."""
  message: [String!]

  """Result snapshot."""
  result: [String!]

  """Important snapshot."""
  imp: [String!]

  """Mismatch snapshot."""
  mismatch: [String!]

  """Not found snapshot."""
  notFound: [String!]

  """Conflict snapshot."""
  conflict: [String!]

  """Success snapshot."""
  success: [String!]

  """Error snapshot."""
  error: [String!]

  """Alert snapshot."""
  alert: [String!]

  """Warning snapshot."""
  warning: [String!]

  """Notice snapshot."""
  notice: [String!]

  """Info snapshot."""
  info: [String!]
}

input StateCreateInput {
  """Required to get state for specifc country."""
  country_id: Int!

  """Name of the state."""
  name: String!

  """Type of the state."""
  type: String

  """FIPS code of the state."""
  fips: String

  """ISO II code of the state."""
  iso_ii: String

  """Latitude of the state."""
  latitude: Float

  """Longitude of the state."""
  longitude: Float
}

type StateCreateOutput {
  """Unique ID of the state, auto generated."""
  id: Int

  """Required to get state for specifc country."""
  country_id: Int

  """Name of the state."""
  name: String

  """Type of the state."""
  type: String

  """FIPS code of the state."""
  fips: String

  """ISO II code of the state."""
  iso_ii: String

  """Latitude of the state."""
  latitude: Float

  """Longitude of the state."""
  longitude: Float

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Country info of the state."""
  fr_country: CountryEntity

  """List of cities for this state."""
  fr_cities: [CityEntity!]

  """List of user address in this state."""
  fr_user_addresses: [UserAddressEntity!]

  """List of user identity cards for this state."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """List of user corporate infos for this state."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """List of business infos for this state."""
  fr_business: [BusinessEntity!]
}

input StateDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StateDeleteInputWhere!]
}

input StateDeleteInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Required to get state for specifc country."""
  country_id: FindOperatorDto

  """Name of the state."""
  name: FindOperatorDto

  """Type of the state."""
  type: FindOperatorDto

  """ISO II code of the state."""
  iso_ii: FindOperatorDto

  """Latitude of the state."""
  latitude: FindOperatorDto

  """Longitude of the state."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info of the state."""
  fr_country: [CountryFindInputWhere!]

  """List of cities for this state."""
  fr_cities: [CityFindInputWhere!]

  """List of user address in this state."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this state."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this state."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]
}

type StateDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type StateEntity {
  """Unique ID of the state, auto generated."""
  id: Int

  """Required to get state for specifc country."""
  country_id: Int

  """Name of the state."""
  name: String

  """Type of the state."""
  type: String

  """FIPS code of the state."""
  fips: String

  """ISO II code of the state."""
  iso_ii: String

  """Latitude of the state."""
  latitude: Float

  """Longitude of the state."""
  longitude: Float

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Country info of the state."""
  fr_country: CountryEntity

  """List of cities for this state."""
  fr_cities: [CityEntity!]

  """List of user address in this state."""
  fr_user_addresses: [UserAddressEntity!]

  """List of user identity cards for this state."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """List of user corporate infos for this state."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """List of business infos for this state."""
  fr_business: [BusinessEntity!]
}

input StateFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StateFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: StateFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: StateFindInputSortOrder
}

input StateFindInputGroupBy {
  country_id: Boolean
  name: Boolean
  iso_ii: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input StateFindInputSortOrder {
  id: RecordSortDirectionEnum

  """Required to get state for specifc country."""
  country_id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  iso_ii: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input StateFindInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Required to get state for specifc country."""
  country_id: FindOperatorDto

  """Name of the state."""
  name: FindOperatorDto

  """Type of the state."""
  type: FindOperatorDto

  """ISO II code of the state."""
  iso_ii: FindOperatorDto

  """Latitude of the state."""
  latitude: FindOperatorDto

  """Longitude of the state."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info of the state."""
  fr_country: [CountryFindInputWhere!]

  """List of cities for this state."""
  fr_cities: [CityFindInputWhere!]

  """List of user address in this state."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this state."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this state."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]
}

input StateFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type StateFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [StateEntity!]!
}

input StateRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StateRecoverInputWhere!]
}

input StateRecoverInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Required to get state for specifc country."""
  country_id: FindOperatorDto

  """Name of the state."""
  name: FindOperatorDto

  """Type of the state."""
  type: FindOperatorDto

  """ISO II code of the state."""
  iso_ii: FindOperatorDto

  """Latitude of the state."""
  latitude: FindOperatorDto

  """Longitude of the state."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info of the state."""
  fr_country: [CountryFindInputWhere!]

  """List of cities for this state."""
  fr_cities: [CityFindInputWhere!]

  """List of user address in this state."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this state."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this state."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]
}

type StateRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [StateEntity!]!
}

input StateRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StateRemoveInputWhere!]
}

input StateRemoveInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Required to get state for specifc country."""
  country_id: FindOperatorDto

  """Name of the state."""
  name: FindOperatorDto

  """Type of the state."""
  type: FindOperatorDto

  """ISO II code of the state."""
  iso_ii: FindOperatorDto

  """Latitude of the state."""
  latitude: FindOperatorDto

  """Longitude of the state."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info of the state."""
  fr_country: [CountryFindInputWhere!]

  """List of cities for this state."""
  fr_cities: [CityFindInputWhere!]

  """List of user address in this state."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this state."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this state."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]
}

type StateRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [StateEntity!]!
}

input StateRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StateRestoreInputWhere!]
}

input StateRestoreInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Required to get state for specifc country."""
  country_id: FindOperatorDto

  """Name of the state."""
  name: FindOperatorDto

  """Type of the state."""
  type: FindOperatorDto

  """ISO II code of the state."""
  iso_ii: FindOperatorDto

  """Latitude of the state."""
  latitude: FindOperatorDto

  """Longitude of the state."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info of the state."""
  fr_country: [CountryFindInputWhere!]

  """List of cities for this state."""
  fr_cities: [CityFindInputWhere!]

  """List of user address in this state."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this state."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this state."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]
}

type StateRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input StateSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StateSoftDeleteInputWhere!]
}

input StateSoftDeleteInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Required to get state for specifc country."""
  country_id: FindOperatorDto

  """Name of the state."""
  name: FindOperatorDto

  """Type of the state."""
  type: FindOperatorDto

  """ISO II code of the state."""
  iso_ii: FindOperatorDto

  """Latitude of the state."""
  latitude: FindOperatorDto

  """Longitude of the state."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info of the state."""
  fr_country: [CountryFindInputWhere!]

  """List of cities for this state."""
  fr_cities: [CityFindInputWhere!]

  """List of user address in this state."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this state."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this state."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]
}

type StateSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input StateSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StateSoftRemoveInputWhere!]
}

input StateSoftRemoveInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Required to get state for specifc country."""
  country_id: FindOperatorDto

  """Name of the state."""
  name: FindOperatorDto

  """Type of the state."""
  type: FindOperatorDto

  """ISO II code of the state."""
  iso_ii: FindOperatorDto

  """Latitude of the state."""
  latitude: FindOperatorDto

  """Longitude of the state."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info of the state."""
  fr_country: [CountryFindInputWhere!]

  """List of cities for this state."""
  fr_cities: [CityFindInputWhere!]

  """List of user address in this state."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this state."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this state."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]
}

type StateSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [StateEntity!]!
}

input StateUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StateUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: StateUpdateInputSets!
}

input StateUpdateInputSets {
  """Required to get state for specifc country."""
  country_id: Int

  """Name of the state."""
  name: String

  """Type of the state."""
  type: String

  """FIPS code of the state."""
  fips: String

  """ISO II code of the state."""
  iso_ii: String

  """Latitude of the state."""
  latitude: Float

  """Longitude of the state."""
  longitude: Float
}

input StateUpdateInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Required to get state for specifc country."""
  country_id: FindOperatorDto

  """Name of the state."""
  name: FindOperatorDto

  """Type of the state."""
  type: FindOperatorDto

  """ISO II code of the state."""
  iso_ii: FindOperatorDto

  """Latitude of the state."""
  latitude: FindOperatorDto

  """Longitude of the state."""
  longitude: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Country info of the state."""
  fr_country: [CountryFindInputWhere!]

  """List of cities for this state."""
  fr_cities: [CityFindInputWhere!]

  """List of user address in this state."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """List of user identity cards for this state."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """List of user corporate infos for this state."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]
}

type StateUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [StateEntity!]!
}

input StateUpsertInput {
  """Required to get state for specifc country."""
  country_id: Int!

  """Name of the state."""
  name: String!

  """Type of the state."""
  type: String

  """FIPS code of the state."""
  fips: String

  """ISO II code of the state."""
  iso_ii: String

  """Latitude of the state."""
  latitude: Float

  """Longitude of the state."""
  longitude: Float

  """Unique ID of the state, auto generated. undefined"""
  id: Int
}

type StateUpsertOutput {
  """Unique ID of the state, auto generated."""
  id: Int

  """Required to get state for specifc country."""
  country_id: Int

  """Name of the state."""
  name: String

  """Type of the state."""
  type: String

  """FIPS code of the state."""
  fips: String

  """ISO II code of the state."""
  iso_ii: String

  """Latitude of the state."""
  latitude: Float

  """Longitude of the state."""
  longitude: Float

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Country info of the state."""
  fr_country: CountryEntity

  """List of cities for this state."""
  fr_cities: [CityEntity!]

  """List of user address in this state."""
  fr_user_addresses: [UserAddressEntity!]

  """List of user identity cards for this state."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """List of user corporate infos for this state."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """List of business infos for this state."""
  fr_business: [BusinessEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input StaticDataCreateInput {
  """Name of the static data."""
  name: String!

  """Description of the static data."""
  desc: String

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: String

  """Table field name of the static data for key."""
  table_field_for_key: String

  """Table field name of the static data for value."""
  table_field_for_value: String

  """Table field name of the static data for deleted records."""
  table_field_for_deleted: String
}

type StaticDataCreateOutput {
  """Unique ID of the static data, auto generated."""
  id: Int

  """Name of the static data."""
  name: String

  """Description of the static data."""
  desc: String

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: String

  """Table field name of the static data for key."""
  table_field_for_key: String

  """Table field name of the static data for value."""
  table_field_for_value: String

  """Table field name of the static data for deleted records."""
  table_field_for_deleted: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Static values of static data"""
  fr_static_data_values: [StaticDataValueEntity!]

  """Setting preference of Static data"""
  fr_setting_preference: [SettingPreferenceEntity!]

  """Setting of Static data"""
  fr_setting: [SettingEntity!]
}

input StaticDataDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataDeleteInputWhere!]
}

input StaticDataDeleteInputWhere {
  """Unique ID of the static data, auto generated."""
  id: FindOperatorDto

  """Name of the static data."""
  name: FindOperatorDto

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: FindOperatorDto

  """Table field name of the static data for key."""
  table_field_for_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static values of static data"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting preference of Static data"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Static data"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type StaticDataEntity {
  """Unique ID of the static data, auto generated."""
  id: Int

  """Name of the static data."""
  name: String

  """Description of the static data."""
  desc: String

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: String

  """Table field name of the static data for key."""
  table_field_for_key: String

  """Table field name of the static data for value."""
  table_field_for_value: String

  """Table field name of the static data for deleted records."""
  table_field_for_deleted: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Static values of static data"""
  fr_static_data_values: [StaticDataValueEntity!]

  """Setting preference of Static data"""
  fr_setting_preference: [SettingPreferenceEntity!]

  """Setting of Static data"""
  fr_setting: [SettingEntity!]
}

input StaticDataFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: StaticDataFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: StaticDataFindInputSortOrder
}

input StaticDataFindInputGroupBy {
  name: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input StaticDataFindInputSortOrder {
  id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  table: RecordSortDirectionEnum
  table_field_for_key: RecordSortDirectionEnum
  table_field_for_value: RecordSortDirectionEnum
  table_field_for_deleted: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input StaticDataFindInputWhere {
  """Unique ID of the static data, auto generated."""
  id: FindOperatorDto

  """Name of the static data."""
  name: FindOperatorDto

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: FindOperatorDto

  """Table field name of the static data for key."""
  table_field_for_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static values of static data"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting preference of Static data"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Static data"""
  fr_setting: [SettingFindInputWhere!]
}

input StaticDataFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type StaticDataFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [StaticDataEntity!]!
}

input StaticDataRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataRecoverInputWhere!]
}

input StaticDataRecoverInputWhere {
  """Unique ID of the static data, auto generated."""
  id: FindOperatorDto

  """Name of the static data."""
  name: FindOperatorDto

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: FindOperatorDto

  """Table field name of the static data for key."""
  table_field_for_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static values of static data"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting preference of Static data"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Static data"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [StaticDataEntity!]!
}

input StaticDataRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataRemoveInputWhere!]
}

input StaticDataRemoveInputWhere {
  """Unique ID of the static data, auto generated."""
  id: FindOperatorDto

  """Name of the static data."""
  name: FindOperatorDto

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: FindOperatorDto

  """Table field name of the static data for key."""
  table_field_for_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static values of static data"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting preference of Static data"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Static data"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [StaticDataEntity!]!
}

input StaticDataRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataRestoreInputWhere!]
}

input StaticDataRestoreInputWhere {
  """Unique ID of the static data, auto generated."""
  id: FindOperatorDto

  """Name of the static data."""
  name: FindOperatorDto

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: FindOperatorDto

  """Table field name of the static data for key."""
  table_field_for_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static values of static data"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting preference of Static data"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Static data"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input StaticDataSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataSoftDeleteInputWhere!]
}

input StaticDataSoftDeleteInputWhere {
  """Unique ID of the static data, auto generated."""
  id: FindOperatorDto

  """Name of the static data."""
  name: FindOperatorDto

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: FindOperatorDto

  """Table field name of the static data for key."""
  table_field_for_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static values of static data"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting preference of Static data"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Static data"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input StaticDataSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataSoftRemoveInputWhere!]
}

input StaticDataSoftRemoveInputWhere {
  """Unique ID of the static data, auto generated."""
  id: FindOperatorDto

  """Name of the static data."""
  name: FindOperatorDto

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: FindOperatorDto

  """Table field name of the static data for key."""
  table_field_for_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static values of static data"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting preference of Static data"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Static data"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [StaticDataEntity!]!
}

input StaticDataUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: StaticDataUpdateInputSets!
}

input StaticDataUpdateInputSets {
  """Name of the static data."""
  name: String

  """Description of the static data."""
  desc: String

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: String

  """Table field name of the static data for key."""
  table_field_for_key: String

  """Table field name of the static data for value."""
  table_field_for_value: String

  """Table field name of the static data for deleted records."""
  table_field_for_deleted: String
}

input StaticDataUpdateInputWhere {
  """Unique ID of the static data, auto generated."""
  id: FindOperatorDto

  """Name of the static data."""
  name: FindOperatorDto

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: FindOperatorDto

  """Table field name of the static data for key."""
  table_field_for_key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static values of static data"""
  fr_static_data_values: [StaticDataValueFindInputWhere!]

  """Setting preference of Static data"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of Static data"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [StaticDataEntity!]!
}

input StaticDataUpsertInput {
  """Name of the static data."""
  name: String!

  """Description of the static data."""
  desc: String

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: String

  """Table field name of the static data for key."""
  table_field_for_key: String

  """Table field name of the static data for value."""
  table_field_for_value: String

  """Table field name of the static data for deleted records."""
  table_field_for_deleted: String

  """Unique ID of the static data, auto generated. undefined"""
  id: Int
}

type StaticDataUpsertOutput {
  """Unique ID of the static data, auto generated."""
  id: Int

  """Name of the static data."""
  name: String

  """Description of the static data."""
  desc: String

  """
  Table name of the static data. If static data depends on any seperate table.
  """
  table: String

  """Table field name of the static data for key."""
  table_field_for_key: String

  """Table field name of the static data for value."""
  table_field_for_value: String

  """Table field name of the static data for deleted records."""
  table_field_for_deleted: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Static values of static data"""
  fr_static_data_values: [StaticDataValueEntity!]

  """Setting preference of Static data"""
  fr_setting_preference: [SettingPreferenceEntity!]

  """Setting of Static data"""
  fr_setting: [SettingEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input StaticDataValueCreateInput {
  """Key of the static value."""
  key: String!

  """Value of the static value."""
  value: String!

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: Int!

  """Slug name of the static data."""
  sd_name: String!
}

type StaticDataValueCreateOutput {
  """Unique ID of the static value, auto generated."""
  id: Int

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: Int

  """Slug name of the static data."""
  sd_name: String

  """Key of the static value."""
  key: String

  """Value of the static value."""
  value: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Static date of static data value"""
  fr_static_data: StaticDataEntity

  """Setting preference of static data value"""
  fr_setting_preference: [SettingPreferenceEntity!]

  """Setting of static data value"""
  fr_setting: [SettingEntity!]
}

input StaticDataValueDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataValueDeleteInputWhere!]
}

input StaticDataValueDeleteInputWhere {
  """Unique ID of the static value, auto generated."""
  id: FindOperatorDto

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Key of the static value."""
  key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static date of static data value"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Setting preference of static data value"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of static data value"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataValueDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type StaticDataValueEntity {
  """Unique ID of the static value, auto generated."""
  id: Int

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: Int

  """Slug name of the static data."""
  sd_name: String

  """Key of the static value."""
  key: String

  """Value of the static value."""
  value: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Static date of static data value"""
  fr_static_data: StaticDataEntity

  """Setting preference of static data value"""
  fr_setting_preference: [SettingPreferenceEntity!]

  """Setting of static data value"""
  fr_setting: [SettingEntity!]
}

input StaticDataValueFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataValueFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: StaticDataValueFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: StaticDataValueFindInputSortOrder
}

input StaticDataValueFindInputGroupBy {
  key: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input StaticDataValueFindInputSortOrder {
  id: RecordSortDirectionEnum
  sd_id: RecordSortDirectionEnum
  sd_name: RecordSortDirectionEnum
  key: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input StaticDataValueFindInputWhere {
  """Unique ID of the static value, auto generated."""
  id: FindOperatorDto

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Key of the static value."""
  key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static date of static data value"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Setting preference of static data value"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of static data value"""
  fr_setting: [SettingFindInputWhere!]
}

input StaticDataValueFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type StaticDataValueFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [StaticDataValueEntity!]!
}

input StaticDataValueRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataValueRecoverInputWhere!]
}

input StaticDataValueRecoverInputWhere {
  """Unique ID of the static value, auto generated."""
  id: FindOperatorDto

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Key of the static value."""
  key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static date of static data value"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Setting preference of static data value"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of static data value"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataValueRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [StaticDataValueEntity!]!
}

input StaticDataValueRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataValueRemoveInputWhere!]
}

input StaticDataValueRemoveInputWhere {
  """Unique ID of the static value, auto generated."""
  id: FindOperatorDto

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Key of the static value."""
  key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static date of static data value"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Setting preference of static data value"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of static data value"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataValueRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [StaticDataValueEntity!]!
}

input StaticDataValueRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataValueRestoreInputWhere!]
}

input StaticDataValueRestoreInputWhere {
  """Unique ID of the static value, auto generated."""
  id: FindOperatorDto

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Key of the static value."""
  key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static date of static data value"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Setting preference of static data value"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of static data value"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataValueRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input StaticDataValueSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataValueSoftDeleteInputWhere!]
}

input StaticDataValueSoftDeleteInputWhere {
  """Unique ID of the static value, auto generated."""
  id: FindOperatorDto

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Key of the static value."""
  key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static date of static data value"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Setting preference of static data value"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of static data value"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataValueSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input StaticDataValueSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataValueSoftRemoveInputWhere!]
}

input StaticDataValueSoftRemoveInputWhere {
  """Unique ID of the static value, auto generated."""
  id: FindOperatorDto

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Key of the static value."""
  key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static date of static data value"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Setting preference of static data value"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of static data value"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataValueSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [StaticDataValueEntity!]!
}

input StaticDataValueUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [StaticDataValueUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: StaticDataValueUpdateInputSets!
}

input StaticDataValueUpdateInputSets {
  """Key of the static value."""
  key: String

  """Value of the static value."""
  value: String

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: Int

  """Slug name of the static data."""
  sd_name: String
}

input StaticDataValueUpdateInputWhere {
  """Unique ID of the static value, auto generated."""
  id: FindOperatorDto

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: FindOperatorDto

  """Slug name of the static data."""
  sd_name: FindOperatorDto

  """Key of the static value."""
  key: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Static date of static data value"""
  fr_static_data: [StaticDataFindInputWhere!]

  """Setting preference of static data value"""
  fr_setting_preference: [SettingPreferenceFindInputWhere!]

  """Setting of static data value"""
  fr_setting: [SettingFindInputWhere!]
}

type StaticDataValueUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [StaticDataValueEntity!]!
}

input StaticDataValueUpsertInput {
  """Key of the static value."""
  key: String!

  """Value of the static value."""
  value: String!

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: Int!

  """Slug name of the static data."""
  sd_name: String!

  """Unique ID of the static value, auto generated. undefined"""
  id: Int
}

type StaticDataValueUpsertOutput {
  """Unique ID of the static value, auto generated."""
  id: Int

  """Foregin key referencing staticdata table in the static value table."""
  sd_id: Int

  """Slug name of the static data."""
  sd_name: String

  """Key of the static value."""
  key: String

  """Value of the static value."""
  value: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Static date of static data value"""
  fr_static_data: StaticDataEntity

  """Setting preference of static data value"""
  fr_setting_preference: [SettingPreferenceEntity!]

  """Setting of static data value"""
  fr_setting: [SettingEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input SubregionCreateInput {
  """Required to get subregion for specifc region."""
  region_id: Int!

  """Name of the subregion."""
  name: String!

  """Translations of the subregion."""
  translations: String
}

type SubregionCreateOutput {
  """Unique ID of the subregion, auto generated."""
  id: Int

  """Required to get subregion for specifc region."""
  region_id: Int

  """Name of the subregion."""
  name: String

  """Translations of the subregion."""
  translations: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Region info of the subregion."""
  fr_region: RegionEntity

  """List of countries for this subregion."""
  fr_countries: CountryEntity
}

input SubregionDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SubregionDeleteInputWhere!]
}

input SubregionDeleteInputWhere {
  """Unique ID of the subregion, auto generated."""
  id: FindOperatorDto

  """Required to get subregion for specifc region."""
  region_id: FindOperatorDto

  """Name of the subregion."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Region info of the subregion."""
  fr_region: [RegionFindInputWhere!]

  """List of countries for this subregion."""
  fr_countries: [CountryFindInputWhere!]
}

type SubregionDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type SubregionEntity {
  """Unique ID of the subregion, auto generated."""
  id: Int

  """Required to get subregion for specifc region."""
  region_id: Int

  """Name of the subregion."""
  name: String

  """Translations of the subregion."""
  translations: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Region info of the subregion."""
  fr_region: RegionEntity

  """List of countries for this subregion."""
  fr_countries: CountryEntity
}

input SubregionFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SubregionFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: SubregionFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: SubregionFindInputSortOrder
}

input SubregionFindInputGroupBy {
  region_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input SubregionFindInputSortOrder {
  id: RecordSortDirectionEnum
  region_id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input SubregionFindInputWhere {
  """Unique ID of the subregion, auto generated."""
  id: FindOperatorDto

  """Required to get subregion for specifc region."""
  region_id: FindOperatorDto

  """Name of the subregion."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Region info of the subregion."""
  fr_region: [RegionFindInputWhere!]

  """List of countries for this subregion."""
  fr_countries: [CountryFindInputWhere!]
}

input SubregionFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type SubregionFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [SubregionEntity!]!
}

input SubregionRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SubregionRecoverInputWhere!]
}

input SubregionRecoverInputWhere {
  """Unique ID of the subregion, auto generated."""
  id: FindOperatorDto

  """Required to get subregion for specifc region."""
  region_id: FindOperatorDto

  """Name of the subregion."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Region info of the subregion."""
  fr_region: [RegionFindInputWhere!]

  """List of countries for this subregion."""
  fr_countries: [CountryFindInputWhere!]
}

type SubregionRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SubregionEntity!]!
}

input SubregionRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SubregionRemoveInputWhere!]
}

input SubregionRemoveInputWhere {
  """Unique ID of the subregion, auto generated."""
  id: FindOperatorDto

  """Required to get subregion for specifc region."""
  region_id: FindOperatorDto

  """Name of the subregion."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Region info of the subregion."""
  fr_region: [RegionFindInputWhere!]

  """List of countries for this subregion."""
  fr_countries: [CountryFindInputWhere!]
}

type SubregionRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SubregionEntity!]!
}

input SubregionRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SubregionRestoreInputWhere!]
}

input SubregionRestoreInputWhere {
  """Unique ID of the subregion, auto generated."""
  id: FindOperatorDto

  """Required to get subregion for specifc region."""
  region_id: FindOperatorDto

  """Name of the subregion."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Region info of the subregion."""
  fr_region: [RegionFindInputWhere!]

  """List of countries for this subregion."""
  fr_countries: [CountryFindInputWhere!]
}

type SubregionRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SubregionSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SubregionSoftDeleteInputWhere!]
}

input SubregionSoftDeleteInputWhere {
  """Unique ID of the subregion, auto generated."""
  id: FindOperatorDto

  """Required to get subregion for specifc region."""
  region_id: FindOperatorDto

  """Name of the subregion."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Region info of the subregion."""
  fr_region: [RegionFindInputWhere!]

  """List of countries for this subregion."""
  fr_countries: [CountryFindInputWhere!]
}

type SubregionSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input SubregionSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SubregionSoftRemoveInputWhere!]
}

input SubregionSoftRemoveInputWhere {
  """Unique ID of the subregion, auto generated."""
  id: FindOperatorDto

  """Required to get subregion for specifc region."""
  region_id: FindOperatorDto

  """Name of the subregion."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Region info of the subregion."""
  fr_region: [RegionFindInputWhere!]

  """List of countries for this subregion."""
  fr_countries: [CountryFindInputWhere!]
}

type SubregionSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [SubregionEntity!]!
}

input SubregionUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [SubregionUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: SubregionUpdateInputSets!
}

input SubregionUpdateInputSets {
  """Required to get subregion for specifc region."""
  region_id: Int

  """Name of the subregion."""
  name: String

  """Translations of the subregion."""
  translations: String
}

input SubregionUpdateInputWhere {
  """Unique ID of the subregion, auto generated."""
  id: FindOperatorDto

  """Required to get subregion for specifc region."""
  region_id: FindOperatorDto

  """Name of the subregion."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Region info of the subregion."""
  fr_region: [RegionFindInputWhere!]

  """List of countries for this subregion."""
  fr_countries: [CountryFindInputWhere!]
}

type SubregionUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [SubregionEntity!]!
}

input SubregionUpsertInput {
  """Required to get subregion for specifc region."""
  region_id: Int!

  """Name of the subregion."""
  name: String!

  """Translations of the subregion."""
  translations: String

  """Unique ID of the subregion, auto generated. undefined"""
  id: Int
}

type SubregionUpsertOutput {
  """Unique ID of the subregion, auto generated."""
  id: Int

  """Required to get subregion for specifc region."""
  region_id: Int

  """Name of the subregion."""
  name: String

  """Translations of the subregion."""
  translations: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Region info of the subregion."""
  fr_region: RegionEntity

  """List of countries for this subregion."""
  fr_countries: CountryEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input ThirdPartyPlatformCreateInput {
  """Description of the thirdparty platform."""
  slug: String!

  """Name of the thirdparty platform."""
  name: String!
}

type ThirdPartyPlatformCreateOutput {
  """Unique ID of the thirdparty platform, auto generated."""
  id: Int

  """Description of the thirdparty platform."""
  slug: String

  """Name of the thirdparty platform."""
  name: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides list of webhook responses."""
  fr_webhook_responses: [WebhookResponseEntity!]

  """Newsletter of third party platform."""
  fr_newsletter_third_party_platforms: [NewsLetterEntity!]
}

input ThirdPartyPlatformDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ThirdPartyPlatformDeleteInputWhere!]
}

input ThirdPartyPlatformDeleteInputWhere {
  """Unique ID of the thirdparty platform, auto generated."""
  id: FindOperatorDto

  """Description of the thirdparty platform."""
  slug: FindOperatorDto

  """Name of the thirdparty platform."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of webhook responses."""
  fr_webhook_responses: [WebhookResponseFindInputWhere!]
}

type ThirdPartyPlatformDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type ThirdPartyPlatformEntity {
  """Unique ID of the thirdparty platform, auto generated."""
  id: Int
  fr_rets_listing: [RetsListingEntity!]

  """Description of the thirdparty platform."""
  slug: String

  """Name of the thirdparty platform."""
  name: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides list of webhook responses."""
  fr_webhook_responses: [WebhookResponseEntity!]

  """Newsletter of third party platform."""
  fr_newsletter_third_party_platforms: [NewsLetterEntity!]
}

input ThirdPartyPlatformFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ThirdPartyPlatformFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: ThirdPartyPlatformFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: ThirdPartyPlatformFindInputSortOrder
}

input ThirdPartyPlatformFindInputGroupBy {
  name: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input ThirdPartyPlatformFindInputSortOrder {
  id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  slug: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input ThirdPartyPlatformFindInputWhere {
  """Unique ID of the thirdparty platform, auto generated."""
  id: FindOperatorDto

  """Description of the thirdparty platform."""
  slug: FindOperatorDto

  """Name of the thirdparty platform."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of webhook responses."""
  fr_webhook_responses: [WebhookResponseFindInputWhere!]
}

input ThirdPartyPlatformFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type ThirdPartyPlatformFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [ThirdPartyPlatformEntity!]!
}

input ThirdPartyPlatformRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ThirdPartyPlatformRecoverInputWhere!]
}

input ThirdPartyPlatformRecoverInputWhere {
  """Unique ID of the thirdparty platform, auto generated."""
  id: FindOperatorDto

  """Description of the thirdparty platform."""
  slug: FindOperatorDto

  """Name of the thirdparty platform."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of webhook responses."""
  fr_webhook_responses: [WebhookResponseFindInputWhere!]
}

type ThirdPartyPlatformRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ThirdPartyPlatformEntity!]!
}

input ThirdPartyPlatformRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ThirdPartyPlatformRemoveInputWhere!]
}

input ThirdPartyPlatformRemoveInputWhere {
  """Unique ID of the thirdparty platform, auto generated."""
  id: FindOperatorDto

  """Description of the thirdparty platform."""
  slug: FindOperatorDto

  """Name of the thirdparty platform."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of webhook responses."""
  fr_webhook_responses: [WebhookResponseFindInputWhere!]
}

type ThirdPartyPlatformRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ThirdPartyPlatformEntity!]!
}

input ThirdPartyPlatformRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ThirdPartyPlatformRestoreInputWhere!]
}

input ThirdPartyPlatformRestoreInputWhere {
  """Unique ID of the thirdparty platform, auto generated."""
  id: FindOperatorDto

  """Description of the thirdparty platform."""
  slug: FindOperatorDto

  """Name of the thirdparty platform."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of webhook responses."""
  fr_webhook_responses: [WebhookResponseFindInputWhere!]
}

type ThirdPartyPlatformRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ThirdPartyPlatformSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ThirdPartyPlatformSoftDeleteInputWhere!]
}

input ThirdPartyPlatformSoftDeleteInputWhere {
  """Unique ID of the thirdparty platform, auto generated."""
  id: FindOperatorDto

  """Description of the thirdparty platform."""
  slug: FindOperatorDto

  """Name of the thirdparty platform."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of webhook responses."""
  fr_webhook_responses: [WebhookResponseFindInputWhere!]
}

type ThirdPartyPlatformSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input ThirdPartyPlatformSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ThirdPartyPlatformSoftRemoveInputWhere!]
}

input ThirdPartyPlatformSoftRemoveInputWhere {
  """Unique ID of the thirdparty platform, auto generated."""
  id: FindOperatorDto

  """Description of the thirdparty platform."""
  slug: FindOperatorDto

  """Name of the thirdparty platform."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of webhook responses."""
  fr_webhook_responses: [WebhookResponseFindInputWhere!]
}

type ThirdPartyPlatformSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [ThirdPartyPlatformEntity!]!
}

input ThirdPartyPlatformUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [ThirdPartyPlatformUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: ThirdPartyPlatformUpdateInputSets!
}

input ThirdPartyPlatformUpdateInputSets {
  """Description of the thirdparty platform."""
  slug: String

  """Name of the thirdparty platform."""
  name: String
}

input ThirdPartyPlatformUpdateInputWhere {
  """Unique ID of the thirdparty platform, auto generated."""
  id: FindOperatorDto

  """Description of the thirdparty platform."""
  slug: FindOperatorDto

  """Name of the thirdparty platform."""
  name: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Provides list of webhook responses."""
  fr_webhook_responses: [WebhookResponseFindInputWhere!]
}

type ThirdPartyPlatformUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [ThirdPartyPlatformEntity!]!
}

input ThirdPartyPlatformUpsertInput {
  """Description of the thirdparty platform."""
  slug: String!

  """Name of the thirdparty platform."""
  name: String!

  """Unique ID of the thirdparty platform, auto generated. undefined"""
  id: Int
}

type ThirdPartyPlatformUpsertOutput {
  """Unique ID of the thirdparty platform, auto generated."""
  id: Int

  """Description of the thirdparty platform."""
  slug: String

  """Name of the thirdparty platform."""
  name: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Provides list of webhook responses."""
  fr_webhook_responses: [WebhookResponseEntity!]

  """Newsletter of third party platform."""
  fr_newsletter_third_party_platforms: [NewsLetterEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input TimezoneCreateInput {
  """Name of the timezone."""
  name: String!

  """Name of the timezone."""
  abbreviation: String!

  """Name of the timezone."""
  timestamp: Int!

  """Name of the timezone."""
  gmt_offset: Int!

  """Name of the timezone."""
  dst: Int!
}

type TimezoneCreateOutput {
  """Unique ID of the state, auto generated."""
  id: Int

  """Name of the timezone."""
  name: String

  """Abbreviation of the timezone."""
  abbreviation: String

  """Timestamp of the timezone."""
  timestamp: Int

  """Timestamp of the timezone."""
  gmt_offset: Int

  """Timestamp of the timezone."""
  dst: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """country timezone information."""
  fr_country_timezone: [CountryTimezoneEntity!]

  """Cities of timezone information."""
  fr_cities: [CityEntity!]
}

input TimezoneDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [TimezoneDeleteInputWhere!]
}

input TimezoneDeleteInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Name of the timezone."""
  name: FindOperatorDto

  """Abbreviation of the timezone."""
  abbreviation: FindOperatorDto

  """Timestamp of the timezone."""
  timestamp: FindOperatorDto

  """Timestamp of the timezone."""
  gmt_offset: FindOperatorDto

  """Timestamp of the timezone."""
  dst: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Cities of timezone information."""
  fr_cities: [CityFindInputWhere!]
}

type TimezoneDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type TimezoneEntity {
  """Unique ID of the state, auto generated."""
  id: Int

  """Name of the timezone."""
  name: String

  """Abbreviation of the timezone."""
  abbreviation: String

  """Timestamp of the timezone."""
  timestamp: Int

  """Timestamp of the timezone."""
  gmt_offset: Int

  """Timestamp of the timezone."""
  dst: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """country timezone information."""
  fr_country_timezone: [CountryTimezoneEntity!]

  """Cities of timezone information."""
  fr_cities: [CityEntity!]
}

input TimezoneFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [TimezoneFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: TimezoneFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: TimezoneFindInputSortOrder
}

input TimezoneFindInputGroupBy {
  name: Boolean
  abbreviation: Boolean
  dst: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input TimezoneFindInputSortOrder {
  id: RecordSortDirectionEnum
  name: RecordSortDirectionEnum
  abbreviation: RecordSortDirectionEnum
  timestamp: RecordSortDirectionEnum
  gmt_offset: RecordSortDirectionEnum
  dst: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input TimezoneFindInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Name of the timezone."""
  name: FindOperatorDto

  """Abbreviation of the timezone."""
  abbreviation: FindOperatorDto

  """Timestamp of the timezone."""
  timestamp: FindOperatorDto

  """Timestamp of the timezone."""
  gmt_offset: FindOperatorDto

  """Timestamp of the timezone."""
  dst: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Cities of timezone information."""
  fr_cities: [CityFindInputWhere!]
}

input TimezoneFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type TimezoneFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [TimezoneEntity!]!
}

input TimezoneRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [TimezoneRecoverInputWhere!]
}

input TimezoneRecoverInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Name of the timezone."""
  name: FindOperatorDto

  """Abbreviation of the timezone."""
  abbreviation: FindOperatorDto

  """Timestamp of the timezone."""
  timestamp: FindOperatorDto

  """Timestamp of the timezone."""
  gmt_offset: FindOperatorDto

  """Timestamp of the timezone."""
  dst: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Cities of timezone information."""
  fr_cities: [CityFindInputWhere!]
}

type TimezoneRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [TimezoneEntity!]!
}

input TimezoneRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [TimezoneRemoveInputWhere!]
}

input TimezoneRemoveInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Name of the timezone."""
  name: FindOperatorDto

  """Abbreviation of the timezone."""
  abbreviation: FindOperatorDto

  """Timestamp of the timezone."""
  timestamp: FindOperatorDto

  """Timestamp of the timezone."""
  gmt_offset: FindOperatorDto

  """Timestamp of the timezone."""
  dst: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Cities of timezone information."""
  fr_cities: [CityFindInputWhere!]
}

type TimezoneRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [TimezoneEntity!]!
}

input TimezoneRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [TimezoneRestoreInputWhere!]
}

input TimezoneRestoreInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Name of the timezone."""
  name: FindOperatorDto

  """Abbreviation of the timezone."""
  abbreviation: FindOperatorDto

  """Timestamp of the timezone."""
  timestamp: FindOperatorDto

  """Timestamp of the timezone."""
  gmt_offset: FindOperatorDto

  """Timestamp of the timezone."""
  dst: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Cities of timezone information."""
  fr_cities: [CityFindInputWhere!]
}

type TimezoneRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input TimezoneSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [TimezoneSoftDeleteInputWhere!]
}

input TimezoneSoftDeleteInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Name of the timezone."""
  name: FindOperatorDto

  """Abbreviation of the timezone."""
  abbreviation: FindOperatorDto

  """Timestamp of the timezone."""
  timestamp: FindOperatorDto

  """Timestamp of the timezone."""
  gmt_offset: FindOperatorDto

  """Timestamp of the timezone."""
  dst: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Cities of timezone information."""
  fr_cities: [CityFindInputWhere!]
}

type TimezoneSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input TimezoneSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [TimezoneSoftRemoveInputWhere!]
}

input TimezoneSoftRemoveInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Name of the timezone."""
  name: FindOperatorDto

  """Abbreviation of the timezone."""
  abbreviation: FindOperatorDto

  """Timestamp of the timezone."""
  timestamp: FindOperatorDto

  """Timestamp of the timezone."""
  gmt_offset: FindOperatorDto

  """Timestamp of the timezone."""
  dst: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Cities of timezone information."""
  fr_cities: [CityFindInputWhere!]
}

type TimezoneSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [TimezoneEntity!]!
}

input TimezoneUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [TimezoneUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: TimezoneUpdateInputSets!
}

input TimezoneUpdateInputSets {
  """Name of the timezone."""
  name: String

  """Name of the timezone."""
  abbreviation: String

  """Name of the timezone."""
  timestamp: Int

  """Name of the timezone."""
  gmt_offset: Int

  """Name of the timezone."""
  dst: Int
}

input TimezoneUpdateInputWhere {
  """Unique ID of the state, auto generated."""
  id: FindOperatorDto

  """Name of the timezone."""
  name: FindOperatorDto

  """Abbreviation of the timezone."""
  abbreviation: FindOperatorDto

  """Timestamp of the timezone."""
  timestamp: FindOperatorDto

  """Timestamp of the timezone."""
  gmt_offset: FindOperatorDto

  """Timestamp of the timezone."""
  dst: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Cities of timezone information."""
  fr_cities: [CityFindInputWhere!]
}

type TimezoneUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [TimezoneEntity!]!
}

input TimezoneUpsertInput {
  """Name of the timezone."""
  name: String!

  """Name of the timezone."""
  abbreviation: String!

  """Name of the timezone."""
  timestamp: Int!

  """Name of the timezone."""
  gmt_offset: Int!

  """Name of the timezone."""
  dst: Int!

  """Unique ID of the state, auto generated. undefined"""
  id: Int
}

type TimezoneUpsertOutput {
  """Unique ID of the state, auto generated."""
  id: Int

  """Name of the timezone."""
  name: String

  """Abbreviation of the timezone."""
  abbreviation: String

  """Timestamp of the timezone."""
  timestamp: Int

  """Timestamp of the timezone."""
  gmt_offset: Int

  """Timestamp of the timezone."""
  dst: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  If record is deleted, then date time value will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """country timezone information."""
  fr_country_timezone: [CountryTimezoneEntity!]

  """Cities of timezone information."""
  fr_cities: [CityEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type UploadFileAccessUrlDto {
  """Direct access url of the file."""
  direct: String

  """Secure url of the file using rewrite url pattern."""
  secure: String

  """Direct access url of the file."""
  thumb: String
}

"""
Action type performed with record during database operation of upsert()
"""
enum UpsertStatusEnum {
  """New record inserted using upsert"""
  INSERTED

  """Record updated using upsert"""
  UPDATED

  """Record not changed using upsert"""
  NOCHANGE

  """Undefined status during upsert"""
  UNDEFINED
}

input UserAddressCreateInput {
  """Unique ID of the entity, This is the same as user id"""
  u_id: Int!

  """Title of the user address."""
  title: String

  """First name of the user address."""
  fname: String

  """Last name of the user address."""
  lname: String

  """Mobile number of the user address."""
  mobile: String

  """Mobile country code of the user address."""
  mobile_cc: String

  """Email of the user address."""
  email: String

  """Address of the user address."""
  address: String

  """Country ID of the user address."""
  country_id: Int!

  """State ID of the user address."""
  state_id: Int!

  """City ID of the user address."""
  city_id: Int!

  """Postal zip code of the user address."""
  postal_zip_code: String
}

type UserAddressCreateOutput {
  """Unique ID of the entity, This is the same as user id"""
  id: Int

  """User ID of the user address."""
  u_id: Int

  """Title of the user address."""
  title: String

  """First name of the user address."""
  fname: String

  """Last name of the user address."""
  lname: String

  """Mobile number of the user address."""
  mobile: String

  """Mobile country code of the user address."""
  mobile_cc: String

  """Email of the user address."""
  email: String

  """Address of the user address."""
  address: String

  """Country ID of the user address."""
  country_id: Int

  """State ID of the user address."""
  state_id: Int

  """City ID of the user address."""
  city_id: Int

  """Postal zip code of the user address."""
  postal_zip_code: String

  """Date time when user address is created."""
  created: DateTime

  """Date time when user address is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User of the user address."""
  fr_user: UserEntity

  """Country of the user address."""
  fr_country: CountryEntity

  """State of the user address."""
  fr_state: StateEntity

  """City of the user address."""
  fr_city: CityEntity
}

input UserAddressDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAddressDeleteInputWhere!]
}

input UserAddressDeleteInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """User ID of the user address."""
  u_id: FindOperatorDto

  """Title of the user address."""
  title: FindOperatorDto

  """First name of the user address."""
  fname: FindOperatorDto

  """Last name of the user address."""
  lname: FindOperatorDto

  """Mobile number of the user address."""
  mobile: FindOperatorDto

  """Mobile country code of the user address."""
  mobile_cc: FindOperatorDto

  """Email of the user address."""
  email: FindOperatorDto

  """Address of the user address."""
  address: FindOperatorDto

  """Country ID of the user address."""
  country_id: FindOperatorDto

  """State ID of the user address."""
  state_id: FindOperatorDto

  """City ID of the user address."""
  city_id: FindOperatorDto

  """Postal zip code of the user address."""
  postal_zip_code: FindOperatorDto

  """Date time when user address is created."""
  created: FindOperatorDto

  """Date time when user address is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user address."""
  fr_user: [UserFindInputWhere!]

  """Country of the user address."""
  fr_country: [CountryFindInputWhere!]

  """State of the user address."""
  fr_state: [StateFindInputWhere!]

  """City of the user address."""
  fr_city: [CityFindInputWhere!]
}

type UserAddressDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserAddressEntity {
  """Unique ID of the entity, This is the same as user id"""
  id: Int

  """User ID of the user address."""
  u_id: Int

  """Title of the user address."""
  title: String

  """First name of the user address."""
  fname: String

  """Last name of the user address."""
  lname: String

  """Mobile number of the user address."""
  mobile: String

  """Mobile country code of the user address."""
  mobile_cc: String

  """Email of the user address."""
  email: String

  """Address of the user address."""
  address: String

  """Country ID of the user address."""
  country_id: Int

  """State ID of the user address."""
  state_id: Int

  """City ID of the user address."""
  city_id: Int

  """Postal zip code of the user address."""
  postal_zip_code: String

  """Date time when user address is created."""
  created: DateTime

  """Date time when user address is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User of the user address."""
  fr_user: UserEntity

  """Country of the user address."""
  fr_country: CountryEntity

  """State of the user address."""
  fr_state: StateEntity

  """City of the user address."""
  fr_city: CityEntity
}

input UserAddressFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAddressFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserAddressFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserAddressFindInputSortOrder
}

input UserAddressFindInputGroupBy {
  u_id: Boolean
  title: Boolean
  mobile_cc: Boolean
  country_id: Boolean
  state_id: Boolean
  city_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserAddressFindInputSortOrder {
  id: RecordSortDirectionEnum
  u_id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  fname: RecordSortDirectionEnum
  lname: RecordSortDirectionEnum
  mobile_cc: RecordSortDirectionEnum
  country_id: RecordSortDirectionEnum
  state_id: RecordSortDirectionEnum
  city_id: RecordSortDirectionEnum
  postal_zip_code: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserAddressFindInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """User ID of the user address."""
  u_id: FindOperatorDto

  """Title of the user address."""
  title: FindOperatorDto

  """First name of the user address."""
  fname: FindOperatorDto

  """Last name of the user address."""
  lname: FindOperatorDto

  """Mobile number of the user address."""
  mobile: FindOperatorDto

  """Mobile country code of the user address."""
  mobile_cc: FindOperatorDto

  """Email of the user address."""
  email: FindOperatorDto

  """Address of the user address."""
  address: FindOperatorDto

  """Country ID of the user address."""
  country_id: FindOperatorDto

  """State ID of the user address."""
  state_id: FindOperatorDto

  """City ID of the user address."""
  city_id: FindOperatorDto

  """Postal zip code of the user address."""
  postal_zip_code: FindOperatorDto

  """Date time when user address is created."""
  created: FindOperatorDto

  """Date time when user address is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user address."""
  fr_user: [UserFindInputWhere!]

  """Country of the user address."""
  fr_country: [CountryFindInputWhere!]

  """State of the user address."""
  fr_state: [StateFindInputWhere!]

  """City of the user address."""
  fr_city: [CityFindInputWhere!]
}

input UserAddressFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserAddressFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserAddressEntity!]!
}

input UserAddressRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAddressRecoverInputWhere!]
}

input UserAddressRecoverInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """User ID of the user address."""
  u_id: FindOperatorDto

  """Title of the user address."""
  title: FindOperatorDto

  """First name of the user address."""
  fname: FindOperatorDto

  """Last name of the user address."""
  lname: FindOperatorDto

  """Mobile number of the user address."""
  mobile: FindOperatorDto

  """Mobile country code of the user address."""
  mobile_cc: FindOperatorDto

  """Email of the user address."""
  email: FindOperatorDto

  """Address of the user address."""
  address: FindOperatorDto

  """Country ID of the user address."""
  country_id: FindOperatorDto

  """State ID of the user address."""
  state_id: FindOperatorDto

  """City ID of the user address."""
  city_id: FindOperatorDto

  """Postal zip code of the user address."""
  postal_zip_code: FindOperatorDto

  """Date time when user address is created."""
  created: FindOperatorDto

  """Date time when user address is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user address."""
  fr_user: [UserFindInputWhere!]

  """Country of the user address."""
  fr_country: [CountryFindInputWhere!]

  """State of the user address."""
  fr_state: [StateFindInputWhere!]

  """City of the user address."""
  fr_city: [CityFindInputWhere!]
}

type UserAddressRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserAddressEntity!]!
}

input UserAddressRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAddressRemoveInputWhere!]
}

input UserAddressRemoveInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """User ID of the user address."""
  u_id: FindOperatorDto

  """Title of the user address."""
  title: FindOperatorDto

  """First name of the user address."""
  fname: FindOperatorDto

  """Last name of the user address."""
  lname: FindOperatorDto

  """Mobile number of the user address."""
  mobile: FindOperatorDto

  """Mobile country code of the user address."""
  mobile_cc: FindOperatorDto

  """Email of the user address."""
  email: FindOperatorDto

  """Address of the user address."""
  address: FindOperatorDto

  """Country ID of the user address."""
  country_id: FindOperatorDto

  """State ID of the user address."""
  state_id: FindOperatorDto

  """City ID of the user address."""
  city_id: FindOperatorDto

  """Postal zip code of the user address."""
  postal_zip_code: FindOperatorDto

  """Date time when user address is created."""
  created: FindOperatorDto

  """Date time when user address is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user address."""
  fr_user: [UserFindInputWhere!]

  """Country of the user address."""
  fr_country: [CountryFindInputWhere!]

  """State of the user address."""
  fr_state: [StateFindInputWhere!]

  """City of the user address."""
  fr_city: [CityFindInputWhere!]
}

type UserAddressRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserAddressEntity!]!
}

input UserAddressRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAddressRestoreInputWhere!]
}

input UserAddressRestoreInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """User ID of the user address."""
  u_id: FindOperatorDto

  """Title of the user address."""
  title: FindOperatorDto

  """First name of the user address."""
  fname: FindOperatorDto

  """Last name of the user address."""
  lname: FindOperatorDto

  """Mobile number of the user address."""
  mobile: FindOperatorDto

  """Mobile country code of the user address."""
  mobile_cc: FindOperatorDto

  """Email of the user address."""
  email: FindOperatorDto

  """Address of the user address."""
  address: FindOperatorDto

  """Country ID of the user address."""
  country_id: FindOperatorDto

  """State ID of the user address."""
  state_id: FindOperatorDto

  """City ID of the user address."""
  city_id: FindOperatorDto

  """Postal zip code of the user address."""
  postal_zip_code: FindOperatorDto

  """Date time when user address is created."""
  created: FindOperatorDto

  """Date time when user address is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user address."""
  fr_user: [UserFindInputWhere!]

  """Country of the user address."""
  fr_country: [CountryFindInputWhere!]

  """State of the user address."""
  fr_state: [StateFindInputWhere!]

  """City of the user address."""
  fr_city: [CityFindInputWhere!]
}

type UserAddressRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserAddressSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAddressSoftDeleteInputWhere!]
}

input UserAddressSoftDeleteInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """User ID of the user address."""
  u_id: FindOperatorDto

  """Title of the user address."""
  title: FindOperatorDto

  """First name of the user address."""
  fname: FindOperatorDto

  """Last name of the user address."""
  lname: FindOperatorDto

  """Mobile number of the user address."""
  mobile: FindOperatorDto

  """Mobile country code of the user address."""
  mobile_cc: FindOperatorDto

  """Email of the user address."""
  email: FindOperatorDto

  """Address of the user address."""
  address: FindOperatorDto

  """Country ID of the user address."""
  country_id: FindOperatorDto

  """State ID of the user address."""
  state_id: FindOperatorDto

  """City ID of the user address."""
  city_id: FindOperatorDto

  """Postal zip code of the user address."""
  postal_zip_code: FindOperatorDto

  """Date time when user address is created."""
  created: FindOperatorDto

  """Date time when user address is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user address."""
  fr_user: [UserFindInputWhere!]

  """Country of the user address."""
  fr_country: [CountryFindInputWhere!]

  """State of the user address."""
  fr_state: [StateFindInputWhere!]

  """City of the user address."""
  fr_city: [CityFindInputWhere!]
}

type UserAddressSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserAddressSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAddressSoftRemoveInputWhere!]
}

input UserAddressSoftRemoveInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """User ID of the user address."""
  u_id: FindOperatorDto

  """Title of the user address."""
  title: FindOperatorDto

  """First name of the user address."""
  fname: FindOperatorDto

  """Last name of the user address."""
  lname: FindOperatorDto

  """Mobile number of the user address."""
  mobile: FindOperatorDto

  """Mobile country code of the user address."""
  mobile_cc: FindOperatorDto

  """Email of the user address."""
  email: FindOperatorDto

  """Address of the user address."""
  address: FindOperatorDto

  """Country ID of the user address."""
  country_id: FindOperatorDto

  """State ID of the user address."""
  state_id: FindOperatorDto

  """City ID of the user address."""
  city_id: FindOperatorDto

  """Postal zip code of the user address."""
  postal_zip_code: FindOperatorDto

  """Date time when user address is created."""
  created: FindOperatorDto

  """Date time when user address is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user address."""
  fr_user: [UserFindInputWhere!]

  """Country of the user address."""
  fr_country: [CountryFindInputWhere!]

  """State of the user address."""
  fr_state: [StateFindInputWhere!]

  """City of the user address."""
  fr_city: [CityFindInputWhere!]
}

type UserAddressSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserAddressEntity!]!
}

input UserAddressUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAddressUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserAddressUpdateInputSets!
}

input UserAddressUpdateInputSets {
  """Unique ID of the entity, This is the same as user id"""
  u_id: Int

  """Title of the user address."""
  title: String

  """First name of the user address."""
  fname: String

  """Last name of the user address."""
  lname: String

  """Mobile number of the user address."""
  mobile: String

  """Mobile country code of the user address."""
  mobile_cc: String

  """Email of the user address."""
  email: String

  """Address of the user address."""
  address: String

  """Country ID of the user address."""
  country_id: Int

  """State ID of the user address."""
  state_id: Int

  """City ID of the user address."""
  city_id: Int

  """Postal zip code of the user address."""
  postal_zip_code: String
}

input UserAddressUpdateInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """User ID of the user address."""
  u_id: FindOperatorDto

  """Title of the user address."""
  title: FindOperatorDto

  """First name of the user address."""
  fname: FindOperatorDto

  """Last name of the user address."""
  lname: FindOperatorDto

  """Mobile number of the user address."""
  mobile: FindOperatorDto

  """Mobile country code of the user address."""
  mobile_cc: FindOperatorDto

  """Email of the user address."""
  email: FindOperatorDto

  """Address of the user address."""
  address: FindOperatorDto

  """Country ID of the user address."""
  country_id: FindOperatorDto

  """State ID of the user address."""
  state_id: FindOperatorDto

  """City ID of the user address."""
  city_id: FindOperatorDto

  """Postal zip code of the user address."""
  postal_zip_code: FindOperatorDto

  """Date time when user address is created."""
  created: FindOperatorDto

  """Date time when user address is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user address."""
  fr_user: [UserFindInputWhere!]

  """Country of the user address."""
  fr_country: [CountryFindInputWhere!]

  """State of the user address."""
  fr_state: [StateFindInputWhere!]

  """City of the user address."""
  fr_city: [CityFindInputWhere!]
}

type UserAddressUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserAddressEntity!]!
}

input UserAddressUpsertInput {
  """Unique ID of the entity, This is the same as user id"""
  u_id: Int!

  """Title of the user address."""
  title: String

  """First name of the user address."""
  fname: String

  """Last name of the user address."""
  lname: String

  """Mobile number of the user address."""
  mobile: String

  """Mobile country code of the user address."""
  mobile_cc: String

  """Email of the user address."""
  email: String

  """Address of the user address."""
  address: String

  """Country ID of the user address."""
  country_id: Int!

  """State ID of the user address."""
  state_id: Int!

  """City ID of the user address."""
  city_id: Int!

  """Postal zip code of the user address."""
  postal_zip_code: String

  """Unique ID of the entity, This is the same as user id undefined"""
  id: Int
}

type UserAddressUpsertOutput {
  """Unique ID of the entity, This is the same as user id"""
  id: Int

  """User ID of the user address."""
  u_id: Int

  """Title of the user address."""
  title: String

  """First name of the user address."""
  fname: String

  """Last name of the user address."""
  lname: String

  """Mobile number of the user address."""
  mobile: String

  """Mobile country code of the user address."""
  mobile_cc: String

  """Email of the user address."""
  email: String

  """Address of the user address."""
  address: String

  """Country ID of the user address."""
  country_id: Int

  """State ID of the user address."""
  state_id: Int

  """City ID of the user address."""
  city_id: Int

  """Postal zip code of the user address."""
  postal_zip_code: String

  """Date time when user address is created."""
  created: DateTime

  """Date time when user address is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User of the user address."""
  fr_user: UserEntity

  """Country of the user address."""
  fr_country: CountryEntity

  """State of the user address."""
  fr_state: StateEntity

  """City of the user address."""
  fr_city: CityEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserAuthenticationCreateInput {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int!

  """
  Identify string for the user. Password should be combination of digit, uppercase, lowercase, special charector and no more than 3 consecutive identical characters.
  """
  identify: String

  """Enter your password again."""
  identify_confirm: String

  """Force user to reset identify strig."""
  force_reset: DateTime = "1970-01-01T00:00:00.000Z"

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime
}

type UserAuthenticationCreateOutput {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """User info of the user."""
  fr_user: UserEntity

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """Sessions of the user."""
  fr_user_sessions: [SessionEntity!]
}

input UserAuthenticationDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthenticationDeleteInputWhere!]
}

input UserAuthenticationDeleteInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """Last changed identify string by the user."""
  last_changed: FindOperatorDto

  """Force user to reset identify strig."""
  force_reset: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """User info of the user."""
  fr_user: [UserFindInputWhere!]

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Sessions of the user."""
  fr_user_sessions: [SessionFindInputWhere!]
}

type UserAuthenticationDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserAuthenticationEntity {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """User info of the user."""
  fr_user: UserEntity

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """Sessions of the user."""
  fr_user_sessions: [SessionEntity!]
}

input UserAuthenticationFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthenticationFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserAuthenticationFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserAuthenticationFindInputSortOrder
}

input UserAuthenticationFindInputGroupBy {
  id: Boolean
  last_changed: Boolean
  force_reset: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserAuthenticationFindInputSortOrder {
  id: RecordSortDirectionEnum
  last_changed: RecordSortDirectionEnum
  force_reset: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserAuthenticationFindInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """Last changed identify string by the user."""
  last_changed: FindOperatorDto

  """Force user to reset identify strig."""
  force_reset: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """User info of the user."""
  fr_user: [UserFindInputWhere!]

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Sessions of the user."""
  fr_user_sessions: [SessionFindInputWhere!]
}

input UserAuthenticationFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserAuthenticationFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserAuthenticationEntity!]!
}

type UserAuthenticationFindOutputRows {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """User info of the user."""
  fr_user: UserEntity

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """Sessions of the user."""
  fr_user_sessions: [SessionEntity!]
}

input UserAuthenticationRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthenticationRecoverInputWhere!]
}

input UserAuthenticationRecoverInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """Last changed identify string by the user."""
  last_changed: FindOperatorDto

  """Force user to reset identify strig."""
  force_reset: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """User info of the user."""
  fr_user: [UserFindInputWhere!]

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Sessions of the user."""
  fr_user_sessions: [SessionFindInputWhere!]
}

type UserAuthenticationRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserAuthenticationRecoverOutputAffectedRows!]!
}

type UserAuthenticationRecoverOutputAffectedRows {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """User info of the user."""
  fr_user: UserEntity

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """Sessions of the user."""
  fr_user_sessions: [SessionEntity!]
}

input UserAuthenticationRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthenticationRemoveInputWhere!]
}

input UserAuthenticationRemoveInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """Last changed identify string by the user."""
  last_changed: FindOperatorDto

  """Force user to reset identify strig."""
  force_reset: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """User info of the user."""
  fr_user: [UserFindInputWhere!]

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Sessions of the user."""
  fr_user_sessions: [SessionFindInputWhere!]
}

type UserAuthenticationRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserAuthenticationRemoveOutputAffectedRows!]!
}

type UserAuthenticationRemoveOutputAffectedRows {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """User info of the user."""
  fr_user: UserEntity

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """Sessions of the user."""
  fr_user_sessions: [SessionEntity!]
}

input UserAuthenticationRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthenticationRestoreInputWhere!]
}

input UserAuthenticationRestoreInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """Last changed identify string by the user."""
  last_changed: FindOperatorDto

  """Force user to reset identify strig."""
  force_reset: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """User info of the user."""
  fr_user: [UserFindInputWhere!]

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Sessions of the user."""
  fr_user_sessions: [SessionFindInputWhere!]
}

type UserAuthenticationRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserAuthenticationSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthenticationSoftDeleteInputWhere!]
}

input UserAuthenticationSoftDeleteInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """Last changed identify string by the user."""
  last_changed: FindOperatorDto

  """Force user to reset identify strig."""
  force_reset: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """User info of the user."""
  fr_user: [UserFindInputWhere!]

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Sessions of the user."""
  fr_user_sessions: [SessionFindInputWhere!]
}

type UserAuthenticationSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserAuthenticationSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthenticationSoftRemoveInputWhere!]
}

input UserAuthenticationSoftRemoveInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """Last changed identify string by the user."""
  last_changed: FindOperatorDto

  """Force user to reset identify strig."""
  force_reset: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """User info of the user."""
  fr_user: [UserFindInputWhere!]

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Sessions of the user."""
  fr_user_sessions: [SessionFindInputWhere!]
}

type UserAuthenticationSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserAuthenticationSoftRemoveOutputAffectedRows!]!
}

type UserAuthenticationSoftRemoveOutputAffectedRows {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """User info of the user."""
  fr_user: UserEntity

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """Sessions of the user."""
  fr_user_sessions: [SessionEntity!]
}

input UserAuthenticationUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthenticationUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserAuthenticationUpdateInputSets!
}

input UserAuthenticationUpdateInputSets {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """
  Identify string for the user. Password should be combination of digit, uppercase, lowercase, special charector and no more than 3 consecutive identical characters.
  """
  identify: String

  """Enter your password again."""
  identify_confirm: String

  """Force user to reset identify strig."""
  force_reset: DateTime = "1970-01-01T00:00:00.000Z"

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime
}

input UserAuthenticationUpdateInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """Last changed identify string by the user."""
  last_changed: FindOperatorDto

  """Force user to reset identify strig."""
  force_reset: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """User info of the user."""
  fr_user: [UserFindInputWhere!]

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Sessions of the user."""
  fr_user_sessions: [SessionFindInputWhere!]
}

type UserAuthenticationUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserAuthenticationUpdateOutputAffectedRows!]!
}

type UserAuthenticationUpdateOutputAffectedRows {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """User info of the user."""
  fr_user: UserEntity

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """Sessions of the user."""
  fr_user_sessions: [SessionEntity!]
}

input UserAuthenticationUpsertInput {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int!

  """
  Identify string for the user. Password should be combination of digit, uppercase, lowercase, special charector and no more than 3 consecutive identical characters.
  """
  identify: String

  """Enter your password again."""
  identify_confirm: String

  """Force user to reset identify strig."""
  force_reset: DateTime = "1970-01-01T00:00:00.000Z"

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime
}

type UserAuthenticationUpsertOutput {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """One time password for the user signin."""
  otp: String

  """One time password expiry datetime for the user signin."""
  otp_expiry: DateTime

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """User info of the user."""
  fr_user: UserEntity

  """Authorisations (roles) of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """Sessions of the user."""
  fr_user_sessions: [SessionEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserAuthorisationCreateInput {
  """User id of the user."""
  u_id: Int!

  """Authentication id of the user."""
  au_id: Int

  """Authorisation role id of the user."""
  ar_id: Int!

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: String

  """
  Privileges of the user. This is overwrite default authorisation permission and privileges this provide highly flexible integration
  """
  privileges: String
}

type UserAuthorisationCreateOutput {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """User id of the user."""
  u_id: Int

  """Authentication id of the user."""
  au_id: Int

  """Authorisation role id of the user."""
  ar_id: Int

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: String

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  privileges: String

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """Authentication info of the user."""
  fr_user_auth: UserAuthenticationEntity

  """Authorisation info of the user role."""
  fr_authorisation: AuthorisationEntity

  """User info of the user."""
  fr_user: UserEntity
}

input UserAuthorisationDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthorisationDeleteInputWhere!]
}

input UserAuthorisationDeleteInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """User id of the user."""
  u_id: FindOperatorDto

  """Authentication id of the user."""
  au_id: FindOperatorDto

  """Authorisation role id of the user."""
  ar_id: FindOperatorDto

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """Authentication info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Authorisation info of the user role."""
  fr_authorisation: [AuthorisationFindInputWhere!]

  """User info of the user."""
  fr_user: [UserFindInputWhere!]
}

type UserAuthorisationDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserAuthorisationEntity {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """User id of the user."""
  u_id: Int

  """Authentication id of the user."""
  au_id: Int

  """Authorisation role id of the user."""
  ar_id: Int

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: String

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  privileges: String

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """Authentication info of the user."""
  fr_user_auth: UserAuthenticationEntity

  """Authorisation info of the user role."""
  fr_authorisation: AuthorisationEntity

  """User info of the user."""
  fr_user: UserEntity
}

input UserAuthorisationFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthorisationFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserAuthorisationFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserAuthorisationFindInputSortOrder
}

input UserAuthorisationFindInputGroupBy {
  u_id: Boolean
  au_id: Boolean
  ar_id: Boolean
  role_title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserAuthorisationFindInputSortOrder {
  id: RecordSortDirectionEnum
  au_id: RecordSortDirectionEnum
  u_id: RecordSortDirectionEnum
  ar_id: RecordSortDirectionEnum
  role_title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserAuthorisationFindInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """User id of the user."""
  u_id: FindOperatorDto

  """Authentication id of the user."""
  au_id: FindOperatorDto

  """Authorisation role id of the user."""
  ar_id: FindOperatorDto

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """Authentication info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Authorisation info of the user role."""
  fr_authorisation: [AuthorisationFindInputWhere!]

  """User info of the user."""
  fr_user: [UserFindInputWhere!]
}

input UserAuthorisationFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserAuthorisationFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserAuthorisationEntity!]!
}

input UserAuthorisationRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthorisationRecoverInputWhere!]
}

input UserAuthorisationRecoverInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """User id of the user."""
  u_id: FindOperatorDto

  """Authentication id of the user."""
  au_id: FindOperatorDto

  """Authorisation role id of the user."""
  ar_id: FindOperatorDto

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """Authentication info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Authorisation info of the user role."""
  fr_authorisation: [AuthorisationFindInputWhere!]

  """User info of the user."""
  fr_user: [UserFindInputWhere!]
}

type UserAuthorisationRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserAuthorisationEntity!]!
}

input UserAuthorisationRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthorisationRemoveInputWhere!]
}

input UserAuthorisationRemoveInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """User id of the user."""
  u_id: FindOperatorDto

  """Authentication id of the user."""
  au_id: FindOperatorDto

  """Authorisation role id of the user."""
  ar_id: FindOperatorDto

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """Authentication info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Authorisation info of the user role."""
  fr_authorisation: [AuthorisationFindInputWhere!]

  """User info of the user."""
  fr_user: [UserFindInputWhere!]
}

type UserAuthorisationRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserAuthorisationEntity!]!
}

input UserAuthorisationRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthorisationRestoreInputWhere!]
}

input UserAuthorisationRestoreInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """User id of the user."""
  u_id: FindOperatorDto

  """Authentication id of the user."""
  au_id: FindOperatorDto

  """Authorisation role id of the user."""
  ar_id: FindOperatorDto

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """Authentication info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Authorisation info of the user role."""
  fr_authorisation: [AuthorisationFindInputWhere!]

  """User info of the user."""
  fr_user: [UserFindInputWhere!]
}

type UserAuthorisationRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserAuthorisationSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthorisationSoftDeleteInputWhere!]
}

input UserAuthorisationSoftDeleteInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """User id of the user."""
  u_id: FindOperatorDto

  """Authentication id of the user."""
  au_id: FindOperatorDto

  """Authorisation role id of the user."""
  ar_id: FindOperatorDto

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """Authentication info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Authorisation info of the user role."""
  fr_authorisation: [AuthorisationFindInputWhere!]

  """User info of the user."""
  fr_user: [UserFindInputWhere!]
}

type UserAuthorisationSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserAuthorisationSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthorisationSoftRemoveInputWhere!]
}

input UserAuthorisationSoftRemoveInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """User id of the user."""
  u_id: FindOperatorDto

  """Authentication id of the user."""
  au_id: FindOperatorDto

  """Authorisation role id of the user."""
  ar_id: FindOperatorDto

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """Authentication info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Authorisation info of the user role."""
  fr_authorisation: [AuthorisationFindInputWhere!]

  """User info of the user."""
  fr_user: [UserFindInputWhere!]
}

type UserAuthorisationSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserAuthorisationEntity!]!
}

input UserAuthorisationUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserAuthorisationUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserAuthorisationUpdateInputSets!
}

input UserAuthorisationUpdateInputSets {
  """User id of the user."""
  u_id: Int

  """Authentication id of the user."""
  au_id: Int

  """Authorisation role id of the user."""
  ar_id: Int

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: String

  """
  Privileges of the user. This is overwrite default authorisation permission and privileges this provide highly flexible integration
  """
  privileges: String
}

input UserAuthorisationUpdateInputWhere {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: FindOperatorDto

  """User id of the user."""
  u_id: FindOperatorDto

  """Authentication id of the user."""
  au_id: FindOperatorDto

  """Authorisation role id of the user."""
  ar_id: FindOperatorDto

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: FindOperatorDto

  """Created datetime of the user auth."""
  created: FindOperatorDto

  """Updated datetime of the user auth."""
  updated: FindOperatorDto

  """Deleted datetime of the user auth."""
  deleted: FindOperatorDto

  """Authentication info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """Authorisation info of the user role."""
  fr_authorisation: [AuthorisationFindInputWhere!]

  """User info of the user."""
  fr_user: [UserFindInputWhere!]
}

type UserAuthorisationUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserAuthorisationEntity!]!
}

input UserAuthorisationUpsertInput {
  """User id of the user."""
  u_id: Int!

  """Authentication id of the user."""
  au_id: Int

  """Authorisation role id of the user."""
  ar_id: Int!

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: String

  """
  Privileges of the user. This is overwrite default authorisation permission and privileges this provide highly flexible integration
  """
  privileges: String

  """
  Unique ID of the entity, auto generated. This is is same with user id. Can be empty or provide id to update existing record.
  """
  id: Int
}

type UserAuthorisationUpsertOutput {
  """Unique ID of the entity, auto generated. This is is same with user id."""
  id: Int

  """User id of the user."""
  u_id: Int

  """Authentication id of the user."""
  au_id: Int

  """Authorisation role id of the user."""
  ar_id: Int

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  role_title: String

  """
  Role title of the user. Overwrite default authorisation role title. Custom name which makes it easy to identify.
  """
  privileges: String

  """Created datetime of the user auth."""
  created: DateTime

  """Updated datetime of the user auth."""
  updated: DateTime

  """Deleted datetime of the user auth."""
  deleted: DateTime

  """Authentication info of the user."""
  fr_user_auth: UserAuthenticationEntity

  """Authorisation info of the user role."""
  fr_authorisation: AuthorisationEntity

  """User info of the user."""
  fr_user: UserEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserCorporateInfoCreateInput {
  """User ID of the user corporate info."""
  u_id: Int!

  """Company name of the user corporate info."""
  company_name: String!

  """Contact person name of the user corporate info."""
  contact_person_name: String

  """Email of the user corporate info."""
  email: String!

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: String!

  """Mobile country code of the user corporate info."""
  mobile_cc: String!

  """Website of the user corporate info."""
  website: String

  """Company address of the user corporate info."""
  company_address: String

  """City ID of the user corporate info."""
  city_id: Int

  """State ID of the user corporate info."""
  state_id: Int

  """Country ID of the user corporate info."""
  country_id: Int

  """Date time when user corporate info is registered."""
  registered: DateTime
}

type UserCorporateInfoCreateOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """User ID of the user corporate info."""
  u_id: Int

  """Company name of the user corporate info."""
  company_name: String

  """Contact person name of the user corporate info."""
  contact_person_name: String

  """Email of the user corporate info."""
  email: EmailAddress

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: String

  """Mobile country code of the user corporate info."""
  mobile_cc: String

  """Website of the user corporate info."""
  website: String

  """Company address of the user corporate info."""
  company_address: String

  """City ID of the user corporate info."""
  city_id: Int

  """State ID of the user corporate info."""
  state_id: Int

  """Country ID of the user corporate info."""
  country_id: Int

  """Company logo of the user corporate info."""
  file_company_logo: String

  """User company logo url."""
  file_company_logo_url: UploadFileAccessUrlDto

  """Date time when user corporate info is registered."""
  registered: DateTime

  """Date time when user corporate info is created."""
  created: DateTime

  """Date time when user corporate info is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User ID of the user corporate info."""
  fr_user: UserEntity

  """City of the user identity card."""
  fr_city: CityEntity

  """State of the user identity card."""
  fr_state: StateEntity

  """Country of the user identity card."""
  fr_country: CountryEntity
}

input UserCorporateInfoDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserCorporateInfoDeleteInputWhere!]
}

input UserCorporateInfoDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user corporate info."""
  u_id: FindOperatorDto

  """Company name of the user corporate info."""
  company_name: FindOperatorDto

  """Contact person name of the user corporate info."""
  contact_person_name: FindOperatorDto

  """Email of the user corporate info."""
  email: FindOperatorDto

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: FindOperatorDto

  """Mobile country code of the user corporate info."""
  mobile_cc: FindOperatorDto

  """City ID of the user corporate info."""
  city_id: FindOperatorDto

  """State ID of the user corporate info."""
  state_id: FindOperatorDto

  """Country ID of the user corporate info."""
  country_id: FindOperatorDto

  """Date time when user corporate info is created."""
  created: FindOperatorDto

  """Date time when user corporate info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user corporate info."""
  fr_user: [UserFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]
}

type UserCorporateInfoDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserCorporateInfoEntity {
  """Unique ID of the entity, auto generated."""
  id: Int

  """User ID of the user corporate info."""
  u_id: Int

  """Company name of the user corporate info."""
  company_name: String

  """Contact person name of the user corporate info."""
  contact_person_name: String

  """Email of the user corporate info."""
  email: EmailAddress

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: String

  """Mobile country code of the user corporate info."""
  mobile_cc: String

  """Website of the user corporate info."""
  website: String

  """Company address of the user corporate info."""
  company_address: String

  """City ID of the user corporate info."""
  city_id: Int

  """State ID of the user corporate info."""
  state_id: Int

  """Country ID of the user corporate info."""
  country_id: Int

  """Company logo of the user corporate info."""
  file_company_logo: String

  """User company logo url."""
  file_company_logo_url: UploadFileAccessUrlDto

  """Date time when user corporate info is registered."""
  registered: DateTime

  """Date time when user corporate info is created."""
  created: DateTime

  """Date time when user corporate info is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User ID of the user corporate info."""
  fr_user: UserEntity

  """City of the user identity card."""
  fr_city: CityEntity

  """State of the user identity card."""
  fr_state: StateEntity

  """Country of the user identity card."""
  fr_country: CountryEntity
}

input UserCorporateInfoFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserCorporateInfoFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserCorporateInfoFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserCorporateInfoFindInputSortOrder
}

input UserCorporateInfoFindInputGroupBy {
  mobile_cc: Boolean
  city_id: Boolean
  state_id: Boolean
  country_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserCorporateInfoFindInputSortOrder {
  id: RecordSortDirectionEnum
  mobile_cc: RecordSortDirectionEnum

  """City ID of the user corporate info."""
  city_id: RecordSortDirectionEnum

  """State ID of the user corporate info."""
  state_id: RecordSortDirectionEnum

  """Country ID of the user corporate info."""
  country_id: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserCorporateInfoFindInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user corporate info."""
  u_id: FindOperatorDto

  """Company name of the user corporate info."""
  company_name: FindOperatorDto

  """Contact person name of the user corporate info."""
  contact_person_name: FindOperatorDto

  """Email of the user corporate info."""
  email: FindOperatorDto

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: FindOperatorDto

  """Mobile country code of the user corporate info."""
  mobile_cc: FindOperatorDto

  """City ID of the user corporate info."""
  city_id: FindOperatorDto

  """State ID of the user corporate info."""
  state_id: FindOperatorDto

  """Country ID of the user corporate info."""
  country_id: FindOperatorDto

  """Date time when user corporate info is created."""
  created: FindOperatorDto

  """Date time when user corporate info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user corporate info."""
  fr_user: [UserFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]
}

input UserCorporateInfoFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserCorporateInfoFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserCorporateInfoEntity!]!
}

input UserCorporateInfoRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserCorporateInfoRecoverInputWhere!]
}

input UserCorporateInfoRecoverInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user corporate info."""
  u_id: FindOperatorDto

  """Company name of the user corporate info."""
  company_name: FindOperatorDto

  """Contact person name of the user corporate info."""
  contact_person_name: FindOperatorDto

  """Email of the user corporate info."""
  email: FindOperatorDto

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: FindOperatorDto

  """Mobile country code of the user corporate info."""
  mobile_cc: FindOperatorDto

  """City ID of the user corporate info."""
  city_id: FindOperatorDto

  """State ID of the user corporate info."""
  state_id: FindOperatorDto

  """Country ID of the user corporate info."""
  country_id: FindOperatorDto

  """Date time when user corporate info is created."""
  created: FindOperatorDto

  """Date time when user corporate info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user corporate info."""
  fr_user: [UserFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]
}

type UserCorporateInfoRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserCorporateInfoEntity!]!
}

input UserCorporateInfoRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserCorporateInfoRemoveInputWhere!]
}

input UserCorporateInfoRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user corporate info."""
  u_id: FindOperatorDto

  """Company name of the user corporate info."""
  company_name: FindOperatorDto

  """Contact person name of the user corporate info."""
  contact_person_name: FindOperatorDto

  """Email of the user corporate info."""
  email: FindOperatorDto

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: FindOperatorDto

  """Mobile country code of the user corporate info."""
  mobile_cc: FindOperatorDto

  """City ID of the user corporate info."""
  city_id: FindOperatorDto

  """State ID of the user corporate info."""
  state_id: FindOperatorDto

  """Country ID of the user corporate info."""
  country_id: FindOperatorDto

  """Date time when user corporate info is created."""
  created: FindOperatorDto

  """Date time when user corporate info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user corporate info."""
  fr_user: [UserFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]
}

type UserCorporateInfoRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserCorporateInfoEntity!]!
}

input UserCorporateInfoRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserCorporateInfoRestoreInputWhere!]
}

input UserCorporateInfoRestoreInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user corporate info."""
  u_id: FindOperatorDto

  """Company name of the user corporate info."""
  company_name: FindOperatorDto

  """Contact person name of the user corporate info."""
  contact_person_name: FindOperatorDto

  """Email of the user corporate info."""
  email: FindOperatorDto

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: FindOperatorDto

  """Mobile country code of the user corporate info."""
  mobile_cc: FindOperatorDto

  """City ID of the user corporate info."""
  city_id: FindOperatorDto

  """State ID of the user corporate info."""
  state_id: FindOperatorDto

  """Country ID of the user corporate info."""
  country_id: FindOperatorDto

  """Date time when user corporate info is created."""
  created: FindOperatorDto

  """Date time when user corporate info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user corporate info."""
  fr_user: [UserFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]
}

type UserCorporateInfoRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserCorporateInfoSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserCorporateInfoSoftDeleteInputWhere!]
}

input UserCorporateInfoSoftDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user corporate info."""
  u_id: FindOperatorDto

  """Company name of the user corporate info."""
  company_name: FindOperatorDto

  """Contact person name of the user corporate info."""
  contact_person_name: FindOperatorDto

  """Email of the user corporate info."""
  email: FindOperatorDto

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: FindOperatorDto

  """Mobile country code of the user corporate info."""
  mobile_cc: FindOperatorDto

  """City ID of the user corporate info."""
  city_id: FindOperatorDto

  """State ID of the user corporate info."""
  state_id: FindOperatorDto

  """Country ID of the user corporate info."""
  country_id: FindOperatorDto

  """Date time when user corporate info is created."""
  created: FindOperatorDto

  """Date time when user corporate info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user corporate info."""
  fr_user: [UserFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]
}

type UserCorporateInfoSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserCorporateInfoSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserCorporateInfoSoftRemoveInputWhere!]
}

input UserCorporateInfoSoftRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user corporate info."""
  u_id: FindOperatorDto

  """Company name of the user corporate info."""
  company_name: FindOperatorDto

  """Contact person name of the user corporate info."""
  contact_person_name: FindOperatorDto

  """Email of the user corporate info."""
  email: FindOperatorDto

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: FindOperatorDto

  """Mobile country code of the user corporate info."""
  mobile_cc: FindOperatorDto

  """City ID of the user corporate info."""
  city_id: FindOperatorDto

  """State ID of the user corporate info."""
  state_id: FindOperatorDto

  """Country ID of the user corporate info."""
  country_id: FindOperatorDto

  """Date time when user corporate info is created."""
  created: FindOperatorDto

  """Date time when user corporate info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user corporate info."""
  fr_user: [UserFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]
}

type UserCorporateInfoSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserCorporateInfoEntity!]!
}

input UserCorporateInfoUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserCorporateInfoUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserCorporateInfoUpdateInputSets!
}

input UserCorporateInfoUpdateInputSets {
  """User ID of the user corporate info."""
  u_id: Int

  """Company name of the user corporate info."""
  company_name: String

  """Contact person name of the user corporate info."""
  contact_person_name: String

  """Email of the user corporate info."""
  email: String

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: String

  """Mobile country code of the user corporate info."""
  mobile_cc: String

  """Website of the user corporate info."""
  website: String

  """Company address of the user corporate info."""
  company_address: String

  """City ID of the user corporate info."""
  city_id: Int

  """State ID of the user corporate info."""
  state_id: Int

  """Country ID of the user corporate info."""
  country_id: Int

  """Date time when user corporate info is registered."""
  registered: DateTime
}

input UserCorporateInfoUpdateInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user corporate info."""
  u_id: FindOperatorDto

  """Company name of the user corporate info."""
  company_name: FindOperatorDto

  """Contact person name of the user corporate info."""
  contact_person_name: FindOperatorDto

  """Email of the user corporate info."""
  email: FindOperatorDto

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: FindOperatorDto

  """Mobile country code of the user corporate info."""
  mobile_cc: FindOperatorDto

  """City ID of the user corporate info."""
  city_id: FindOperatorDto

  """State ID of the user corporate info."""
  state_id: FindOperatorDto

  """Country ID of the user corporate info."""
  country_id: FindOperatorDto

  """Date time when user corporate info is created."""
  created: FindOperatorDto

  """Date time when user corporate info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user corporate info."""
  fr_user: [UserFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]
}

type UserCorporateInfoUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserCorporateInfoEntity!]!
}

input UserCorporateInfoUploadDeleteInput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserCorporateInfoUploadFileFieldEnum!

  """Please enter record reference id for uploaded file."""
  ref_id: String!

  """
  Please enter record id for uploaded file, this is optional but in some case when entity has single file upload and also has enternal relation id is must.
  """
  id: String

  """
  When file delete is performed and file is inside a folder of record id and during delete, if all files are deleted, means folder is empty, then also remove record id folder.
  """
  rmdir_record: Boolean! = false
}

type UserCorporateInfoUploadDeleteOutput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserCorporateInfoUploadFileFieldEnum

  """Record reference id for uploaded file."""
  ref_id: String

  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  File id used to perform delete, this is a record id where file is saved.
  """
  id: String
}

"""UserCorporateInfo upload ref type enum"""
enum UserCorporateInfoUploadFileFieldEnum {
  """
  User company logo upload  file. Only jpeg, jpg, png, svg files are allowed. Maximum file size is 5 MB. Only one file is allowed to upload.
  """
  FILE_COMPANY_LOGO
}

input UserCorporateInfoUploadInput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserCorporateInfoUploadFileFieldEnum!

  """Please enter record reference id for uploaded file."""
  ref_id: String!

  """
  Please enter record id for uploaded file, this is optional but in some case when entity has single file upload and also has enternal relation id is must.
  """
  id: String
}

type UserCorporateInfoUploadOutput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserCorporateInfoUploadFileFieldEnum

  """File id on sucessfull upload, this database record id holds this file."""
  id: String

  """Record reference id for uploaded file."""
  ref_id: String

  """Uploaded file name."""
  file_name: String

  """Uploaded file access url over web."""
  access_url: UploadFileAccessUrlDto
}

input UserCorporateInfoUpsertInput {
  """User ID of the user corporate info."""
  u_id: Int!

  """Company name of the user corporate info."""
  company_name: String!

  """Contact person name of the user corporate info."""
  contact_person_name: String

  """Email of the user corporate info."""
  email: String!

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: String!

  """Mobile country code of the user corporate info."""
  mobile_cc: String!

  """Website of the user corporate info."""
  website: String

  """Company address of the user corporate info."""
  company_address: String

  """City ID of the user corporate info."""
  city_id: Int

  """State ID of the user corporate info."""
  state_id: Int

  """Country ID of the user corporate info."""
  country_id: Int

  """Date time when user corporate info is registered."""
  registered: DateTime

  """Unique ID of the entity, auto generated. undefined"""
  id: Int
}

type UserCorporateInfoUpsertOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """User ID of the user corporate info."""
  u_id: Int

  """Company name of the user corporate info."""
  company_name: String

  """Contact person name of the user corporate info."""
  contact_person_name: String

  """Email of the user corporate info."""
  email: EmailAddress

  """Mobile of the user corporate info. Provide in USA mobile format."""
  mobile: String

  """Mobile country code of the user corporate info."""
  mobile_cc: String

  """Website of the user corporate info."""
  website: String

  """Company address of the user corporate info."""
  company_address: String

  """City ID of the user corporate info."""
  city_id: Int

  """State ID of the user corporate info."""
  state_id: Int

  """Country ID of the user corporate info."""
  country_id: Int

  """Company logo of the user corporate info."""
  file_company_logo: String

  """User company logo url."""
  file_company_logo_url: UploadFileAccessUrlDto

  """Date time when user corporate info is registered."""
  registered: DateTime

  """Date time when user corporate info is created."""
  created: DateTime

  """Date time when user corporate info is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User ID of the user corporate info."""
  fr_user: UserEntity

  """City of the user identity card."""
  fr_city: CityEntity

  """State of the user identity card."""
  fr_state: StateEntity

  """Country of the user identity card."""
  fr_country: CountryEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserCreateInput {
  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: String

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: String

  """Connection source ID."""
  connsrc_id: Int

  """First name of the user."""
  fname: String

  """Last name of the user."""
  lname: String

  """Middle name of the user."""
  mname: String

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: String

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: String

  """Primary mobile country code of the user."""
  primary_mobile_cc: String

  """Used to reset password."""
  recovery_email: String

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: String

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: String

  """Provide whatsapp of the user."""
  whatsapp: String

  """Whatsapp country code of the user."""
  whatsapp_cc: String

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: YesNoEnum!
}

type UserCreateOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: String

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: String

  """Connection source ID."""
  connsrc_id: Int

  """First name of the user."""
  fname: String

  """Last name of the user."""
  lname: String

  """Middle name of the user."""
  mname: String

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: String

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: String

  """Primary mobile country code of the user."""
  primary_mobile_cc: String

  """Used to reset password."""
  recovery_email: EmailAddress

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: String

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: String

  """Provide whatsapp of the user."""
  whatsapp: String

  """Whatsapp country code of the user."""
  whatsapp_cc: String

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: YesNoEnum

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: DateTime

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: DateTime

  """
  Flag to indicate if user is verified. When record is verified, date-time will be saved otherwise null to indicate not verified.
  """
  verified: DateTime

  """
  Flag to indicate if user is suspended. When record is suspended, date-time will be saved otherwise null to indicate record is active.
  """
  suspended: DateTime

  """Date time when user is created."""
  created: DateTime

  """Date time when user is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User profile photo."""
  file_profile_photo: String

  """User profile photo url."""
  file_profile_photo_url: UploadFileAccessUrlDto

  """User profile banner."""
  file_profile_banner: String

  """User profile banner url."""
  file_profile_banner_url: UploadFileAccessUrlDto

  """User auth info of the user."""
  fr_user_auth: UserAuthenticationEntity

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceEntity!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """User personal info of the user."""
  fr_user_personal_info: UserPersonalInfoEntity

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """User address of the user."""
  fr_user_addresses: [UserAddressEntity!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyEntity!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User files."""
  fr_user_files: [UserFileEntity!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsEntity!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsEntity!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappEntity!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappEntity!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailEntity!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailEntity!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailEntity!]

  """Lead users."""
  fr_lead_from_users: [LeadEntity!]

  """Lead users."""
  fr_lead_to_users: [LeadEntity!]

  """News letter of this userr."""
  fr_newsletter_users: NewsLetterEntity

  """News letter schedule for this User."""
  fr_newsletter_schedule_users: NewsLetterScheduleEntity

  """Lead followup for this user."""
  fr_lead_followup_user: LeadFollowupEntity

  """Newsletter user for this user."""
  fr_news_letter_user_user: NewsLetterUserEntity

  """Newsletter subscription user for this user."""
  fr_user_newsletters_subscription: UserNewsLetterSubscriptionEntity

  """User favourites for this user."""
  fr_user_favourites: UserFavEntity

  """Buissness user."""
  fr_business_user: BusinessEntity

  """connection source for this user."""
  fr_connection_source: ConnectionSourceEntity
}

input UserDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserDeleteInputWhere!]
}

input UserDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: FindOperatorDto

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: FindOperatorDto

  """Connection source ID."""
  connsrc_id: FindOperatorDto

  """First name of the user."""
  fname: FindOperatorDto

  """Last name of the user."""
  lname: FindOperatorDto

  """Middle name of the user."""
  mname: FindOperatorDto

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: FindOperatorDto

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: FindOperatorDto

  """Primary mobile country code of the user."""
  primary_mobile_cc: FindOperatorDto

  """Used to reset password."""
  recovery_email: FindOperatorDto

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: FindOperatorDto

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: FindOperatorDto

  """Provide whatsapp of the user."""
  whatsapp: FindOperatorDto

  """Whatsapp country code of the user."""
  whatsapp_cc: FindOperatorDto

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: FindOperatorDto

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: FindOperatorDto

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: FindOperatorDto

  """Date time when user is created."""
  created: FindOperatorDto

  """Date time when user is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User auth info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceFindInputWhere!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """User personal info of the user."""
  fr_user_personal_info: [UserPersonalInfoFindInputWhere!]

  """User address of the user."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyFindInputWhere!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User files."""
  fr_user_files: [UserFileFindInputWhere!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsFindInputWhere!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsFindInputWhere!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappFindInputWhere!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappFindInputWhere!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailFindInputWhere!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailFindInputWhere!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailFindInputWhere!]

  """connection source for this user."""
  fr_connection_source: [ConnectionSourceFindInputWhere!]
}

type UserDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserDeviceCreateInput {
  """User ID."""
  u_id: Int!

  """Device ID of the user."""
  device_id: Int!

  """Device Token of the entity."""
  device_token: String!

  """Device User Agent String of the entity."""
  device_user_agent: String!

  """From IP Address of the entity."""
  from_ip_address: IP!

  """Device MAC Address of the entity."""
  device_mac_address: MAC

  """Device System ID of the entity."""
  device_system_id: String

  """Device Name of the entity."""
  device_name: String
}

type UserDeviceCreateOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """User ID."""
  u_id: Int

  """Device ID of the user."""
  device_id: Int

  """Device Token of the entity."""
  device_token: String

  """Device User Agent String of the entity."""
  device_user_agent: String

  """From IP Address of the entity."""
  from_ip_address: IP

  """Device MAC Address of the entity."""
  device_mac_address: MAC

  """Device System ID of the entity."""
  device_system_id: String

  """Device Name of the entity."""
  device_name: String

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Device entity for user device"""
  fr_device: DeviceEntity

  """User entity for device"""
  fr_user: UserEntity
}

input UserDeviceDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserDeviceDeleteInputWhere!]
}

input UserDeviceDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID."""
  u_id: FindOperatorDto

  """Device ID of the user."""
  device_id: FindOperatorDto

  """Device Token of the entity."""
  device_token: FindOperatorDto

  """From IP Address of the entity."""
  from_ip_address: FindOperatorDto

  """Device MAC Address of the entity."""
  device_mac_address: FindOperatorDto

  """Device System ID of the entity."""
  device_system_id: FindOperatorDto

  """Device Name of the entity."""
  device_name: FindOperatorDto

  """Device User Agent String of the entity."""
  device_user_agent: FindOperatorDto

  """Suspended status of the entity."""
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Device entity for user device"""
  fr_device: [DeviceFindInputWhere!]

  """User entity for device"""
  fr_user: [UserFindInputWhere!]
}

type UserDeviceDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserDeviceEntity {
  """Unique ID of the entity, auto generated."""
  id: Int

  """User ID."""
  u_id: Int

  """Device ID of the user."""
  device_id: Int

  """Device Token of the entity."""
  device_token: String

  """Device User Agent String of the entity."""
  device_user_agent: String

  """From IP Address of the entity."""
  from_ip_address: IP

  """Device MAC Address of the entity."""
  device_mac_address: MAC

  """Device System ID of the entity."""
  device_system_id: String

  """Device Name of the entity."""
  device_name: String

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Device entity for user device"""
  fr_device: DeviceEntity

  """User entity for device"""
  fr_user: UserEntity
}

input UserDeviceFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserDeviceFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserDeviceFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserDeviceFindInputSortOrder
}

input UserDeviceFindInputGroupBy {
  u_id: Boolean
  device_id: Boolean
  from_ip_address: Boolean
  device_mac_address: Boolean
  device_system_id: Boolean
  device_name: Boolean
  device_user_agent: Boolean
  suspended: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserDeviceFindInputSortOrder {
  id: RecordSortDirectionEnum
  u_id: RecordSortDirectionEnum
  device_id: RecordSortDirectionEnum
  device_token: RecordSortDirectionEnum
  from_ip_address: RecordSortDirectionEnum
  device_mac_address: RecordSortDirectionEnum
  device_system_id: RecordSortDirectionEnum
  device_name: RecordSortDirectionEnum
  device_user_agent: RecordSortDirectionEnum
  suspended: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserDeviceFindInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID."""
  u_id: FindOperatorDto

  """Device ID of the user."""
  device_id: FindOperatorDto

  """Device Token of the entity."""
  device_token: FindOperatorDto

  """From IP Address of the entity."""
  from_ip_address: FindOperatorDto

  """Device MAC Address of the entity."""
  device_mac_address: FindOperatorDto

  """Device System ID of the entity."""
  device_system_id: FindOperatorDto

  """Device Name of the entity."""
  device_name: FindOperatorDto

  """Device User Agent String of the entity."""
  device_user_agent: FindOperatorDto

  """Suspended status of the entity."""
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Device entity for user device"""
  fr_device: [DeviceFindInputWhere!]

  """User entity for device"""
  fr_user: [UserFindInputWhere!]
}

input UserDeviceFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserDeviceFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserDeviceEntity!]!
}

input UserDeviceRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserDeviceRecoverInputWhere!]
}

input UserDeviceRecoverInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID."""
  u_id: FindOperatorDto

  """Device ID of the user."""
  device_id: FindOperatorDto

  """Device Token of the entity."""
  device_token: FindOperatorDto

  """From IP Address of the entity."""
  from_ip_address: FindOperatorDto

  """Device MAC Address of the entity."""
  device_mac_address: FindOperatorDto

  """Device System ID of the entity."""
  device_system_id: FindOperatorDto

  """Device Name of the entity."""
  device_name: FindOperatorDto

  """Device User Agent String of the entity."""
  device_user_agent: FindOperatorDto

  """Suspended status of the entity."""
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Device entity for user device"""
  fr_device: [DeviceFindInputWhere!]

  """User entity for device"""
  fr_user: [UserFindInputWhere!]
}

type UserDeviceRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserDeviceEntity!]!
}

input UserDeviceRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserDeviceRemoveInputWhere!]
}

input UserDeviceRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID."""
  u_id: FindOperatorDto

  """Device ID of the user."""
  device_id: FindOperatorDto

  """Device Token of the entity."""
  device_token: FindOperatorDto

  """From IP Address of the entity."""
  from_ip_address: FindOperatorDto

  """Device MAC Address of the entity."""
  device_mac_address: FindOperatorDto

  """Device System ID of the entity."""
  device_system_id: FindOperatorDto

  """Device Name of the entity."""
  device_name: FindOperatorDto

  """Device User Agent String of the entity."""
  device_user_agent: FindOperatorDto

  """Suspended status of the entity."""
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Device entity for user device"""
  fr_device: [DeviceFindInputWhere!]

  """User entity for device"""
  fr_user: [UserFindInputWhere!]
}

type UserDeviceRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserDeviceEntity!]!
}

input UserDeviceRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserDeviceRestoreInputWhere!]
}

input UserDeviceRestoreInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID."""
  u_id: FindOperatorDto

  """Device ID of the user."""
  device_id: FindOperatorDto

  """Device Token of the entity."""
  device_token: FindOperatorDto

  """From IP Address of the entity."""
  from_ip_address: FindOperatorDto

  """Device MAC Address of the entity."""
  device_mac_address: FindOperatorDto

  """Device System ID of the entity."""
  device_system_id: FindOperatorDto

  """Device Name of the entity."""
  device_name: FindOperatorDto

  """Device User Agent String of the entity."""
  device_user_agent: FindOperatorDto

  """Suspended status of the entity."""
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Device entity for user device"""
  fr_device: [DeviceFindInputWhere!]

  """User entity for device"""
  fr_user: [UserFindInputWhere!]
}

type UserDeviceRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserDeviceSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserDeviceSoftDeleteInputWhere!]
}

input UserDeviceSoftDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID."""
  u_id: FindOperatorDto

  """Device ID of the user."""
  device_id: FindOperatorDto

  """Device Token of the entity."""
  device_token: FindOperatorDto

  """From IP Address of the entity."""
  from_ip_address: FindOperatorDto

  """Device MAC Address of the entity."""
  device_mac_address: FindOperatorDto

  """Device System ID of the entity."""
  device_system_id: FindOperatorDto

  """Device Name of the entity."""
  device_name: FindOperatorDto

  """Device User Agent String of the entity."""
  device_user_agent: FindOperatorDto

  """Suspended status of the entity."""
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Device entity for user device"""
  fr_device: [DeviceFindInputWhere!]

  """User entity for device"""
  fr_user: [UserFindInputWhere!]
}

type UserDeviceSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserDeviceSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserDeviceSoftRemoveInputWhere!]
}

input UserDeviceSoftRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID."""
  u_id: FindOperatorDto

  """Device ID of the user."""
  device_id: FindOperatorDto

  """Device Token of the entity."""
  device_token: FindOperatorDto

  """From IP Address of the entity."""
  from_ip_address: FindOperatorDto

  """Device MAC Address of the entity."""
  device_mac_address: FindOperatorDto

  """Device System ID of the entity."""
  device_system_id: FindOperatorDto

  """Device Name of the entity."""
  device_name: FindOperatorDto

  """Device User Agent String of the entity."""
  device_user_agent: FindOperatorDto

  """Suspended status of the entity."""
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Device entity for user device"""
  fr_device: [DeviceFindInputWhere!]

  """User entity for device"""
  fr_user: [UserFindInputWhere!]
}

type UserDeviceSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserDeviceEntity!]!
}

input UserDeviceUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserDeviceUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserDeviceUpdateInputSets!
}

input UserDeviceUpdateInputSets {
  """User ID."""
  u_id: Int

  """Device ID of the user."""
  device_id: Int

  """Device Token of the entity."""
  device_token: String

  """Device User Agent String of the entity."""
  device_user_agent: String

  """From IP Address of the entity."""
  from_ip_address: IP

  """Device MAC Address of the entity."""
  device_mac_address: MAC

  """Device System ID of the entity."""
  device_system_id: String

  """Device Name of the entity."""
  device_name: String
}

input UserDeviceUpdateInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID."""
  u_id: FindOperatorDto

  """Device ID of the user."""
  device_id: FindOperatorDto

  """Device Token of the entity."""
  device_token: FindOperatorDto

  """From IP Address of the entity."""
  from_ip_address: FindOperatorDto

  """Device MAC Address of the entity."""
  device_mac_address: FindOperatorDto

  """Device System ID of the entity."""
  device_system_id: FindOperatorDto

  """Device Name of the entity."""
  device_name: FindOperatorDto

  """Device User Agent String of the entity."""
  device_user_agent: FindOperatorDto

  """Suspended status of the entity."""
  suspended: FindOperatorDto

  """Record created date time."""
  created: FindOperatorDto

  """Record last updated date time. Update can be any."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Device entity for user device"""
  fr_device: [DeviceFindInputWhere!]

  """User entity for device"""
  fr_user: [UserFindInputWhere!]
}

type UserDeviceUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserDeviceEntity!]!
}

input UserDeviceUpsertInput {
  """User ID."""
  u_id: Int!

  """Device ID of the user."""
  device_id: Int!

  """Device Token of the entity."""
  device_token: String!

  """Device User Agent String of the entity."""
  device_user_agent: String!

  """From IP Address of the entity."""
  from_ip_address: IP!

  """Device MAC Address of the entity."""
  device_mac_address: MAC

  """Device System ID of the entity."""
  device_system_id: String

  """Device Name of the entity."""
  device_name: String

  """Unique ID of the entity, auto generated. undefined"""
  id: Int
}

type UserDeviceUpsertOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """User ID."""
  u_id: Int

  """Device ID of the user."""
  device_id: Int

  """Device Token of the entity."""
  device_token: String

  """Device User Agent String of the entity."""
  device_user_agent: String

  """From IP Address of the entity."""
  from_ip_address: IP

  """Device MAC Address of the entity."""
  device_mac_address: MAC

  """Device System ID of the entity."""
  device_system_id: String

  """Device Name of the entity."""
  device_name: String

  """Record created date time."""
  created: DateTime

  """Record last updated date time. Update can be any."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Device entity for user device"""
  fr_device: DeviceEntity

  """User entity for device"""
  fr_user: UserEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

type UserEntity {
  """Unique ID of the entity, auto generated."""
  id: Int
  fr_user_favs: [UserFavouritePropertyEntity!]
  fr_created_user_favs: [UserFavouritePropertyEntity!]
  fr_user_search: [UserSavedSearchEntity!]
  fr_created_user_search: [UserSavedSearchEntity!]

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: String

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: String

  """Connection source ID."""
  connsrc_id: Int

  """First name of the user."""
  fname: String

  """Last name of the user."""
  lname: String

  """Middle name of the user."""
  mname: String

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: String

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: String

  """Primary mobile country code of the user."""
  primary_mobile_cc: String

  """Used to reset password."""
  recovery_email: EmailAddress

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: String

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: String

  """Provide whatsapp of the user."""
  whatsapp: String

  """Whatsapp country code of the user."""
  whatsapp_cc: String

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: YesNoEnum

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: DateTime

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: DateTime

  """
  Flag to indicate if user is verified. When record is verified, date-time will be saved otherwise null to indicate not verified.
  """
  verified: DateTime

  """
  Flag to indicate if user is suspended. When record is suspended, date-time will be saved otherwise null to indicate record is active.
  """
  suspended: DateTime

  """Date time when user is created."""
  created: DateTime

  """Date time when user is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User profile photo."""
  file_profile_photo: String

  """User profile photo url."""
  file_profile_photo_url: UploadFileAccessUrlDto

  """User profile banner."""
  file_profile_banner: String

  """User profile banner url."""
  file_profile_banner_url: UploadFileAccessUrlDto

  """User auth info of the user."""
  fr_user_auth: UserAuthenticationEntity

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceEntity!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """User personal info of the user."""
  fr_user_personal_info: UserPersonalInfoEntity

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """User address of the user."""
  fr_user_addresses: [UserAddressEntity!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyEntity!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User files."""
  fr_user_files: [UserFileEntity!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsEntity!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsEntity!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappEntity!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappEntity!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailEntity!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailEntity!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailEntity!]

  """Lead users."""
  fr_lead_from_users: [LeadEntity!]

  """Lead users."""
  fr_lead_to_users: [LeadEntity!]

  """News letter of this userr."""
  fr_newsletter_users: NewsLetterEntity

  """News letter schedule for this User."""
  fr_newsletter_schedule_users: NewsLetterScheduleEntity

  """Lead followup for this user."""
  fr_lead_followup_user: LeadFollowupEntity

  """Newsletter user for this user."""
  fr_news_letter_user_user: NewsLetterUserEntity

  """Newsletter subscription user for this user."""
  fr_user_newsletters_subscription: UserNewsLetterSubscriptionEntity

  """User favourites for this user."""
  fr_user_favourites: UserFavEntity

  """Buissness user."""
  fr_business_user: BusinessEntity

  """connection source for this user."""
  fr_connection_source: ConnectionSourceEntity
}

input UserFavCategoryCreateInput {
  """Title of the faq category."""
  title: String!

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime
}

type UserFavCategoryCreateOutput {
  """Unique ID of the faq category, auto generated."""
  id: Int

  """Title of the faq category."""
  title: String

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Favourite category."""
  fr_user_favourite: [UserFavEntity!]
}

input UserFavCategoryDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavCategoryDeleteInputWhere!]
}

input UserFavCategoryDeleteInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite category."""
  fr_user_favourite: [UserFavFindInputWhere!]
}

type UserFavCategoryDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserFavCategoryEntity {
  """Unique ID of the faq category, auto generated."""
  id: Int

  """Title of the faq category."""
  title: String

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Favourite category."""
  fr_user_favourite: [UserFavEntity!]
}

input UserFavCategoryFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavCategoryFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserFavCategoryFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserFavCategoryFindInputSortOrder
}

input UserFavCategoryFindInputGroupBy {
  title: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserFavCategoryFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserFavCategoryFindInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite category."""
  fr_user_favourite: [UserFavFindInputWhere!]
}

input UserFavCategoryFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserFavCategoryFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserFavCategoryEntity!]!
}

input UserFavCategoryRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavCategoryRecoverInputWhere!]
}

input UserFavCategoryRecoverInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite category."""
  fr_user_favourite: [UserFavFindInputWhere!]
}

type UserFavCategoryRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserFavCategoryEntity!]!
}

input UserFavCategoryRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavCategoryRemoveInputWhere!]
}

input UserFavCategoryRemoveInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite category."""
  fr_user_favourite: [UserFavFindInputWhere!]
}

type UserFavCategoryRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserFavCategoryEntity!]!
}

input UserFavCategoryRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavCategoryRestoreInputWhere!]
}

input UserFavCategoryRestoreInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite category."""
  fr_user_favourite: [UserFavFindInputWhere!]
}

type UserFavCategoryRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserFavCategorySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavCategorySoftDeleteInputWhere!]
}

input UserFavCategorySoftDeleteInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite category."""
  fr_user_favourite: [UserFavFindInputWhere!]
}

type UserFavCategorySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserFavCategorySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavCategorySoftRemoveInputWhere!]
}

input UserFavCategorySoftRemoveInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite category."""
  fr_user_favourite: [UserFavFindInputWhere!]
}

type UserFavCategorySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserFavCategoryEntity!]!
}

input UserFavCategoryUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavCategoryUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserFavCategoryUpdateInputSets!
}

input UserFavCategoryUpdateInputSets {
  """Title of the faq category."""
  title: String

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime
}

input UserFavCategoryUpdateInputWhere {
  """Unique ID of the faq category, auto generated."""
  id: FindOperatorDto

  """Title of the faq category."""
  title: FindOperatorDto

  """Active of the faq category."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite category."""
  fr_user_favourite: [UserFavFindInputWhere!]
}

type UserFavCategoryUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserFavCategoryEntity!]!
}

input UserFavCategoryUpsertInput {
  """Title of the faq category."""
  title: String!

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime

  """Unique ID of the faq category, auto generated. undefined"""
  id: Int
}

type UserFavCategoryUpsertOutput {
  """Unique ID of the faq category, auto generated."""
  id: Int

  """Title of the faq category."""
  title: String

  """Description of the faq category."""
  desc: String

  """Active of the faq category."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Favourite category."""
  fr_user_favourite: [UserFavEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserFavCreateInput {
  """Favourite category Id of the user favourite."""
  favcat_id: Int!

  """Reference Id of the user favourite."""
  ref_id: String!

  """Notes of the user favourite."""
  notes: String!
}

type UserFavCreateOutput {
  """Unique ID of the user favourite, auto generated."""
  id: Int

  """Favourite category Id of the user favourite."""
  favcat_id: Int

  """Reference Id of the user favourite."""
  ref_id: String

  """Notes of the user favourite."""
  notes: String

  """User Id of the user favourite added by."""
  created_u_id: Int

  """User authorization Id of the user."""
  created_ar_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Favourite categories of the user."""
  fr_user_fav_categories: UserFavCategoryEntity

  """User id of the queueemail added by"""
  fr_created_user: UserEntity

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: AuthorisationEntity
}

input UserFavDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavDeleteInputWhere!]
}

input UserFavDeleteInputWhere {
  """Unique ID of the user favourite, auto generated."""
  id: FindOperatorDto

  """Favourite category Id of the user favourite."""
  favcat_id: FindOperatorDto

  """User Id of the user favourite added by."""
  created_u_id: FindOperatorDto

  """User authorization Id of the user."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite categories of the user."""
  fr_user_fav_categories: [UserFavCategoryFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type UserFavDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserFavEntity {
  """Unique ID of the user favourite, auto generated."""
  id: Int

  """Favourite category Id of the user favourite."""
  favcat_id: Int

  """Reference Id of the user favourite."""
  ref_id: String

  """Notes of the user favourite."""
  notes: String

  """User Id of the user favourite added by."""
  created_u_id: Int

  """User authorization Id of the user."""
  created_ar_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Favourite categories of the user."""
  fr_user_fav_categories: UserFavCategoryEntity

  """User id of the queueemail added by"""
  fr_created_user: UserEntity

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: AuthorisationEntity
}

input UserFavFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserFavFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserFavFindInputSortOrder
}

input UserFavFindInputGroupBy {
  favcat_id: Boolean
  created_u_id: Boolean
  created_ar_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserFavFindInputSortOrder {
  id: RecordSortDirectionEnum
  favcat_id: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  created_u_id: RecordSortDirectionEnum
  created_ar_id: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserFavFindInputWhere {
  """Unique ID of the user favourite, auto generated."""
  id: FindOperatorDto

  """Favourite category Id of the user favourite."""
  favcat_id: FindOperatorDto

  """User Id of the user favourite added by."""
  created_u_id: FindOperatorDto

  """User authorization Id of the user."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite categories of the user."""
  fr_user_fav_categories: [UserFavCategoryFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

input UserFavFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserFavFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserFavEntity!]!
}

input UserFavouritePropertyCreateInput {
  """User Id of the user favourite property."""
  u_id: Int!

  """MLSP ID of the user favourite property."""
  mlsp_id: Int!

  """MLS NUM of the user favourite property."""
  rl_mls_num: String!

  """Notes"""
  notes: String

  """Created User ID of the user favourite property."""
  created_u_id: Int

  """Created AR ID of the user favourite property."""
  created_ar_id: Int
}

type UserFavouritePropertyCreateOutput {
  """Unique ID of the user favourite property, auto generated."""
  id: Int

  """User Id of the user favourite property."""
  u_id: Int

  """MLSP ID of the user favourite property."""
  mlsp_id: Int

  """MLS NUM of the user favourite property."""
  rl_mls_num: String

  """Notes"""
  notes: String

  """Created User ID of the user favourite property."""
  created_u_id: Int

  """Created AR ID of the user favourite property."""
  created_ar_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: RetsMlsProviderEntity

  """Users of the user favourite property."""
  fr_users: UserEntity

  """Created user of the user favourite property."""
  fr_created_user: UserEntity
}

input UserFavouritePropertyDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavouritePropertyDeleteInputWhere!]
}

input UserFavouritePropertyDeleteInputWhere {
  """Unique ID of the user favourite property, auto generated."""
  id: FindOperatorDto

  """User Id of the user favourite property."""
  u_id: FindOperatorDto

  """MLSP ID of the user favourite property."""
  mlsp_id: FindOperatorDto

  """MLS NUM of the user favourite property."""
  rl_mls_num: FindOperatorDto

  """Created User ID of the user favourite property."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user favourite property."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type UserFavouritePropertyDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserFavouritePropertyEntity {
  """Unique ID of the user favourite property, auto generated."""
  id: Int

  """User Id of the user favourite property."""
  u_id: Int

  """MLSP ID of the user favourite property."""
  mlsp_id: Int

  """MLS NUM of the user favourite property."""
  rl_mls_num: String

  """Notes"""
  notes: String

  """Created User ID of the user favourite property."""
  created_u_id: Int

  """Created AR ID of the user favourite property."""
  created_ar_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: RetsMlsProviderEntity

  """Users of the user favourite property."""
  fr_users: UserEntity

  """Created user of the user favourite property."""
  fr_created_user: UserEntity
}

input UserFavouritePropertyFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavouritePropertyFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserFavouritePropertyFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserFavouritePropertyFindInputSortOrder
}

input UserFavouritePropertyFindInputGroupBy {
  u_id: Boolean
  mlsp_id: Boolean
  rl_mls_num: Boolean
  notes: Boolean
  created_u_id: Boolean
  created_ar_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserFavouritePropertyFindInputSortOrder {
  id: RecordSortDirectionEnum
  u_id: RecordSortDirectionEnum
  mlsp_id: RecordSortDirectionEnum
  rl_mls_num: RecordSortDirectionEnum
  created_u_id: RecordSortDirectionEnum
  created_ar_id: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserFavouritePropertyFindInputWhere {
  """Unique ID of the user favourite property, auto generated."""
  id: FindOperatorDto

  """User Id of the user favourite property."""
  u_id: FindOperatorDto

  """MLSP ID of the user favourite property."""
  mlsp_id: FindOperatorDto

  """MLS NUM of the user favourite property."""
  rl_mls_num: FindOperatorDto

  """Created User ID of the user favourite property."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user favourite property."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

input UserFavouritePropertyFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserFavouritePropertyFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserFavouritePropertyEntity!]!
}

input UserFavouritePropertyRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavouritePropertyRecoverInputWhere!]
}

input UserFavouritePropertyRecoverInputWhere {
  """Unique ID of the user favourite property, auto generated."""
  id: FindOperatorDto

  """User Id of the user favourite property."""
  u_id: FindOperatorDto

  """MLSP ID of the user favourite property."""
  mlsp_id: FindOperatorDto

  """MLS NUM of the user favourite property."""
  rl_mls_num: FindOperatorDto

  """Created User ID of the user favourite property."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user favourite property."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type UserFavouritePropertyRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserFavouritePropertyEntity!]!
}

input UserFavouritePropertyRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavouritePropertyRemoveInputWhere!]
}

input UserFavouritePropertyRemoveInputWhere {
  """Unique ID of the user favourite property, auto generated."""
  id: FindOperatorDto

  """User Id of the user favourite property."""
  u_id: FindOperatorDto

  """MLSP ID of the user favourite property."""
  mlsp_id: FindOperatorDto

  """MLS NUM of the user favourite property."""
  rl_mls_num: FindOperatorDto

  """Created User ID of the user favourite property."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user favourite property."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type UserFavouritePropertyRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserFavouritePropertyEntity!]!
}

input UserFavouritePropertyRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavouritePropertyRestoreInputWhere!]
}

input UserFavouritePropertyRestoreInputWhere {
  """Unique ID of the user favourite property, auto generated."""
  id: FindOperatorDto

  """User Id of the user favourite property."""
  u_id: FindOperatorDto

  """MLSP ID of the user favourite property."""
  mlsp_id: FindOperatorDto

  """MLS NUM of the user favourite property."""
  rl_mls_num: FindOperatorDto

  """Created User ID of the user favourite property."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user favourite property."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type UserFavouritePropertyRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserFavouritePropertySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavouritePropertySoftDeleteInputWhere!]
}

input UserFavouritePropertySoftDeleteInputWhere {
  """Unique ID of the user favourite property, auto generated."""
  id: FindOperatorDto

  """User Id of the user favourite property."""
  u_id: FindOperatorDto

  """MLSP ID of the user favourite property."""
  mlsp_id: FindOperatorDto

  """MLS NUM of the user favourite property."""
  rl_mls_num: FindOperatorDto

  """Created User ID of the user favourite property."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user favourite property."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type UserFavouritePropertySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserFavouritePropertySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavouritePropertySoftRemoveInputWhere!]
}

input UserFavouritePropertySoftRemoveInputWhere {
  """Unique ID of the user favourite property, auto generated."""
  id: FindOperatorDto

  """User Id of the user favourite property."""
  u_id: FindOperatorDto

  """MLSP ID of the user favourite property."""
  mlsp_id: FindOperatorDto

  """MLS NUM of the user favourite property."""
  rl_mls_num: FindOperatorDto

  """Created User ID of the user favourite property."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user favourite property."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type UserFavouritePropertySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserFavouritePropertyEntity!]!
}

input UserFavouritePropertyUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavouritePropertyUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserFavouritePropertyUpdateInputSets!
}

input UserFavouritePropertyUpdateInputSets {
  """User Id of the user favourite property."""
  u_id: Int

  """MLSP ID of the user favourite property."""
  mlsp_id: Int

  """MLS NUM of the user favourite property."""
  rl_mls_num: String

  """Notes"""
  notes: String

  """Created User ID of the user favourite property."""
  created_u_id: Int

  """Created AR ID of the user favourite property."""
  created_ar_id: Int
}

input UserFavouritePropertyUpdateInputWhere {
  """Unique ID of the user favourite property, auto generated."""
  id: FindOperatorDto

  """User Id of the user favourite property."""
  u_id: FindOperatorDto

  """MLSP ID of the user favourite property."""
  mlsp_id: FindOperatorDto

  """MLS NUM of the user favourite property."""
  rl_mls_num: FindOperatorDto

  """Created User ID of the user favourite property."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user favourite property."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: [RetsMlsProviderFindInputWhere!]
}

type UserFavouritePropertyUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserFavouritePropertyEntity!]!
}

input UserFavouritePropertyUpsertInput {
  """User Id of the user favourite property."""
  u_id: Int!

  """MLSP ID of the user favourite property."""
  mlsp_id: Int!

  """MLS NUM of the user favourite property."""
  rl_mls_num: String!

  """Notes"""
  notes: String

  """Created User ID of the user favourite property."""
  created_u_id: Int

  """Created AR ID of the user favourite property."""
  created_ar_id: Int

  """Unique ID of the user favourite property, auto generated. undefined"""
  id: Int
}

type UserFavouritePropertyUpsertOutput {
  """Unique ID of the user favourite property, auto generated."""
  id: Int

  """User Id of the user favourite property."""
  u_id: Int

  """MLSP ID of the user favourite property."""
  mlsp_id: Int

  """MLS NUM of the user favourite property."""
  rl_mls_num: String

  """Notes"""
  notes: String

  """Created User ID of the user favourite property."""
  created_u_id: Int

  """Created AR ID of the user favourite property."""
  created_ar_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """MLSP ID of the user favourite property."""
  fr_mlsp_id: RetsMlsProviderEntity

  """Users of the user favourite property."""
  fr_users: UserEntity

  """Created user of the user favourite property."""
  fr_created_user: UserEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserFavRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavRecoverInputWhere!]
}

input UserFavRecoverInputWhere {
  """Unique ID of the user favourite, auto generated."""
  id: FindOperatorDto

  """Favourite category Id of the user favourite."""
  favcat_id: FindOperatorDto

  """User Id of the user favourite added by."""
  created_u_id: FindOperatorDto

  """User authorization Id of the user."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite categories of the user."""
  fr_user_fav_categories: [UserFavCategoryFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type UserFavRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserFavEntity!]!
}

input UserFavRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavRemoveInputWhere!]
}

input UserFavRemoveInputWhere {
  """Unique ID of the user favourite, auto generated."""
  id: FindOperatorDto

  """Favourite category Id of the user favourite."""
  favcat_id: FindOperatorDto

  """User Id of the user favourite added by."""
  created_u_id: FindOperatorDto

  """User authorization Id of the user."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite categories of the user."""
  fr_user_fav_categories: [UserFavCategoryFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type UserFavRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserFavEntity!]!
}

input UserFavRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavRestoreInputWhere!]
}

input UserFavRestoreInputWhere {
  """Unique ID of the user favourite, auto generated."""
  id: FindOperatorDto

  """Favourite category Id of the user favourite."""
  favcat_id: FindOperatorDto

  """User Id of the user favourite added by."""
  created_u_id: FindOperatorDto

  """User authorization Id of the user."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite categories of the user."""
  fr_user_fav_categories: [UserFavCategoryFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type UserFavRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserFavSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavSoftDeleteInputWhere!]
}

input UserFavSoftDeleteInputWhere {
  """Unique ID of the user favourite, auto generated."""
  id: FindOperatorDto

  """Favourite category Id of the user favourite."""
  favcat_id: FindOperatorDto

  """User Id of the user favourite added by."""
  created_u_id: FindOperatorDto

  """User authorization Id of the user."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite categories of the user."""
  fr_user_fav_categories: [UserFavCategoryFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type UserFavSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserFavSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavSoftRemoveInputWhere!]
}

input UserFavSoftRemoveInputWhere {
  """Unique ID of the user favourite, auto generated."""
  id: FindOperatorDto

  """Favourite category Id of the user favourite."""
  favcat_id: FindOperatorDto

  """User Id of the user favourite added by."""
  created_u_id: FindOperatorDto

  """User authorization Id of the user."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite categories of the user."""
  fr_user_fav_categories: [UserFavCategoryFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type UserFavSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserFavEntity!]!
}

input UserFavUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFavUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserFavUpdateInputSets!
}

input UserFavUpdateInputSets {
  """Favourite category Id of the user favourite."""
  favcat_id: Int

  """Reference Id of the user favourite."""
  ref_id: String

  """Notes of the user favourite."""
  notes: String
}

input UserFavUpdateInputWhere {
  """Unique ID of the user favourite, auto generated."""
  id: FindOperatorDto

  """Favourite category Id of the user favourite."""
  favcat_id: FindOperatorDto

  """User Id of the user favourite added by."""
  created_u_id: FindOperatorDto

  """User authorization Id of the user."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Favourite categories of the user."""
  fr_user_fav_categories: [UserFavCategoryFindInputWhere!]

  """User id of the queueemail added by"""
  fr_created_user: [UserFindInputWhere!]

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: [AuthorisationFindInputWhere!]
}

type UserFavUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserFavEntity!]!
}

input UserFavUpsertInput {
  """Favourite category Id of the user favourite."""
  favcat_id: Int!

  """Reference Id of the user favourite."""
  ref_id: String!

  """Notes of the user favourite."""
  notes: String!

  """Unique ID of the user favourite, auto generated. undefined"""
  id: Int
}

type UserFavUpsertOutput {
  """Unique ID of the user favourite, auto generated."""
  id: Int

  """Favourite category Id of the user favourite."""
  favcat_id: Int

  """Reference Id of the user favourite."""
  ref_id: String

  """Notes of the user favourite."""
  notes: String

  """User Id of the user favourite added by."""
  created_u_id: Int

  """User authorization Id of the user."""
  created_ar_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Favourite categories of the user."""
  fr_user_fav_categories: UserFavCategoryEntity

  """User id of the queueemail added by"""
  fr_created_user: UserEntity

  """Authorisation info of the user role who created email."""
  fr_created_authorisation: AuthorisationEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserFileCreateInput {
  """User ID of the user file"""
  u_id: Int!
}

type UserFileCreateOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """User ID of the user file"""
  u_id: Int

  """User additional files."""
  file: String

  """User attachment file url."""
  file_url: UploadFileAccessUrlDto

  """Date time when user file is created."""
  created: DateTime

  """Date time when user file is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User of the user identity card."""
  fr_user: UserEntity
}

input UserFileDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFileDeleteInputWhere!]
}

input UserFileDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user file"""
  u_id: FindOperatorDto

  """Date time when user file is created."""
  created: FindOperatorDto

  """Date time when user file is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]
}

type UserFileDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserFileEntity {
  """Unique ID of the entity, auto generated."""
  id: Int

  """User ID of the user file"""
  u_id: Int

  """User additional files."""
  file: String

  """User attachment file url."""
  file_url: UploadFileAccessUrlDto

  """Date time when user file is created."""
  created: DateTime

  """Date time when user file is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User of the user identity card."""
  fr_user: UserEntity
}

input UserFileFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFileFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserFileFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserFileFindInputSortOrder
}

input UserFileFindInputGroupBy {
  u_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserFileFindInputSortOrder {
  id: RecordSortDirectionEnum
  u_id: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserFileFindInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user file"""
  u_id: FindOperatorDto

  """Date time when user file is created."""
  created: FindOperatorDto

  """Date time when user file is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]
}

input UserFileFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserFileFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserFileEntity!]!
}

input UserFileRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFileRecoverInputWhere!]
}

input UserFileRecoverInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user file"""
  u_id: FindOperatorDto

  """Date time when user file is created."""
  created: FindOperatorDto

  """Date time when user file is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]
}

type UserFileRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records recovered for the recover query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserFileEntity!]
}

input UserFileRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFileRemoveInputWhere!]
}

input UserFileRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user file"""
  u_id: FindOperatorDto

  """Date time when user file is created."""
  created: FindOperatorDto

  """Date time when user file is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]
}

type UserFileRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records removed for the remove query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserFileEntity!]
}

input UserFileRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFileRestoreInputWhere!]
}

input UserFileRestoreInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user file"""
  u_id: FindOperatorDto

  """Date time when user file is created."""
  created: FindOperatorDto

  """Date time when user file is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]
}

type UserFileRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserFileSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFileSoftDeleteInputWhere!]
}

input UserFileSoftDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user file"""
  u_id: FindOperatorDto

  """Date time when user file is created."""
  created: FindOperatorDto

  """Date time when user file is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]
}

type UserFileSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserFileSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFileSoftRemoveInputWhere!]
}

input UserFileSoftRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user file"""
  u_id: FindOperatorDto

  """Date time when user file is created."""
  created: FindOperatorDto

  """Date time when user file is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]
}

type UserFileSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records soft removed for the soft remove query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserFileEntity!]
}

input UserFileUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFileUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserFileUpdateInputSets!
}

input UserFileUpdateInputSets {
  """User ID of the user file"""
  u_id: Int
}

input UserFileUpdateInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """User ID of the user file"""
  u_id: FindOperatorDto

  """Date time when user file is created."""
  created: FindOperatorDto

  """Date time when user file is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]
}

type UserFileUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserFileEntity!]
}

input UserFileUploadDeleteInput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserFileUploadFileFieldEnum!

  """Please enter record reference id for uploaded file."""
  ref_id: String!

  """
  Please enter record id for uploaded file, this is optional but in some case when entity has single file upload and also has enternal relation id is must.
  """
  id: String

  """
  When file delete is performed and file is inside a folder of record id and during delete, if all files are deleted, means folder is empty, then also remove record id folder.
  """
  rmdir_record: Boolean! = false
}

type UserFileUploadDeleteOutput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserFileUploadFileFieldEnum

  """Record reference id for uploaded file."""
  ref_id: String

  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  File id used to perform delete, this is a record id where file is saved.
  """
  id: String
}

"""UserFile upload ref type enum"""
enum UserFileUploadFileFieldEnum {
  """
  Upload user file. Only jpeg, jpg, png, svg, gif, doc, docx, pdf, xls, xlsx, odt, ods, txt, csv, json, xml, number, ppt, pptx, keynote, zip, rar, 7z, mp4, mkv, avi, mov, wmv, flv, mp3, wav, ogg, apk, ipa, and exe files are allowed. Maximum file size is 10 MB. 5 files are allowed to upload at a time.
  """
  FILE_USER_ATTACHMENT
}

input UserFileUploadInput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserFileUploadFileFieldEnum!

  """Please enter record reference id for uploaded file."""
  ref_id: String!

  """
  Please enter record id for uploaded file, this is optional but in some case when entity has single file upload and also has enternal relation id is must.
  """
  id: String
}

type UserFileUploadOutput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserFileUploadFileFieldEnum

  """File id on sucessfull upload, this database record id holds this file."""
  id: String

  """Record reference id for uploaded file."""
  ref_id: String

  """Uploaded file name."""
  file_name: String

  """Uploaded file access url over web."""
  access_url: UploadFileAccessUrlDto
}

input UserFileUpsertInput {
  """User ID of the user file"""
  u_id: Int!

  """Unique ID of the entity, auto generated. undefined"""
  id: Int
}

type UserFileUpsertOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """User ID of the user file"""
  u_id: Int

  """User additional files."""
  file: String

  """User attachment file url."""
  file_url: UploadFileAccessUrlDto

  """Date time when user file is created."""
  created: DateTime

  """Date time when user file is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User of the user identity card."""
  fr_user: UserEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserFindInputSortOrder
}

input UserFindInputGroupBy {
  primary_mobile_cc: Boolean
  recovery_mobile_cc: Boolean
  has_two_factor_auth: Boolean
  pemail_verified: Boolean
  pmobile_verified: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserFindInputSortOrder {
  id: RecordSortDirectionEnum
  fname: RecordSortDirectionEnum
  connsrc_id: RecordSortDirectionEnum
  lname: RecordSortDirectionEnum
  primary_mobile_cc: RecordSortDirectionEnum
  recovery_mobile_cc: RecordSortDirectionEnum
  has_two_factor_auth: RecordSortDirectionEnum
  pemail_verified: RecordSortDirectionEnum
  pmobile_verified: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserFindInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: FindOperatorDto

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: FindOperatorDto

  """Connection source ID."""
  connsrc_id: FindOperatorDto

  """First name of the user."""
  fname: FindOperatorDto

  """Last name of the user."""
  lname: FindOperatorDto

  """Middle name of the user."""
  mname: FindOperatorDto

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: FindOperatorDto

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: FindOperatorDto

  """Primary mobile country code of the user."""
  primary_mobile_cc: FindOperatorDto

  """Used to reset password."""
  recovery_email: FindOperatorDto

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: FindOperatorDto

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: FindOperatorDto

  """Provide whatsapp of the user."""
  whatsapp: FindOperatorDto

  """Whatsapp country code of the user."""
  whatsapp_cc: FindOperatorDto

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: FindOperatorDto

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: FindOperatorDto

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: FindOperatorDto

  """Date time when user is created."""
  created: FindOperatorDto

  """Date time when user is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User auth info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceFindInputWhere!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """User personal info of the user."""
  fr_user_personal_info: [UserPersonalInfoFindInputWhere!]

  """User address of the user."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyFindInputWhere!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User files."""
  fr_user_files: [UserFileFindInputWhere!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsFindInputWhere!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsFindInputWhere!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappFindInputWhere!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappFindInputWhere!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailFindInputWhere!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailFindInputWhere!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailFindInputWhere!]

  """connection source for this user."""
  fr_connection_source: [ConnectionSourceFindInputWhere!]
}

input UserFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserEntity!]!
}

input UserHierarchyCreateInput {
  """Parent user ID of the user hierarchy."""
  parent_u_id: Int!

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: Int!

  """Child user ID of the user hierarchy."""
  child_u_id: Int!

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: Int!
}

type UserHierarchyCreateOutput {
  """Unique ID of the entity, This is the same as user id"""
  id: Int

  """Parent user ID of the user hierarchy."""
  parent_u_id: Int

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: Int

  """Child user ID of the user hierarchy."""
  child_u_id: Int

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: Int

  """Date time when user hierarchy is created."""
  created: DateTime

  """Date time when user hierarchy is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Parent user of the user hierarchy."""
  fr_parent_user: UserEntity

  """Parent user of the user hierarchy."""
  fr_child_user: UserEntity

  """Parent authorisation of the user hierarchy."""
  fr_parent_authorisation: AuthorisationEntity

  """Child authorisation of the user hierarchy."""
  fr_child_authorisation: AuthorisationEntity
}

input UserHierarchyDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserHierarchyDeleteInputWhere!]
}

input UserHierarchyDeleteInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Parent user ID of the user hierarchy."""
  parent_u_id: FindOperatorDto

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: FindOperatorDto

  """Child user ID of the user hierarchy."""
  child_u_id: FindOperatorDto

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: FindOperatorDto

  """Date time when user hierarchy is created."""
  created: FindOperatorDto

  """Date time when user hierarchy is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent user of the user hierarchy."""
  fr_parent_user: [UserFindInputWhere!]

  """Parent user of the user hierarchy."""
  fr_child_user: [UserFindInputWhere!]

  """Parent authorisation of the user hierarchy."""
  fr_parent_authorisation: [AuthorisationFindInputWhere!]

  """Child authorisation of the user hierarchy."""
  fr_child_authorisation: [AuthorisationFindInputWhere!]
}

type UserHierarchyDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserHierarchyEntity {
  """Unique ID of the entity, This is the same as user id"""
  id: Int

  """Parent user ID of the user hierarchy."""
  parent_u_id: Int

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: Int

  """Child user ID of the user hierarchy."""
  child_u_id: Int

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: Int

  """Date time when user hierarchy is created."""
  created: DateTime

  """Date time when user hierarchy is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Parent user of the user hierarchy."""
  fr_parent_user: UserEntity

  """Parent user of the user hierarchy."""
  fr_child_user: UserEntity

  """Parent authorisation of the user hierarchy."""
  fr_parent_authorisation: AuthorisationEntity

  """Child authorisation of the user hierarchy."""
  fr_child_authorisation: AuthorisationEntity
}

input UserHierarchyFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserHierarchyFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserHierarchyFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserHierarchyFindInputSortOrder
}

input UserHierarchyFindInputGroupBy {
  parent_u_id: Boolean
  parent_ar_id: Boolean
  child_u_id: Boolean
  child_ar_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserHierarchyFindInputSortOrder {
  id: RecordSortDirectionEnum
  parent_u_id: RecordSortDirectionEnum
  parent_ar_id: RecordSortDirectionEnum
  child_u_id: RecordSortDirectionEnum
  child_ar_id: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserHierarchyFindInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Parent user ID of the user hierarchy."""
  parent_u_id: FindOperatorDto

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: FindOperatorDto

  """Child user ID of the user hierarchy."""
  child_u_id: FindOperatorDto

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: FindOperatorDto

  """Date time when user hierarchy is created."""
  created: FindOperatorDto

  """Date time when user hierarchy is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent user of the user hierarchy."""
  fr_parent_user: [UserFindInputWhere!]

  """Parent user of the user hierarchy."""
  fr_child_user: [UserFindInputWhere!]

  """Parent authorisation of the user hierarchy."""
  fr_parent_authorisation: [AuthorisationFindInputWhere!]

  """Child authorisation of the user hierarchy."""
  fr_child_authorisation: [AuthorisationFindInputWhere!]
}

input UserHierarchyFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserHierarchyFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserHierarchyEntity!]!
}

input UserHierarchyRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserHierarchyRecoverInputWhere!]
}

input UserHierarchyRecoverInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Parent user ID of the user hierarchy."""
  parent_u_id: FindOperatorDto

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: FindOperatorDto

  """Child user ID of the user hierarchy."""
  child_u_id: FindOperatorDto

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: FindOperatorDto

  """Date time when user hierarchy is created."""
  created: FindOperatorDto

  """Date time when user hierarchy is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent user of the user hierarchy."""
  fr_parent_user: [UserFindInputWhere!]

  """Parent user of the user hierarchy."""
  fr_child_user: [UserFindInputWhere!]

  """Parent authorisation of the user hierarchy."""
  fr_parent_authorisation: [AuthorisationFindInputWhere!]

  """Child authorisation of the user hierarchy."""
  fr_child_authorisation: [AuthorisationFindInputWhere!]
}

type UserHierarchyRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserHierarchyEntity!]!
}

input UserHierarchyRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserHierarchyRemoveInputWhere!]
}

input UserHierarchyRemoveInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Parent user ID of the user hierarchy."""
  parent_u_id: FindOperatorDto

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: FindOperatorDto

  """Child user ID of the user hierarchy."""
  child_u_id: FindOperatorDto

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: FindOperatorDto

  """Date time when user hierarchy is created."""
  created: FindOperatorDto

  """Date time when user hierarchy is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent user of the user hierarchy."""
  fr_parent_user: [UserFindInputWhere!]

  """Parent user of the user hierarchy."""
  fr_child_user: [UserFindInputWhere!]

  """Parent authorisation of the user hierarchy."""
  fr_parent_authorisation: [AuthorisationFindInputWhere!]

  """Child authorisation of the user hierarchy."""
  fr_child_authorisation: [AuthorisationFindInputWhere!]
}

type UserHierarchyRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserHierarchyEntity!]!
}

input UserHierarchyRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserHierarchyRestoreInputWhere!]
}

input UserHierarchyRestoreInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Parent user ID of the user hierarchy."""
  parent_u_id: FindOperatorDto

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: FindOperatorDto

  """Child user ID of the user hierarchy."""
  child_u_id: FindOperatorDto

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: FindOperatorDto

  """Date time when user hierarchy is created."""
  created: FindOperatorDto

  """Date time when user hierarchy is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent user of the user hierarchy."""
  fr_parent_user: [UserFindInputWhere!]

  """Parent user of the user hierarchy."""
  fr_child_user: [UserFindInputWhere!]

  """Parent authorisation of the user hierarchy."""
  fr_parent_authorisation: [AuthorisationFindInputWhere!]

  """Child authorisation of the user hierarchy."""
  fr_child_authorisation: [AuthorisationFindInputWhere!]
}

type UserHierarchyRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserHierarchySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserHierarchySoftDeleteInputWhere!]
}

input UserHierarchySoftDeleteInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Parent user ID of the user hierarchy."""
  parent_u_id: FindOperatorDto

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: FindOperatorDto

  """Child user ID of the user hierarchy."""
  child_u_id: FindOperatorDto

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: FindOperatorDto

  """Date time when user hierarchy is created."""
  created: FindOperatorDto

  """Date time when user hierarchy is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent user of the user hierarchy."""
  fr_parent_user: [UserFindInputWhere!]

  """Parent user of the user hierarchy."""
  fr_child_user: [UserFindInputWhere!]

  """Parent authorisation of the user hierarchy."""
  fr_parent_authorisation: [AuthorisationFindInputWhere!]

  """Child authorisation of the user hierarchy."""
  fr_child_authorisation: [AuthorisationFindInputWhere!]
}

type UserHierarchySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserHierarchySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserHierarchySoftRemoveInputWhere!]
}

input UserHierarchySoftRemoveInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Parent user ID of the user hierarchy."""
  parent_u_id: FindOperatorDto

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: FindOperatorDto

  """Child user ID of the user hierarchy."""
  child_u_id: FindOperatorDto

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: FindOperatorDto

  """Date time when user hierarchy is created."""
  created: FindOperatorDto

  """Date time when user hierarchy is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent user of the user hierarchy."""
  fr_parent_user: [UserFindInputWhere!]

  """Parent user of the user hierarchy."""
  fr_child_user: [UserFindInputWhere!]

  """Parent authorisation of the user hierarchy."""
  fr_parent_authorisation: [AuthorisationFindInputWhere!]

  """Child authorisation of the user hierarchy."""
  fr_child_authorisation: [AuthorisationFindInputWhere!]
}

type UserHierarchySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserHierarchyEntity!]!
}

input UserHierarchyUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserHierarchyUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserHierarchyUpdateInputSets!
}

input UserHierarchyUpdateInputSets {
  """Parent user ID of the user hierarchy."""
  parent_u_id: Int

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: Int

  """Child user ID of the user hierarchy."""
  child_u_id: Int

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: Int
}

input UserHierarchyUpdateInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Parent user ID of the user hierarchy."""
  parent_u_id: FindOperatorDto

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: FindOperatorDto

  """Child user ID of the user hierarchy."""
  child_u_id: FindOperatorDto

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: FindOperatorDto

  """Date time when user hierarchy is created."""
  created: FindOperatorDto

  """Date time when user hierarchy is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent user of the user hierarchy."""
  fr_parent_user: [UserFindInputWhere!]

  """Parent user of the user hierarchy."""
  fr_child_user: [UserFindInputWhere!]

  """Parent authorisation of the user hierarchy."""
  fr_parent_authorisation: [AuthorisationFindInputWhere!]

  """Child authorisation of the user hierarchy."""
  fr_child_authorisation: [AuthorisationFindInputWhere!]
}

type UserHierarchyUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserHierarchyEntity!]!
}

input UserHierarchyUpsertInput {
  """Parent user ID of the user hierarchy."""
  parent_u_id: Int!

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: Int!

  """Child user ID of the user hierarchy."""
  child_u_id: Int!

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: Int!

  """Unique ID of the entity, This is the same as user id undefined"""
  id: Int
}

type UserHierarchyUpsertOutput {
  """Unique ID of the entity, This is the same as user id"""
  id: Int

  """Parent user ID of the user hierarchy."""
  parent_u_id: Int

  """Parent authorisation ID of the user hierarchy."""
  parent_ar_id: Int

  """Child user ID of the user hierarchy."""
  child_u_id: Int

  """Child authorisation ID of the user hierarchy."""
  child_ar_id: Int

  """Date time when user hierarchy is created."""
  created: DateTime

  """Date time when user hierarchy is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Parent user of the user hierarchy."""
  fr_parent_user: UserEntity

  """Parent user of the user hierarchy."""
  fr_child_user: UserEntity

  """Parent authorisation of the user hierarchy."""
  fr_parent_authorisation: AuthorisationEntity

  """Child authorisation of the user hierarchy."""
  fr_child_authorisation: AuthorisationEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserIdentityCardCreateInput {
  """Identity card type ID of the user identity card."""
  idctype_id: Int!

  """User ID of the user identity card."""
  u_id: Int!

  """Number of the user identity card."""
  num: String!

  """Issue date of the user identity card."""
  issue_date: DateTime

  """Country ID of the user identity card."""
  issue_country_id: Int!

  """State ID of the user identity card."""
  issue_state_id: Int!

  """City ID of the user identity card."""
  issue_city_id: Int!

  """Issue place of the user identity card."""
  issue_place: String!
}

type UserIdentityCardCreateOutput {
  """Unique ID of the entity, This is the same as user id"""
  id: Int

  """Identity card type ID of the user identity card."""
  idctype_id: Int

  """User ID of the user identity card."""
  u_id: Int

  """Number of the user identity card."""
  num: String

  """Issue date of the user identity card."""
  issue_date: DateTime

  """Country ID of the user identity card."""
  issue_country_id: Int

  """State ID of the user identity card."""
  issue_state_id: Int

  """City ID of the user identity card."""
  issue_city_id: Int

  """Issue place of the user identity card."""
  issue_place: String

  """Date time when user identity card is created."""
  created: DateTime

  """Date time when user identity card is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User identity card type of the user identity card."""
  fr_user_identity_card_type: IdentityCardTypeEntity

  """User of the user identity card."""
  fr_user: UserEntity

  """Country of the user identity card."""
  fr_country: CountryEntity

  """State of the user identity card."""
  fr_state: StateEntity

  """City of the user identity card."""
  fr_city: CityEntity
}

input UserIdentityCardDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserIdentityCardDeleteInputWhere!]
}

input UserIdentityCardDeleteInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Identity card type ID of the user identity card."""
  idctype_id: FindOperatorDto

  """User ID of the user identity card."""
  u_id: FindOperatorDto

  """Number of the user identity card."""
  num: FindOperatorDto

  """Issue date of the user identity card."""
  issue_date: FindOperatorDto

  """Issue place of the user identity card."""
  issue_place: FindOperatorDto

  """Country ID of the user identity card."""
  issue_country_id: FindOperatorDto

  """State ID of the user identity card."""
  issue_state_id: FindOperatorDto

  """City ID of the user identity card."""
  issue_city_id: FindOperatorDto

  """Date time when user identity card is created."""
  created: FindOperatorDto

  """Date time when user identity card is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User identity card type of the user identity card."""
  fr_user_identity_card_type: [IdentityCardTypeFindInputWhere!]

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]
}

type UserIdentityCardDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserIdentityCardEntity {
  """Unique ID of the entity, This is the same as user id"""
  id: Int

  """Identity card type ID of the user identity card."""
  idctype_id: Int

  """User ID of the user identity card."""
  u_id: Int

  """Number of the user identity card."""
  num: String

  """Issue date of the user identity card."""
  issue_date: DateTime

  """Country ID of the user identity card."""
  issue_country_id: Int

  """State ID of the user identity card."""
  issue_state_id: Int

  """City ID of the user identity card."""
  issue_city_id: Int

  """Issue place of the user identity card."""
  issue_place: String

  """Date time when user identity card is created."""
  created: DateTime

  """Date time when user identity card is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User identity card type of the user identity card."""
  fr_user_identity_card_type: IdentityCardTypeEntity

  """User of the user identity card."""
  fr_user: UserEntity

  """Country of the user identity card."""
  fr_country: CountryEntity

  """State of the user identity card."""
  fr_state: StateEntity

  """City of the user identity card."""
  fr_city: CityEntity
}

input UserIdentityCardFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserIdentityCardFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserIdentityCardFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserIdentityCardFindInputSortOrder
}

input UserIdentityCardFindInputGroupBy {
  idctype_id: Boolean
  u_id: Boolean
  issue_date: Boolean
  issue_country_id: Boolean
  issue_state_id: Boolean
  issue_city_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserIdentityCardFindInputSortOrder {
  id: RecordSortDirectionEnum
  idctype_id: RecordSortDirectionEnum
  u_id: RecordSortDirectionEnum
  num: RecordSortDirectionEnum
  issue_date: RecordSortDirectionEnum
  issue_country_id: RecordSortDirectionEnum
  issue_state_id: RecordSortDirectionEnum
  issue_city_id: RecordSortDirectionEnum
  issue_place: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserIdentityCardFindInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Identity card type ID of the user identity card."""
  idctype_id: FindOperatorDto

  """User ID of the user identity card."""
  u_id: FindOperatorDto

  """Number of the user identity card."""
  num: FindOperatorDto

  """Issue date of the user identity card."""
  issue_date: FindOperatorDto

  """Issue place of the user identity card."""
  issue_place: FindOperatorDto

  """Country ID of the user identity card."""
  issue_country_id: FindOperatorDto

  """State ID of the user identity card."""
  issue_state_id: FindOperatorDto

  """City ID of the user identity card."""
  issue_city_id: FindOperatorDto

  """Date time when user identity card is created."""
  created: FindOperatorDto

  """Date time when user identity card is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User identity card type of the user identity card."""
  fr_user_identity_card_type: [IdentityCardTypeFindInputWhere!]

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]
}

input UserIdentityCardFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserIdentityCardFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserIdentityCardEntity!]!
}

input UserIdentityCardRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserIdentityCardRecoverInputWhere!]
}

input UserIdentityCardRecoverInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Identity card type ID of the user identity card."""
  idctype_id: FindOperatorDto

  """User ID of the user identity card."""
  u_id: FindOperatorDto

  """Number of the user identity card."""
  num: FindOperatorDto

  """Issue date of the user identity card."""
  issue_date: FindOperatorDto

  """Issue place of the user identity card."""
  issue_place: FindOperatorDto

  """Country ID of the user identity card."""
  issue_country_id: FindOperatorDto

  """State ID of the user identity card."""
  issue_state_id: FindOperatorDto

  """City ID of the user identity card."""
  issue_city_id: FindOperatorDto

  """Date time when user identity card is created."""
  created: FindOperatorDto

  """Date time when user identity card is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User identity card type of the user identity card."""
  fr_user_identity_card_type: [IdentityCardTypeFindInputWhere!]

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]
}

type UserIdentityCardRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserIdentityCardEntity!]!
}

input UserIdentityCardRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserIdentityCardRemoveInputWhere!]
}

input UserIdentityCardRemoveInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Identity card type ID of the user identity card."""
  idctype_id: FindOperatorDto

  """User ID of the user identity card."""
  u_id: FindOperatorDto

  """Number of the user identity card."""
  num: FindOperatorDto

  """Issue date of the user identity card."""
  issue_date: FindOperatorDto

  """Issue place of the user identity card."""
  issue_place: FindOperatorDto

  """Country ID of the user identity card."""
  issue_country_id: FindOperatorDto

  """State ID of the user identity card."""
  issue_state_id: FindOperatorDto

  """City ID of the user identity card."""
  issue_city_id: FindOperatorDto

  """Date time when user identity card is created."""
  created: FindOperatorDto

  """Date time when user identity card is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User identity card type of the user identity card."""
  fr_user_identity_card_type: [IdentityCardTypeFindInputWhere!]

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]
}

type UserIdentityCardRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserIdentityCardEntity!]!
}

input UserIdentityCardRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserIdentityCardRestoreInputWhere!]
}

input UserIdentityCardRestoreInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Identity card type ID of the user identity card."""
  idctype_id: FindOperatorDto

  """User ID of the user identity card."""
  u_id: FindOperatorDto

  """Number of the user identity card."""
  num: FindOperatorDto

  """Issue date of the user identity card."""
  issue_date: FindOperatorDto

  """Issue place of the user identity card."""
  issue_place: FindOperatorDto

  """Country ID of the user identity card."""
  issue_country_id: FindOperatorDto

  """State ID of the user identity card."""
  issue_state_id: FindOperatorDto

  """City ID of the user identity card."""
  issue_city_id: FindOperatorDto

  """Date time when user identity card is created."""
  created: FindOperatorDto

  """Date time when user identity card is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User identity card type of the user identity card."""
  fr_user_identity_card_type: [IdentityCardTypeFindInputWhere!]

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]
}

type UserIdentityCardRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserIdentityCardSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserIdentityCardSoftDeleteInputWhere!]
}

input UserIdentityCardSoftDeleteInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Identity card type ID of the user identity card."""
  idctype_id: FindOperatorDto

  """User ID of the user identity card."""
  u_id: FindOperatorDto

  """Number of the user identity card."""
  num: FindOperatorDto

  """Issue date of the user identity card."""
  issue_date: FindOperatorDto

  """Issue place of the user identity card."""
  issue_place: FindOperatorDto

  """Country ID of the user identity card."""
  issue_country_id: FindOperatorDto

  """State ID of the user identity card."""
  issue_state_id: FindOperatorDto

  """City ID of the user identity card."""
  issue_city_id: FindOperatorDto

  """Date time when user identity card is created."""
  created: FindOperatorDto

  """Date time when user identity card is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User identity card type of the user identity card."""
  fr_user_identity_card_type: [IdentityCardTypeFindInputWhere!]

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]
}

type UserIdentityCardSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserIdentityCardSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserIdentityCardSoftRemoveInputWhere!]
}

input UserIdentityCardSoftRemoveInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Identity card type ID of the user identity card."""
  idctype_id: FindOperatorDto

  """User ID of the user identity card."""
  u_id: FindOperatorDto

  """Number of the user identity card."""
  num: FindOperatorDto

  """Issue date of the user identity card."""
  issue_date: FindOperatorDto

  """Issue place of the user identity card."""
  issue_place: FindOperatorDto

  """Country ID of the user identity card."""
  issue_country_id: FindOperatorDto

  """State ID of the user identity card."""
  issue_state_id: FindOperatorDto

  """City ID of the user identity card."""
  issue_city_id: FindOperatorDto

  """Date time when user identity card is created."""
  created: FindOperatorDto

  """Date time when user identity card is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User identity card type of the user identity card."""
  fr_user_identity_card_type: [IdentityCardTypeFindInputWhere!]

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]
}

type UserIdentityCardSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserIdentityCardEntity!]!
}

input UserIdentityCardUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserIdentityCardUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserIdentityCardUpdateInputSets!
}

input UserIdentityCardUpdateInputSets {
  """Identity card type ID of the user identity card."""
  idctype_id: Int

  """User ID of the user identity card."""
  u_id: Int

  """Number of the user identity card."""
  num: String

  """Issue date of the user identity card."""
  issue_date: DateTime

  """Country ID of the user identity card."""
  issue_country_id: Int

  """State ID of the user identity card."""
  issue_state_id: Int

  """City ID of the user identity card."""
  issue_city_id: Int

  """Issue place of the user identity card."""
  issue_place: String
}

input UserIdentityCardUpdateInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Identity card type ID of the user identity card."""
  idctype_id: FindOperatorDto

  """User ID of the user identity card."""
  u_id: FindOperatorDto

  """Number of the user identity card."""
  num: FindOperatorDto

  """Issue date of the user identity card."""
  issue_date: FindOperatorDto

  """Issue place of the user identity card."""
  issue_place: FindOperatorDto

  """Country ID of the user identity card."""
  issue_country_id: FindOperatorDto

  """State ID of the user identity card."""
  issue_state_id: FindOperatorDto

  """City ID of the user identity card."""
  issue_city_id: FindOperatorDto

  """Date time when user identity card is created."""
  created: FindOperatorDto

  """Date time when user identity card is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User identity card type of the user identity card."""
  fr_user_identity_card_type: [IdentityCardTypeFindInputWhere!]

  """User of the user identity card."""
  fr_user: [UserFindInputWhere!]

  """Country of the user identity card."""
  fr_country: [CountryFindInputWhere!]

  """State of the user identity card."""
  fr_state: [StateFindInputWhere!]

  """City of the user identity card."""
  fr_city: [CityFindInputWhere!]
}

type UserIdentityCardUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserIdentityCardEntity!]!
}

input UserIdentityCardUpsertInput {
  """Identity card type ID of the user identity card."""
  idctype_id: Int!

  """User ID of the user identity card."""
  u_id: Int!

  """Number of the user identity card."""
  num: String!

  """Issue date of the user identity card."""
  issue_date: DateTime

  """Country ID of the user identity card."""
  issue_country_id: Int!

  """State ID of the user identity card."""
  issue_state_id: Int!

  """City ID of the user identity card."""
  issue_city_id: Int!

  """Issue place of the user identity card."""
  issue_place: String!

  """Unique ID of the entity, This is the same as user id undefined"""
  id: Int
}

type UserIdentityCardUpsertOutput {
  """Unique ID of the entity, This is the same as user id"""
  id: Int

  """Identity card type ID of the user identity card."""
  idctype_id: Int

  """User ID of the user identity card."""
  u_id: Int

  """Number of the user identity card."""
  num: String

  """Issue date of the user identity card."""
  issue_date: DateTime

  """Country ID of the user identity card."""
  issue_country_id: Int

  """State ID of the user identity card."""
  issue_state_id: Int

  """City ID of the user identity card."""
  issue_city_id: Int

  """Issue place of the user identity card."""
  issue_place: String

  """Date time when user identity card is created."""
  created: DateTime

  """Date time when user identity card is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User identity card type of the user identity card."""
  fr_user_identity_card_type: IdentityCardTypeEntity

  """User of the user identity card."""
  fr_user: UserEntity

  """Country of the user identity card."""
  fr_country: CountryEntity

  """State of the user identity card."""
  fr_state: StateEntity

  """City of the user identity card."""
  fr_city: CityEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserNewsLetterSubscriptionCreateInput {
  """User Id of the user newsletter subscription."""
  u_id: Int!

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: Int!

  """Subscribed of the user newsletter subscription."""
  subscribed: DateTime

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: DateTime
}

type UserNewsLetterSubscriptionCreateOutput {
  """Unique ID of the user newsletter subscription, auto generated."""
  id: Int

  """User Id of the user newsletter subscription."""
  u_id: Int

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: Int

  """Subscribed of the user newsletter subscription."""
  subscribed: DateTime

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletters of user newsletter subscription."""
  fr_users: UserEntity

  """Newsletters Schedules of user newsletter subscription."""
  fr_categories: NewsLetterCategoryEntity
}

input UserNewsLetterSubscriptionDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserNewsLetterSubscriptionDeleteInputWhere!]
}

input UserNewsLetterSubscriptionDeleteInputWhere {
  """Unique ID of the user newsletter subscription, auto generated."""
  id: FindOperatorDto

  """User Id of the user newsletter subscription."""
  u_id: FindOperatorDto

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: FindOperatorDto

  """Subscribed of the user newsletter subscription."""
  subscribed: FindOperatorDto

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of user newsletter subscription."""
  fr_users: [UserFindInputWhere!]

  """Newsletters Schedules of user newsletter subscription."""
  fr_categories: [NewsLetterCategoryFindInputWhere!]
}

type UserNewsLetterSubscriptionDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserNewsLetterSubscriptionEntity {
  """Unique ID of the user newsletter subscription, auto generated."""
  id: Int

  """User Id of the user newsletter subscription."""
  u_id: Int

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: Int

  """Subscribed of the user newsletter subscription."""
  subscribed: DateTime

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletters of user newsletter subscription."""
  fr_users: UserEntity

  """Newsletters Schedules of user newsletter subscription."""
  fr_categories: NewsLetterCategoryEntity
}

input UserNewsLetterSubscriptionFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserNewsLetterSubscriptionFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserNewsLetterSubscriptionFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserNewsLetterSubscriptionFindInputSortOrder
}

input UserNewsLetterSubscriptionFindInputGroupBy {
  u_id: Boolean
  nlcat_id: Boolean
  subscribed: Boolean
  unsubscribed: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserNewsLetterSubscriptionFindInputSortOrder {
  id: RecordSortDirectionEnum
  u_id: RecordSortDirectionEnum
  nlcat_id: RecordSortDirectionEnum
  subscribed: RecordSortDirectionEnum
  unsubscribed: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserNewsLetterSubscriptionFindInputWhere {
  """Unique ID of the user newsletter subscription, auto generated."""
  id: FindOperatorDto

  """User Id of the user newsletter subscription."""
  u_id: FindOperatorDto

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: FindOperatorDto

  """Subscribed of the user newsletter subscription."""
  subscribed: FindOperatorDto

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of user newsletter subscription."""
  fr_users: [UserFindInputWhere!]

  """Newsletters Schedules of user newsletter subscription."""
  fr_categories: [NewsLetterCategoryFindInputWhere!]
}

input UserNewsLetterSubscriptionFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserNewsLetterSubscriptionFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserNewsLetterSubscriptionEntity!]!
}

input UserNewsLetterSubscriptionRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserNewsLetterSubscriptionRecoverInputWhere!]
}

input UserNewsLetterSubscriptionRecoverInputWhere {
  """Unique ID of the user newsletter subscription, auto generated."""
  id: FindOperatorDto

  """User Id of the user newsletter subscription."""
  u_id: FindOperatorDto

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: FindOperatorDto

  """Subscribed of the user newsletter subscription."""
  subscribed: FindOperatorDto

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of user newsletter subscription."""
  fr_users: [UserFindInputWhere!]

  """Newsletters Schedules of user newsletter subscription."""
  fr_categories: [NewsLetterCategoryFindInputWhere!]
}

type UserNewsLetterSubscriptionRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserNewsLetterSubscriptionEntity!]!
}

input UserNewsLetterSubscriptionRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserNewsLetterSubscriptionRemoveInputWhere!]
}

input UserNewsLetterSubscriptionRemoveInputWhere {
  """Unique ID of the user newsletter subscription, auto generated."""
  id: FindOperatorDto

  """User Id of the user newsletter subscription."""
  u_id: FindOperatorDto

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: FindOperatorDto

  """Subscribed of the user newsletter subscription."""
  subscribed: FindOperatorDto

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of user newsletter subscription."""
  fr_users: [UserFindInputWhere!]

  """Newsletters Schedules of user newsletter subscription."""
  fr_categories: [NewsLetterCategoryFindInputWhere!]
}

type UserNewsLetterSubscriptionRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserNewsLetterSubscriptionEntity!]!
}

input UserNewsLetterSubscriptionRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserNewsLetterSubscriptionRestoreInputWhere!]
}

input UserNewsLetterSubscriptionRestoreInputWhere {
  """Unique ID of the user newsletter subscription, auto generated."""
  id: FindOperatorDto

  """User Id of the user newsletter subscription."""
  u_id: FindOperatorDto

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: FindOperatorDto

  """Subscribed of the user newsletter subscription."""
  subscribed: FindOperatorDto

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of user newsletter subscription."""
  fr_users: [UserFindInputWhere!]

  """Newsletters Schedules of user newsletter subscription."""
  fr_categories: [NewsLetterCategoryFindInputWhere!]
}

type UserNewsLetterSubscriptionRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserNewsLetterSubscriptionSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserNewsLetterSubscriptionSoftDeleteInputWhere!]
}

input UserNewsLetterSubscriptionSoftDeleteInputWhere {
  """Unique ID of the user newsletter subscription, auto generated."""
  id: FindOperatorDto

  """User Id of the user newsletter subscription."""
  u_id: FindOperatorDto

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: FindOperatorDto

  """Subscribed of the user newsletter subscription."""
  subscribed: FindOperatorDto

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of user newsletter subscription."""
  fr_users: [UserFindInputWhere!]

  """Newsletters Schedules of user newsletter subscription."""
  fr_categories: [NewsLetterCategoryFindInputWhere!]
}

type UserNewsLetterSubscriptionSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserNewsLetterSubscriptionSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserNewsLetterSubscriptionSoftRemoveInputWhere!]
}

input UserNewsLetterSubscriptionSoftRemoveInputWhere {
  """Unique ID of the user newsletter subscription, auto generated."""
  id: FindOperatorDto

  """User Id of the user newsletter subscription."""
  u_id: FindOperatorDto

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: FindOperatorDto

  """Subscribed of the user newsletter subscription."""
  subscribed: FindOperatorDto

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of user newsletter subscription."""
  fr_users: [UserFindInputWhere!]

  """Newsletters Schedules of user newsletter subscription."""
  fr_categories: [NewsLetterCategoryFindInputWhere!]
}

type UserNewsLetterSubscriptionSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserNewsLetterSubscriptionEntity!]!
}

input UserNewsLetterSubscriptionUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserNewsLetterSubscriptionUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserNewsLetterSubscriptionUpdateInputSets!
}

input UserNewsLetterSubscriptionUpdateInputSets {
  """User Id of the user newsletter subscription."""
  u_id: Int

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: Int

  """Subscribed of the user newsletter subscription."""
  subscribed: DateTime

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: DateTime
}

input UserNewsLetterSubscriptionUpdateInputWhere {
  """Unique ID of the user newsletter subscription, auto generated."""
  id: FindOperatorDto

  """User Id of the user newsletter subscription."""
  u_id: FindOperatorDto

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: FindOperatorDto

  """Subscribed of the user newsletter subscription."""
  subscribed: FindOperatorDto

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Newsletters of user newsletter subscription."""
  fr_users: [UserFindInputWhere!]

  """Newsletters Schedules of user newsletter subscription."""
  fr_categories: [NewsLetterCategoryFindInputWhere!]
}

type UserNewsLetterSubscriptionUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserNewsLetterSubscriptionEntity!]!
}

input UserNewsLetterSubscriptionUpsertInput {
  """User Id of the user newsletter subscription."""
  u_id: Int!

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: Int!

  """Subscribed of the user newsletter subscription."""
  subscribed: DateTime

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: DateTime

  """
  Unique ID of the user newsletter subscription, auto generated. undefined
  """
  id: Int
}

type UserNewsLetterSubscriptionUpsertOutput {
  """Unique ID of the user newsletter subscription, auto generated."""
  id: Int

  """User Id of the user newsletter subscription."""
  u_id: Int

  """Newsletter category Id of the user newsletter subscription."""
  nlcat_id: Int

  """Subscribed of the user newsletter subscription."""
  subscribed: DateTime

  """Unsubscribed of the user newsletter subscription."""
  unsubscribed: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Newsletters of user newsletter subscription."""
  fr_users: UserEntity

  """Newsletters Schedules of user newsletter subscription."""
  fr_categories: NewsLetterCategoryEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserPersonalInfoCreateInput {
  """Unique ID of the entity, This is the same as user id"""
  id: Int!

  """Date of birth of the user."""
  dob: String

  """Gender of the user."""
  gender: GenderEnum!

  """Height of the user."""
  height: String

  """Weight of the user."""
  weight: Float

  """Blood group of the user."""
  blood_group: String

  """Drivers license number of the user."""
  drivers_licence_num: String

  """About me of the user."""
  about_me: String

  """Email signature of the user."""
  email_sign: String

  """Website url of the user."""
  website_url: String

  """Facebook profile link of the user."""
  facebook_profile: String

  """Instagram profile link of the user."""
  instagram_profile: String

  """YouTube profile link of the user."""
  youtube_profile: String

  """X (formerly Twitter) profile link of the user."""
  x_profile: String

  """LinkedIn profile link of the user."""
  linkedin_profile: String

  """TikTok profile link of the user."""
  tiktok_profile: String

  """Pinterest profile link of the user."""
  pinterest_profile: String
}

type UserPersonalInfoCreateOutput {
  """Unique ID of the entity, This is the same as user id"""
  id: Int!

  """Date of birth of the user."""
  dob: DateTime

  """Gender of the user."""
  gender: GenderEnum

  """Height of the user."""
  height: Float

  """Weight of the user."""
  weight: Float

  """Blood group of the user."""
  blood_group: String

  """Drivers license number of the user."""
  drivers_licence_num: String

  """About me of the user."""
  about_me: String

  """Email signature of the user."""
  email_sign: String

  """Website url of the user."""
  website_url: String

  """Facebook profile link of the user."""
  facebook_profile: String

  """Instagram profile link of the user."""
  instagram_profile: String

  """YouTube profile link of the user."""
  youtube_profile: String

  """X (formerly Twitter) profile link of the user."""
  x_profile: String

  """LinkedIn profile link of the user."""
  linkedin_profile: String

  """TikTok profile link of the user."""
  tiktok_profile: String

  """Pinterest profile link of the user."""
  pinterest_profile: String

  """Date time when user personal info is created."""
  created: DateTime

  """Date time when user personal info is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User ID of the user personal info."""
  fr_user: UserEntity
}

input UserPersonalInfoDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserPersonalInfoDeleteInputWhere!]
}

input UserPersonalInfoDeleteInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Date of birth of the user."""
  dob: FindOperatorDto

  """Gender of the user."""
  gender: FindOperatorDto

  """Blood group of the user."""
  blood_group: FindOperatorDto

  """Drivers license number of the user."""
  drivers_licence_num: FindOperatorDto

  """Website url of the user."""
  website_url: FindOperatorDto

  """Facebook profile link of the user."""
  facebook_profile: FindOperatorDto

  """Instagram profile link of the user."""
  instagram_profile: FindOperatorDto

  """YouTube profile link of the user."""
  youtube_profile: FindOperatorDto

  """X (formerly Twitter) profile link of the user."""
  x_profile: FindOperatorDto

  """LinkedIn profile link of the user."""
  linkedin_profile: FindOperatorDto

  """TikTok profile link of the user."""
  tiktok_profile: FindOperatorDto

  """Pinterest profile link of the user."""
  pinterest_profile: FindOperatorDto

  """Date time when user personal info is created."""
  created: FindOperatorDto

  """Date time when user personal info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user personal info."""
  fr_user: [UserFindInputWhere!]
}

type UserPersonalInfoDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserPersonalInfoEntity {
  """Unique ID of the entity, This is the same as user id"""
  id: Int!

  """Date of birth of the user."""
  dob: DateTime

  """Gender of the user."""
  gender: GenderEnum

  """Height of the user."""
  height: Float

  """Weight of the user."""
  weight: Float

  """Blood group of the user."""
  blood_group: String

  """Drivers license number of the user."""
  drivers_licence_num: String

  """About me of the user."""
  about_me: String

  """Email signature of the user."""
  email_sign: String

  """Website url of the user."""
  website_url: String

  """Facebook profile link of the user."""
  facebook_profile: String

  """Instagram profile link of the user."""
  instagram_profile: String

  """YouTube profile link of the user."""
  youtube_profile: String

  """X (formerly Twitter) profile link of the user."""
  x_profile: String

  """LinkedIn profile link of the user."""
  linkedin_profile: String

  """TikTok profile link of the user."""
  tiktok_profile: String

  """Pinterest profile link of the user."""
  pinterest_profile: String

  """Date time when user personal info is created."""
  created: DateTime

  """Date time when user personal info is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User ID of the user personal info."""
  fr_user: UserEntity
}

input UserPersonalInfoFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserPersonalInfoFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserPersonalInfoFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserPersonalInfoFindInputSortOrder
}

input UserPersonalInfoFindInputGroupBy {
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserPersonalInfoFindInputSortOrder {
  id: RecordSortDirectionEnum
  gender: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserPersonalInfoFindInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Date of birth of the user."""
  dob: FindOperatorDto

  """Gender of the user."""
  gender: FindOperatorDto

  """Blood group of the user."""
  blood_group: FindOperatorDto

  """Drivers license number of the user."""
  drivers_licence_num: FindOperatorDto

  """Website url of the user."""
  website_url: FindOperatorDto

  """Facebook profile link of the user."""
  facebook_profile: FindOperatorDto

  """Instagram profile link of the user."""
  instagram_profile: FindOperatorDto

  """YouTube profile link of the user."""
  youtube_profile: FindOperatorDto

  """X (formerly Twitter) profile link of the user."""
  x_profile: FindOperatorDto

  """LinkedIn profile link of the user."""
  linkedin_profile: FindOperatorDto

  """TikTok profile link of the user."""
  tiktok_profile: FindOperatorDto

  """Pinterest profile link of the user."""
  pinterest_profile: FindOperatorDto

  """Date time when user personal info is created."""
  created: FindOperatorDto

  """Date time when user personal info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user personal info."""
  fr_user: [UserFindInputWhere!]
}

input UserPersonalInfoFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserPersonalInfoFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserPersonalInfoEntity!]!
}

input UserPersonalInfoRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserPersonalInfoRecoverInputWhere!]
}

input UserPersonalInfoRecoverInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Date of birth of the user."""
  dob: FindOperatorDto

  """Gender of the user."""
  gender: FindOperatorDto

  """Blood group of the user."""
  blood_group: FindOperatorDto

  """Drivers license number of the user."""
  drivers_licence_num: FindOperatorDto

  """Website url of the user."""
  website_url: FindOperatorDto

  """Facebook profile link of the user."""
  facebook_profile: FindOperatorDto

  """Instagram profile link of the user."""
  instagram_profile: FindOperatorDto

  """YouTube profile link of the user."""
  youtube_profile: FindOperatorDto

  """X (formerly Twitter) profile link of the user."""
  x_profile: FindOperatorDto

  """LinkedIn profile link of the user."""
  linkedin_profile: FindOperatorDto

  """TikTok profile link of the user."""
  tiktok_profile: FindOperatorDto

  """Pinterest profile link of the user."""
  pinterest_profile: FindOperatorDto

  """Date time when user personal info is created."""
  created: FindOperatorDto

  """Date time when user personal info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user personal info."""
  fr_user: [UserFindInputWhere!]
}

type UserPersonalInfoRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserPersonalInfoEntity!]!
}

input UserPersonalInfoRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserPersonalInfoRemoveInputWhere!]
}

input UserPersonalInfoRemoveInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Date of birth of the user."""
  dob: FindOperatorDto

  """Gender of the user."""
  gender: FindOperatorDto

  """Blood group of the user."""
  blood_group: FindOperatorDto

  """Drivers license number of the user."""
  drivers_licence_num: FindOperatorDto

  """Website url of the user."""
  website_url: FindOperatorDto

  """Facebook profile link of the user."""
  facebook_profile: FindOperatorDto

  """Instagram profile link of the user."""
  instagram_profile: FindOperatorDto

  """YouTube profile link of the user."""
  youtube_profile: FindOperatorDto

  """X (formerly Twitter) profile link of the user."""
  x_profile: FindOperatorDto

  """LinkedIn profile link of the user."""
  linkedin_profile: FindOperatorDto

  """TikTok profile link of the user."""
  tiktok_profile: FindOperatorDto

  """Pinterest profile link of the user."""
  pinterest_profile: FindOperatorDto

  """Date time when user personal info is created."""
  created: FindOperatorDto

  """Date time when user personal info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user personal info."""
  fr_user: [UserFindInputWhere!]
}

type UserPersonalInfoRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserPersonalInfoEntity!]!
}

input UserPersonalInfoRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserPersonalInfoRestoreInputWhere!]
}

input UserPersonalInfoRestoreInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Date of birth of the user."""
  dob: FindOperatorDto

  """Gender of the user."""
  gender: FindOperatorDto

  """Blood group of the user."""
  blood_group: FindOperatorDto

  """Drivers license number of the user."""
  drivers_licence_num: FindOperatorDto

  """Website url of the user."""
  website_url: FindOperatorDto

  """Facebook profile link of the user."""
  facebook_profile: FindOperatorDto

  """Instagram profile link of the user."""
  instagram_profile: FindOperatorDto

  """YouTube profile link of the user."""
  youtube_profile: FindOperatorDto

  """X (formerly Twitter) profile link of the user."""
  x_profile: FindOperatorDto

  """LinkedIn profile link of the user."""
  linkedin_profile: FindOperatorDto

  """TikTok profile link of the user."""
  tiktok_profile: FindOperatorDto

  """Pinterest profile link of the user."""
  pinterest_profile: FindOperatorDto

  """Date time when user personal info is created."""
  created: FindOperatorDto

  """Date time when user personal info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user personal info."""
  fr_user: [UserFindInputWhere!]
}

type UserPersonalInfoRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserPersonalInfoSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserPersonalInfoSoftDeleteInputWhere!]
}

input UserPersonalInfoSoftDeleteInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Date of birth of the user."""
  dob: FindOperatorDto

  """Gender of the user."""
  gender: FindOperatorDto

  """Blood group of the user."""
  blood_group: FindOperatorDto

  """Drivers license number of the user."""
  drivers_licence_num: FindOperatorDto

  """Website url of the user."""
  website_url: FindOperatorDto

  """Facebook profile link of the user."""
  facebook_profile: FindOperatorDto

  """Instagram profile link of the user."""
  instagram_profile: FindOperatorDto

  """YouTube profile link of the user."""
  youtube_profile: FindOperatorDto

  """X (formerly Twitter) profile link of the user."""
  x_profile: FindOperatorDto

  """LinkedIn profile link of the user."""
  linkedin_profile: FindOperatorDto

  """TikTok profile link of the user."""
  tiktok_profile: FindOperatorDto

  """Pinterest profile link of the user."""
  pinterest_profile: FindOperatorDto

  """Date time when user personal info is created."""
  created: FindOperatorDto

  """Date time when user personal info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user personal info."""
  fr_user: [UserFindInputWhere!]
}

type UserPersonalInfoSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserPersonalInfoSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserPersonalInfoSoftRemoveInputWhere!]
}

input UserPersonalInfoSoftRemoveInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Date of birth of the user."""
  dob: FindOperatorDto

  """Gender of the user."""
  gender: FindOperatorDto

  """Blood group of the user."""
  blood_group: FindOperatorDto

  """Drivers license number of the user."""
  drivers_licence_num: FindOperatorDto

  """Website url of the user."""
  website_url: FindOperatorDto

  """Facebook profile link of the user."""
  facebook_profile: FindOperatorDto

  """Instagram profile link of the user."""
  instagram_profile: FindOperatorDto

  """YouTube profile link of the user."""
  youtube_profile: FindOperatorDto

  """X (formerly Twitter) profile link of the user."""
  x_profile: FindOperatorDto

  """LinkedIn profile link of the user."""
  linkedin_profile: FindOperatorDto

  """TikTok profile link of the user."""
  tiktok_profile: FindOperatorDto

  """Pinterest profile link of the user."""
  pinterest_profile: FindOperatorDto

  """Date time when user personal info is created."""
  created: FindOperatorDto

  """Date time when user personal info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user personal info."""
  fr_user: [UserFindInputWhere!]
}

type UserPersonalInfoSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserPersonalInfoEntity!]!
}

input UserPersonalInfoUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserPersonalInfoUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserPersonalInfoUpdateInputSets!
}

input UserPersonalInfoUpdateInputSets {
  """Unique ID of the entity, This is the same as user id"""
  id: Int

  """Date of birth of the user."""
  dob: String

  """Gender of the user."""
  gender: GenderEnum

  """Height of the user."""
  height: String

  """Weight of the user."""
  weight: Float

  """Blood group of the user."""
  blood_group: String

  """Drivers license number of the user."""
  drivers_licence_num: String

  """About me of the user."""
  about_me: String

  """Email signature of the user."""
  email_sign: String

  """Website url of the user."""
  website_url: String

  """Facebook profile link of the user."""
  facebook_profile: String

  """Instagram profile link of the user."""
  instagram_profile: String

  """YouTube profile link of the user."""
  youtube_profile: String

  """X (formerly Twitter) profile link of the user."""
  x_profile: String

  """LinkedIn profile link of the user."""
  linkedin_profile: String

  """TikTok profile link of the user."""
  tiktok_profile: String

  """Pinterest profile link of the user."""
  pinterest_profile: String
}

input UserPersonalInfoUpdateInputWhere {
  """Unique ID of the entity, This is the same as user id"""
  id: FindOperatorDto

  """Date of birth of the user."""
  dob: FindOperatorDto

  """Gender of the user."""
  gender: FindOperatorDto

  """Blood group of the user."""
  blood_group: FindOperatorDto

  """Drivers license number of the user."""
  drivers_licence_num: FindOperatorDto

  """Website url of the user."""
  website_url: FindOperatorDto

  """Facebook profile link of the user."""
  facebook_profile: FindOperatorDto

  """Instagram profile link of the user."""
  instagram_profile: FindOperatorDto

  """YouTube profile link of the user."""
  youtube_profile: FindOperatorDto

  """X (formerly Twitter) profile link of the user."""
  x_profile: FindOperatorDto

  """LinkedIn profile link of the user."""
  linkedin_profile: FindOperatorDto

  """TikTok profile link of the user."""
  tiktok_profile: FindOperatorDto

  """Pinterest profile link of the user."""
  pinterest_profile: FindOperatorDto

  """Date time when user personal info is created."""
  created: FindOperatorDto

  """Date time when user personal info is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User ID of the user personal info."""
  fr_user: [UserFindInputWhere!]
}

type UserPersonalInfoUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserPersonalInfoEntity!]!
}

input UserPersonalInfoUpsertInput {
  """Unique ID of the entity, This is the same as user id undefined"""
  id: Int

  """Date of birth of the user."""
  dob: String

  """Gender of the user."""
  gender: GenderEnum!

  """Height of the user."""
  height: String

  """Weight of the user."""
  weight: Float

  """Blood group of the user."""
  blood_group: String

  """Drivers license number of the user."""
  drivers_licence_num: String

  """About me of the user."""
  about_me: String

  """Email signature of the user."""
  email_sign: String

  """Website url of the user."""
  website_url: String

  """Facebook profile link of the user."""
  facebook_profile: String

  """Instagram profile link of the user."""
  instagram_profile: String

  """YouTube profile link of the user."""
  youtube_profile: String

  """X (formerly Twitter) profile link of the user."""
  x_profile: String

  """LinkedIn profile link of the user."""
  linkedin_profile: String

  """TikTok profile link of the user."""
  tiktok_profile: String

  """Pinterest profile link of the user."""
  pinterest_profile: String
}

type UserPersonalInfoUpsertOutput {
  """Unique ID of the entity, This is the same as user id"""
  id: Int!

  """Date of birth of the user."""
  dob: DateTime

  """Gender of the user."""
  gender: GenderEnum

  """Height of the user."""
  height: Float

  """Weight of the user."""
  weight: Float

  """Blood group of the user."""
  blood_group: String

  """Drivers license number of the user."""
  drivers_licence_num: String

  """About me of the user."""
  about_me: String

  """Email signature of the user."""
  email_sign: String

  """Website url of the user."""
  website_url: String

  """Facebook profile link of the user."""
  facebook_profile: String

  """Instagram profile link of the user."""
  instagram_profile: String

  """YouTube profile link of the user."""
  youtube_profile: String

  """X (formerly Twitter) profile link of the user."""
  x_profile: String

  """LinkedIn profile link of the user."""
  linkedin_profile: String

  """TikTok profile link of the user."""
  tiktok_profile: String

  """Pinterest profile link of the user."""
  pinterest_profile: String

  """Date time when user personal info is created."""
  created: DateTime

  """Date time when user personal info is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User ID of the user personal info."""
  fr_user: UserEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserRecoverInputWhere!]
}

input UserRecoverInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: FindOperatorDto

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: FindOperatorDto

  """Connection source ID."""
  connsrc_id: FindOperatorDto

  """First name of the user."""
  fname: FindOperatorDto

  """Last name of the user."""
  lname: FindOperatorDto

  """Middle name of the user."""
  mname: FindOperatorDto

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: FindOperatorDto

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: FindOperatorDto

  """Primary mobile country code of the user."""
  primary_mobile_cc: FindOperatorDto

  """Used to reset password."""
  recovery_email: FindOperatorDto

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: FindOperatorDto

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: FindOperatorDto

  """Provide whatsapp of the user."""
  whatsapp: FindOperatorDto

  """Whatsapp country code of the user."""
  whatsapp_cc: FindOperatorDto

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: FindOperatorDto

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: FindOperatorDto

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: FindOperatorDto

  """Date time when user is created."""
  created: FindOperatorDto

  """Date time when user is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User auth info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceFindInputWhere!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """User personal info of the user."""
  fr_user_personal_info: [UserPersonalInfoFindInputWhere!]

  """User address of the user."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyFindInputWhere!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User files."""
  fr_user_files: [UserFileFindInputWhere!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsFindInputWhere!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsFindInputWhere!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappFindInputWhere!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappFindInputWhere!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailFindInputWhere!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailFindInputWhere!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailFindInputWhere!]

  """connection source for this user."""
  fr_connection_source: [ConnectionSourceFindInputWhere!]
}

type UserRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records recovered for the recover query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserEntity!]
}

input UserRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserRemoveInputWhere!]
}

input UserRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: FindOperatorDto

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: FindOperatorDto

  """Connection source ID."""
  connsrc_id: FindOperatorDto

  """First name of the user."""
  fname: FindOperatorDto

  """Last name of the user."""
  lname: FindOperatorDto

  """Middle name of the user."""
  mname: FindOperatorDto

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: FindOperatorDto

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: FindOperatorDto

  """Primary mobile country code of the user."""
  primary_mobile_cc: FindOperatorDto

  """Used to reset password."""
  recovery_email: FindOperatorDto

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: FindOperatorDto

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: FindOperatorDto

  """Provide whatsapp of the user."""
  whatsapp: FindOperatorDto

  """Whatsapp country code of the user."""
  whatsapp_cc: FindOperatorDto

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: FindOperatorDto

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: FindOperatorDto

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: FindOperatorDto

  """Date time when user is created."""
  created: FindOperatorDto

  """Date time when user is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User auth info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceFindInputWhere!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """User personal info of the user."""
  fr_user_personal_info: [UserPersonalInfoFindInputWhere!]

  """User address of the user."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyFindInputWhere!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User files."""
  fr_user_files: [UserFileFindInputWhere!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsFindInputWhere!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsFindInputWhere!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappFindInputWhere!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappFindInputWhere!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailFindInputWhere!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailFindInputWhere!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailFindInputWhere!]

  """connection source for this user."""
  fr_connection_source: [ConnectionSourceFindInputWhere!]
}

type UserRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records removed for the remove query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserEntity!]
}

input UserRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserRestoreInputWhere!]
}

input UserRestoreInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: FindOperatorDto

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: FindOperatorDto

  """Connection source ID."""
  connsrc_id: FindOperatorDto

  """First name of the user."""
  fname: FindOperatorDto

  """Last name of the user."""
  lname: FindOperatorDto

  """Middle name of the user."""
  mname: FindOperatorDto

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: FindOperatorDto

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: FindOperatorDto

  """Primary mobile country code of the user."""
  primary_mobile_cc: FindOperatorDto

  """Used to reset password."""
  recovery_email: FindOperatorDto

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: FindOperatorDto

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: FindOperatorDto

  """Provide whatsapp of the user."""
  whatsapp: FindOperatorDto

  """Whatsapp country code of the user."""
  whatsapp_cc: FindOperatorDto

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: FindOperatorDto

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: FindOperatorDto

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: FindOperatorDto

  """Date time when user is created."""
  created: FindOperatorDto

  """Date time when user is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User auth info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceFindInputWhere!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """User personal info of the user."""
  fr_user_personal_info: [UserPersonalInfoFindInputWhere!]

  """User address of the user."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyFindInputWhere!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User files."""
  fr_user_files: [UserFileFindInputWhere!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsFindInputWhere!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsFindInputWhere!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappFindInputWhere!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappFindInputWhere!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailFindInputWhere!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailFindInputWhere!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailFindInputWhere!]

  """connection source for this user."""
  fr_connection_source: [ConnectionSourceFindInputWhere!]
}

type UserRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserSavedSearchCreateInput {
  """User Id of the user saved search."""
  u_id: Int!

  """Title of the user saved search."""
  title: String!

  """Url slug of the user saved search."""
  url_slug: String

  """Criteria of the user saved search."""
  criteria: String!

  """Result count of the user saved search."""
  result_count: Int!

  """Alert type of the user saved search."""
  alertdur_id: Int!

  """Alert last sent of the user saved search."""
  alert_last_sent: DateTime

  """Listing last updated of the user saved search."""
  listing_last_updated: DateTime!

  """Created User ID of the user saved search."""
  created_u_id: Int

  """Created AR ID of the user saved search."""
  created_ar_id: Int
}

type UserSavedSearchCreateOutput {
  """Unique ID of the user saved search, auto generated."""
  id: Int

  """User Id of the user saved search."""
  u_id: Int

  """Title of the user saved search."""
  title: String

  """Url slug of the user saved search."""
  url_slug: String

  """Criteria of the user saved search."""
  criteria: String

  """Result count of the user saved search."""
  result_count: Int

  """Alert type of the user saved search."""
  alertdur_id: Int

  """Criteria of the user saved search."""
  alert_last_sent: DateTime

  """Listing last updated of the user saved search."""
  listing_last_updated: DateTime

  """Created User ID of the user saved search."""
  created_u_id: Int

  """Created AR ID of the user saved search."""
  created_ar_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Users of the user save search."""
  fr_users: UserEntity

  """Created user of the user save search."""
  fr_created_user: UserEntity

  """Alert duration of the user save search."""
  fr_alert_duration: AlertDurationEntity

  """Created auth role of the user save search."""
  fr_created_authorisation: AuthorisationEntity
}

input UserSavedSearchDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserSavedSearchDeleteInputWhere!]
}

input UserSavedSearchDeleteInputWhere {
  """Unique ID of the user saved search, auto generated."""
  id: FindOperatorDto

  """User Id of the user saved search."""
  u_id: FindOperatorDto

  """Title of the user saved search."""
  title: FindOperatorDto

  """Alert type of the user saved search."""
  alertdur_id: FindOperatorDto

  """Created User ID of the user saved search."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user saved search."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type UserSavedSearchDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type UserSavedSearchEntity {
  """Unique ID of the user saved search, auto generated."""
  id: Int

  """User Id of the user saved search."""
  u_id: Int

  """Title of the user saved search."""
  title: String

  """Url slug of the user saved search."""
  url_slug: String

  """Criteria of the user saved search."""
  criteria: String

  """Result count of the user saved search."""
  result_count: Int

  """Alert type of the user saved search."""
  alertdur_id: Int

  """Criteria of the user saved search."""
  alert_last_sent: DateTime

  """Listing last updated of the user saved search."""
  listing_last_updated: DateTime

  """Created User ID of the user saved search."""
  created_u_id: Int

  """Created AR ID of the user saved search."""
  created_ar_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Users of the user save search."""
  fr_users: UserEntity

  """Created user of the user save search."""
  fr_created_user: UserEntity

  """Alert duration of the user save search."""
  fr_alert_duration: AlertDurationEntity

  """Created auth role of the user save search."""
  fr_created_authorisation: AuthorisationEntity
}

input UserSavedSearchFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserSavedSearchFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: UserSavedSearchFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: UserSavedSearchFindInputSortOrder
}

input UserSavedSearchFindInputGroupBy {
  u_id: Boolean
  title: Boolean
  alertdur_id: Boolean
  created_u_id: Boolean
  created_ar_id: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input UserSavedSearchFindInputSortOrder {
  id: RecordSortDirectionEnum
  u_id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  alertdur_id: RecordSortDirectionEnum
  created_u_id: RecordSortDirectionEnum
  created_ar_id: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input UserSavedSearchFindInputWhere {
  """Unique ID of the user saved search, auto generated."""
  id: FindOperatorDto

  """User Id of the user saved search."""
  u_id: FindOperatorDto

  """Title of the user saved search."""
  title: FindOperatorDto

  """Alert type of the user saved search."""
  alertdur_id: FindOperatorDto

  """Created User ID of the user saved search."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user saved search."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

input UserSavedSearchFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type UserSavedSearchFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [UserSavedSearchEntity!]!
}

input UserSavedSearchRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserSavedSearchRecoverInputWhere!]
}

input UserSavedSearchRecoverInputWhere {
  """Unique ID of the user saved search, auto generated."""
  id: FindOperatorDto

  """User Id of the user saved search."""
  u_id: FindOperatorDto

  """Title of the user saved search."""
  title: FindOperatorDto

  """Alert type of the user saved search."""
  alertdur_id: FindOperatorDto

  """Created User ID of the user saved search."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user saved search."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type UserSavedSearchRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserSavedSearchEntity!]!
}

input UserSavedSearchRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserSavedSearchRemoveInputWhere!]
}

input UserSavedSearchRemoveInputWhere {
  """Unique ID of the user saved search, auto generated."""
  id: FindOperatorDto

  """User Id of the user saved search."""
  u_id: FindOperatorDto

  """Title of the user saved search."""
  title: FindOperatorDto

  """Alert type of the user saved search."""
  alertdur_id: FindOperatorDto

  """Created User ID of the user saved search."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user saved search."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type UserSavedSearchRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserSavedSearchEntity!]!
}

input UserSavedSearchRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserSavedSearchRestoreInputWhere!]
}

input UserSavedSearchRestoreInputWhere {
  """Unique ID of the user saved search, auto generated."""
  id: FindOperatorDto

  """User Id of the user saved search."""
  u_id: FindOperatorDto

  """Title of the user saved search."""
  title: FindOperatorDto

  """Alert type of the user saved search."""
  alertdur_id: FindOperatorDto

  """Created User ID of the user saved search."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user saved search."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type UserSavedSearchRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserSavedSearchSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserSavedSearchSoftDeleteInputWhere!]
}

input UserSavedSearchSoftDeleteInputWhere {
  """Unique ID of the user saved search, auto generated."""
  id: FindOperatorDto

  """User Id of the user saved search."""
  u_id: FindOperatorDto

  """Title of the user saved search."""
  title: FindOperatorDto

  """Alert type of the user saved search."""
  alertdur_id: FindOperatorDto

  """Created User ID of the user saved search."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user saved search."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type UserSavedSearchSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserSavedSearchSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserSavedSearchSoftRemoveInputWhere!]
}

input UserSavedSearchSoftRemoveInputWhere {
  """Unique ID of the user saved search, auto generated."""
  id: FindOperatorDto

  """User Id of the user saved search."""
  u_id: FindOperatorDto

  """Title of the user saved search."""
  title: FindOperatorDto

  """Alert type of the user saved search."""
  alertdur_id: FindOperatorDto

  """Created User ID of the user saved search."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user saved search."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type UserSavedSearchSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [UserSavedSearchEntity!]!
}

input UserSavedSearchUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserSavedSearchUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserSavedSearchUpdateInputSets!
}

input UserSavedSearchUpdateInputSets {
  """User Id of the user saved search."""
  u_id: Int

  """Title of the user saved search."""
  title: String

  """Url slug of the user saved search."""
  url_slug: String

  """Criteria of the user saved search."""
  criteria: String

  """Result count of the user saved search."""
  result_count: Int

  """Alert type of the user saved search."""
  alertdur_id: Int

  """Alert last sent of the user saved search."""
  alert_last_sent: DateTime

  """Listing last updated of the user saved search."""
  listing_last_updated: DateTime

  """Created User ID of the user saved search."""
  created_u_id: Int

  """Created AR ID of the user saved search."""
  created_ar_id: Int
}

input UserSavedSearchUpdateInputWhere {
  """Unique ID of the user saved search, auto generated."""
  id: FindOperatorDto

  """User Id of the user saved search."""
  u_id: FindOperatorDto

  """Title of the user saved search."""
  title: FindOperatorDto

  """Alert type of the user saved search."""
  alertdur_id: FindOperatorDto

  """Created User ID of the user saved search."""
  created_u_id: FindOperatorDto

  """Created AR ID of the user saved search."""
  created_ar_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto
}

type UserSavedSearchUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserSavedSearchEntity!]!
}

input UserSavedSearchUpsertInput {
  """User Id of the user saved search."""
  u_id: Int!

  """Title of the user saved search."""
  title: String!

  """Url slug of the user saved search."""
  url_slug: String

  """Criteria of the user saved search."""
  criteria: String!

  """Result count of the user saved search."""
  result_count: Int!

  """Alert type of the user saved search."""
  alertdur_id: Int!

  """Alert last sent of the user saved search."""
  alert_last_sent: DateTime

  """Listing last updated of the user saved search."""
  listing_last_updated: DateTime!

  """Created User ID of the user saved search."""
  created_u_id: Int

  """Created AR ID of the user saved search."""
  created_ar_id: Int

  """Unique ID of the user saved search, auto generated. undefined"""
  id: Int
}

type UserSavedSearchUpsertOutput {
  """Unique ID of the user saved search, auto generated."""
  id: Int

  """User Id of the user saved search."""
  u_id: Int

  """Title of the user saved search."""
  title: String

  """Url slug of the user saved search."""
  url_slug: String

  """Criteria of the user saved search."""
  criteria: String

  """Result count of the user saved search."""
  result_count: Int

  """Alert type of the user saved search."""
  alertdur_id: Int

  """Criteria of the user saved search."""
  alert_last_sent: DateTime

  """Listing last updated of the user saved search."""
  listing_last_updated: DateTime

  """Created User ID of the user saved search."""
  created_u_id: Int

  """Created AR ID of the user saved search."""
  created_ar_id: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Users of the user save search."""
  fr_users: UserEntity

  """Created user of the user save search."""
  fr_created_user: UserEntity

  """Alert duration of the user save search."""
  fr_alert_duration: AlertDurationEntity

  """Created auth role of the user save search."""
  fr_created_authorisation: AuthorisationEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input UserSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserSoftDeleteInputWhere!]
}

input UserSoftDeleteInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: FindOperatorDto

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: FindOperatorDto

  """Connection source ID."""
  connsrc_id: FindOperatorDto

  """First name of the user."""
  fname: FindOperatorDto

  """Last name of the user."""
  lname: FindOperatorDto

  """Middle name of the user."""
  mname: FindOperatorDto

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: FindOperatorDto

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: FindOperatorDto

  """Primary mobile country code of the user."""
  primary_mobile_cc: FindOperatorDto

  """Used to reset password."""
  recovery_email: FindOperatorDto

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: FindOperatorDto

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: FindOperatorDto

  """Provide whatsapp of the user."""
  whatsapp: FindOperatorDto

  """Whatsapp country code of the user."""
  whatsapp_cc: FindOperatorDto

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: FindOperatorDto

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: FindOperatorDto

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: FindOperatorDto

  """Date time when user is created."""
  created: FindOperatorDto

  """Date time when user is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User auth info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceFindInputWhere!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """User personal info of the user."""
  fr_user_personal_info: [UserPersonalInfoFindInputWhere!]

  """User address of the user."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyFindInputWhere!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User files."""
  fr_user_files: [UserFileFindInputWhere!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsFindInputWhere!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsFindInputWhere!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappFindInputWhere!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappFindInputWhere!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailFindInputWhere!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailFindInputWhere!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailFindInputWhere!]

  """connection source for this user."""
  fr_connection_source: [ConnectionSourceFindInputWhere!]
}

type UserSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input UserSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserSoftRemoveInputWhere!]
}

input UserSoftRemoveInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: FindOperatorDto

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: FindOperatorDto

  """Connection source ID."""
  connsrc_id: FindOperatorDto

  """First name of the user."""
  fname: FindOperatorDto

  """Last name of the user."""
  lname: FindOperatorDto

  """Middle name of the user."""
  mname: FindOperatorDto

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: FindOperatorDto

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: FindOperatorDto

  """Primary mobile country code of the user."""
  primary_mobile_cc: FindOperatorDto

  """Used to reset password."""
  recovery_email: FindOperatorDto

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: FindOperatorDto

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: FindOperatorDto

  """Provide whatsapp of the user."""
  whatsapp: FindOperatorDto

  """Whatsapp country code of the user."""
  whatsapp_cc: FindOperatorDto

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: FindOperatorDto

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: FindOperatorDto

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: FindOperatorDto

  """Date time when user is created."""
  created: FindOperatorDto

  """Date time when user is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User auth info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceFindInputWhere!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """User personal info of the user."""
  fr_user_personal_info: [UserPersonalInfoFindInputWhere!]

  """User address of the user."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyFindInputWhere!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User files."""
  fr_user_files: [UserFileFindInputWhere!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsFindInputWhere!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsFindInputWhere!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappFindInputWhere!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappFindInputWhere!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailFindInputWhere!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailFindInputWhere!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailFindInputWhere!]

  """connection source for this user."""
  fr_connection_source: [ConnectionSourceFindInputWhere!]
}

type UserSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records soft removed for the soft remove query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserEntity!]
}

input UserUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [UserUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: UserUpdateInputSets!
}

input UserUpdateInputSets {
  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: String

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: String

  """Connection source ID."""
  connsrc_id: Int

  """First name of the user."""
  fname: String

  """Last name of the user."""
  lname: String

  """Middle name of the user."""
  mname: String

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: String

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: String

  """Primary mobile country code of the user."""
  primary_mobile_cc: String

  """Used to reset password."""
  recovery_email: String

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: String

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: String

  """Provide whatsapp of the user."""
  whatsapp: String

  """Whatsapp country code of the user."""
  whatsapp_cc: String

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: YesNoEnum
}

input UserUpdateInputWhere {
  """Unique ID of the entity, auto generated."""
  id: FindOperatorDto

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: FindOperatorDto

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: FindOperatorDto

  """Connection source ID."""
  connsrc_id: FindOperatorDto

  """First name of the user."""
  fname: FindOperatorDto

  """Last name of the user."""
  lname: FindOperatorDto

  """Middle name of the user."""
  mname: FindOperatorDto

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: FindOperatorDto

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: FindOperatorDto

  """Primary mobile country code of the user."""
  primary_mobile_cc: FindOperatorDto

  """Used to reset password."""
  recovery_email: FindOperatorDto

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: FindOperatorDto

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: FindOperatorDto

  """Provide whatsapp of the user."""
  whatsapp: FindOperatorDto

  """Whatsapp country code of the user."""
  whatsapp_cc: FindOperatorDto

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: FindOperatorDto

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: FindOperatorDto

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: FindOperatorDto

  """Date time when user is created."""
  created: FindOperatorDto

  """Date time when user is updated."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """User auth info of the user."""
  fr_user_auth: [UserAuthenticationFindInputWhere!]

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationFindInputWhere!]

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceFindInputWhere!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoFindInputWhere!]

  """User personal info of the user."""
  fr_user_personal_info: [UserPersonalInfoFindInputWhere!]

  """User address of the user."""
  fr_user_addresses: [UserAddressFindInputWhere!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardFindInputWhere!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyFindInputWhere!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyFindInputWhere!]

  """User files."""
  fr_user_files: [UserFileFindInputWhere!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsFindInputWhere!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsFindInputWhere!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappFindInputWhere!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappFindInputWhere!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailFindInputWhere!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailFindInputWhere!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailFindInputWhere!]

  """connection source for this user."""
  fr_connection_source: [ConnectionSourceFindInputWhere!]
}

type UserUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [UserEntity!]
}

input UserUploadDeleteInput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserUploadFileFieldEnum!

  """Please enter record reference id for uploaded file."""
  ref_id: String!

  """
  Please enter record id for uploaded file, this is optional but in some case when entity has single file upload and also has enternal relation id is must.
  """
  id: String

  """
  When file delete is performed and file is inside a folder of record id and during delete, if all files are deleted, means folder is empty, then also remove record id folder.
  """
  rmdir_record: Boolean! = false
}

type UserUploadDeleteOutput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserUploadFileFieldEnum

  """Record reference id for uploaded file."""
  ref_id: String

  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  File id used to perform delete, this is a record id where file is saved.
  """
  id: String
}

"""User upload ref type enum"""
enum UserUploadFileFieldEnum {
  """
  Upload user profile photo. Only jpeg, jpg, png, svg and gif files are allowed. Maximum file size is 5 MB. Only one file is allowed to upload.
  """
  FILE_PROFILE_PHOTO

  """
  Upload user profile banner. Only jpeg, jpg, png, svg and gif files are allowed. Maximum file size is 10 MB. Only one file is allowed to upload.
  """
  FILE_PROFILE_BANNER
}

input UserUploadInput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserUploadFileFieldEnum!

  """Please enter record reference id for uploaded file."""
  ref_id: String!

  """
  Please enter record id for uploaded file, this is optional but in some case when entity has single file upload and also has enternal relation id is must.
  """
  id: String
}

type UserUploadOutput {
  """
  Upload type/field as there can be various purpose for upload and uploaded content. This is kind of category to identify which type of uploaded file it is and process accordingly.
  """
  file_field: UserUploadFileFieldEnum

  """File id on sucessfull upload, this database record id holds this file."""
  id: String

  """Record reference id for uploaded file."""
  ref_id: String

  """Uploaded file name."""
  file_name: String

  """Uploaded file access url over web."""
  access_url: UploadFileAccessUrlDto
}

input UserUpsertInput {
  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: String

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: String

  """Connection source ID."""
  connsrc_id: Int

  """First name of the user."""
  fname: String

  """Last name of the user."""
  lname: String

  """Middle name of the user."""
  mname: String

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: String

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: String

  """Primary mobile country code of the user."""
  primary_mobile_cc: String

  """Used to reset password."""
  recovery_email: String

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: String

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: String

  """Provide whatsapp of the user."""
  whatsapp: String

  """Whatsapp country code of the user."""
  whatsapp_cc: String

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: YesNoEnum!

  """Unique ID of the entity, auto generated. undefined"""
  id: Int
}

type UserUpsertOutput {
  """Unique ID of the entity, auto generated."""
  id: Int

  """
  Username of the user. Required if primary_email or primary_mobile is not provided.
  """
  username: String

  """
  Url slug of the user. Set as empty string ("") to generate automatically as per set data and to remove set to null.
  """
  url_slug: String

  """Connection source ID."""
  connsrc_id: Int

  """First name of the user."""
  fname: String

  """Last name of the user."""
  lname: String

  """Middle name of the user."""
  mname: String

  """
  Primary email of the user. Required if username or primary_mobile is not provided.
  """
  primary_email: String

  """
  Primary mobile of the user. Provide in USA mobile format. Required if username or primary_email is not provided.
  """
  primary_mobile: String

  """Primary mobile country code of the user."""
  primary_mobile_cc: String

  """Used to reset password."""
  recovery_email: EmailAddress

  """Provide in USA mobile format. Used to reset password."""
  recovery_mobile: String

  """Recovery mobile country code of the user."""
  recovery_mobile_cc: String

  """Provide whatsapp of the user."""
  whatsapp: String

  """Whatsapp country code of the user."""
  whatsapp_cc: String

  """Flag to indicate if user has two factor authentication."""
  has_two_factor_auth: YesNoEnum

  """
  Flag to indicate if primary email is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pemail_verified: DateTime

  """
  Flag to indicate if primary mobile is verified. When primary mobile is verified, date-time will be saved otherwise null to indicate not verified.
  """
  pmobile_verified: DateTime

  """
  Flag to indicate if user is verified. When record is verified, date-time will be saved otherwise null to indicate not verified.
  """
  verified: DateTime

  """
  Flag to indicate if user is suspended. When record is suspended, date-time will be saved otherwise null to indicate record is active.
  """
  suspended: DateTime

  """Date time when user is created."""
  created: DateTime

  """Date time when user is updated."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """User profile photo."""
  file_profile_photo: String

  """User profile photo url."""
  file_profile_photo_url: UploadFileAccessUrlDto

  """User profile banner."""
  file_profile_banner: String

  """User profile banner url."""
  file_profile_banner_url: UploadFileAccessUrlDto

  """User auth info of the user."""
  fr_user_auth: UserAuthenticationEntity

  """Registered devices of the user."""
  fr_user_devices: [UserDeviceEntity!]

  """User corporate info of the user."""
  fr_user_corporate_infos: [UserCorporateInfoEntity!]

  """User personal info of the user."""
  fr_user_personal_info: UserPersonalInfoEntity

  """User authorisations of the user."""
  fr_user_authorisations: [UserAuthorisationEntity!]

  """User address of the user."""
  fr_user_addresses: [UserAddressEntity!]

  """User identity card of the user."""
  fr_user_identity_cards: [UserIdentityCardEntity!]

  """Parent user hierarchy of the user."""
  fr_parent_user_hierarchies: [UserHierarchyEntity!]

  """Child user hierarchy of the user."""
  fr_child_user_hirarchies: [UserHierarchyEntity!]

  """User files."""
  fr_user_files: [UserFileEntity!]

  """Queue sms from user of the user."""
  fr_queue_sms_from_users: [QueueSmsEntity!]

  """Queue sms to user of the user."""
  fr_queue_sms_to_users: [QueueSmsEntity!]

  """Queue whatsapp msg from user of the user."""
  fr_queue_whatsapp_from_users: [QueueWhatsappEntity!]

  """Queue whatsapp msg to user of the user."""
  fr_queue_whatsapp_to_users: [QueueWhatsappEntity!]

  """Queue email from user of the user."""
  fr_queue_email_from_users: [QueueEmailEntity!]

  """Queue email to user of the user."""
  fr_queue_email_to_users: [QueueEmailEntity!]

  """Queue email u id of the user."""
  fr_queue_email_created_users: [QueueEmailEntity!]

  """Lead users."""
  fr_lead_from_users: [LeadEntity!]

  """Lead users."""
  fr_lead_to_users: [LeadEntity!]

  """News letter of this userr."""
  fr_newsletter_users: NewsLetterEntity

  """News letter schedule for this User."""
  fr_newsletter_schedule_users: NewsLetterScheduleEntity

  """Lead followup for this user."""
  fr_lead_followup_user: LeadFollowupEntity

  """Newsletter user for this user."""
  fr_news_letter_user_user: NewsLetterUserEntity

  """Newsletter subscription user for this user."""
  fr_user_newsletters_subscription: UserNewsLetterSubscriptionEntity

  """User favourites for this user."""
  fr_user_favourites: UserFavEntity

  """Buissness user."""
  fr_business_user: BusinessEntity

  """connection source for this user."""
  fr_connection_source: ConnectionSourceEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input WebhookResponseCreateInput {
  """Template ID of the webhookresponse."""
  tppltf_id: Int!

  """Response ID of the webhookresponse."""
  resp_id: String!

  """Reference ID of the webhookresponse."""
  ref_id: String!

  """Reference type of the webhookresponse."""
  ref_type: String!
}

type WebhookResponseCreateOutput {
  """Unique ID of the webhookresponse, auto generated."""
  id: Int

  """Template ID of the webhookresponse."""
  tppltf_id: Int

  """Response ID of the webhookresponse."""
  resp_id: String

  """Reference ID of the webhookresponse."""
  ref_id: String

  """Reference type of the webhookresponse."""
  ref_type: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Webhook response data."""
  fr_webhook_response_data: [WebhookResponseDataEntity!]

  """Queue sms."""
  fr_queue_sms: [QueueSmsEntity!]

  """Queue whatsapp messages."""
  fr_queue_whatsapp: [QueueWhatsappEntity!]

  """Third party platform."""
  fr_third_party_platform: ThirdPartyPlatformEntity
}

input WebhookResponseDataCreateInput {
  """Who response ID of the webhookresponse."""
  whresp_id: Int!

  """Raw data of the webhookresponse."""
  raw: JSONObject
}

type WebhookResponseDataCreateOutput {
  """Unique ID of the webhookresponse, auto generated."""
  id: Int

  """Who response ID of the webhookresponse."""
  whresp_id: Int

  """Raw data of the webhookresponse."""
  raw: JSONObject

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Webhook response."""
  fr_webhook_response: WebhookResponseEntity
}

input WebhookResponseDataDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseDataDeleteInputWhere!]
}

input WebhookResponseDataDeleteInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Who response ID of the webhookresponse."""
  whresp_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response."""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type WebhookResponseDataDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type WebhookResponseDataEntity {
  """Unique ID of the webhookresponse, auto generated."""
  id: Int

  """Who response ID of the webhookresponse."""
  whresp_id: Int

  """Raw data of the webhookresponse."""
  raw: JSONObject

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Webhook response."""
  fr_webhook_response: WebhookResponseEntity
}

input WebhookResponseDataFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseDataFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: WebhookResponseDataFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: WebhookResponseDataFindInputSortOrder
}

input WebhookResponseDataFindInputGroupBy {
  whresp_id: Boolean
  created: Boolean
  deleted: Boolean
}

input WebhookResponseDataFindInputSortOrder {
  id: RecordSortDirectionEnum
  whresp_id: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input WebhookResponseDataFindInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Who response ID of the webhookresponse."""
  whresp_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response."""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

input WebhookResponseDataFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type WebhookResponseDataFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [WebhookResponseDataEntity!]!
}

input WebhookResponseDataRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseDataRecoverInputWhere!]
}

input WebhookResponseDataRecoverInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Who response ID of the webhookresponse."""
  whresp_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response."""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type WebhookResponseDataRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebhookResponseDataEntity!]!
}

input WebhookResponseDataRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseDataRemoveInputWhere!]
}

input WebhookResponseDataRemoveInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Who response ID of the webhookresponse."""
  whresp_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response."""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type WebhookResponseDataRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebhookResponseDataEntity!]!
}

input WebhookResponseDataRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseDataRestoreInputWhere!]
}

input WebhookResponseDataRestoreInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Who response ID of the webhookresponse."""
  whresp_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response."""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type WebhookResponseDataRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input WebhookResponseDataSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseDataSoftDeleteInputWhere!]
}

input WebhookResponseDataSoftDeleteInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Who response ID of the webhookresponse."""
  whresp_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response."""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type WebhookResponseDataSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input WebhookResponseDataSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseDataSoftRemoveInputWhere!]
}

input WebhookResponseDataSoftRemoveInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Who response ID of the webhookresponse."""
  whresp_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response."""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type WebhookResponseDataSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebhookResponseDataEntity!]!
}

input WebhookResponseDataUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseDataUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: WebhookResponseDataUpdateInputSets!
}

input WebhookResponseDataUpdateInputSets {
  """Who response ID of the webhookresponse."""
  whresp_id: Int

  """Raw data of the webhookresponse."""
  raw: JSONObject
}

input WebhookResponseDataUpdateInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Who response ID of the webhookresponse."""
  whresp_id: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response."""
  fr_webhook_response: [WebhookResponseFindInputWhere!]
}

type WebhookResponseDataUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [WebhookResponseDataEntity!]!
}

input WebhookResponseDataUpsertInput {
  """Who response ID of the webhookresponse."""
  whresp_id: Int!

  """Raw data of the webhookresponse."""
  raw: JSONObject

  """Unique ID of the webhookresponse, auto generated. undefined"""
  id: Int
}

type WebhookResponseDataUpsertOutput {
  """Unique ID of the webhookresponse, auto generated."""
  id: Int

  """Who response ID of the webhookresponse."""
  whresp_id: Int

  """Raw data of the webhookresponse."""
  raw: JSONObject

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Webhook response."""
  fr_webhook_response: WebhookResponseEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input WebhookResponseDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseDeleteInputWhere!]
}

input WebhookResponseDeleteInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Template ID of the webhookresponse."""
  tppltf_id: FindOperatorDto

  """Response ID of the webhookresponse."""
  resp_id: FindOperatorDto

  """Reference ID of the webhookresponse."""
  ref_id: FindOperatorDto

  """Reference type of the webhookresponse."""
  ref_type: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response data."""
  fr_webhook_response_data: [WebhookResponseDataFindInputWhere!]

  """Queue sms."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Queue whatsapp messages."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Third party platform."""
  fr_third_party_platform: [ThirdPartyPlatformFindInputWhere!]
}

type WebhookResponseDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type WebhookResponseEntity {
  """Unique ID of the webhookresponse, auto generated."""
  id: Int

  """Template ID of the webhookresponse."""
  tppltf_id: Int

  """Response ID of the webhookresponse."""
  resp_id: String

  """Reference ID of the webhookresponse."""
  ref_id: String

  """Reference type of the webhookresponse."""
  ref_type: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Webhook response data."""
  fr_webhook_response_data: [WebhookResponseDataEntity!]

  """Queue sms."""
  fr_queue_sms: [QueueSmsEntity!]

  """Queue whatsapp messages."""
  fr_queue_whatsapp: [QueueWhatsappEntity!]

  """Third party platform."""
  fr_third_party_platform: ThirdPartyPlatformEntity
}

input WebhookResponseFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: WebhookResponseFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: WebhookResponseFindInputSortOrder
}

input WebhookResponseFindInputGroupBy {
  tppltf_id: Boolean
  ref_id: Boolean
  ref_type: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input WebhookResponseFindInputSortOrder {
  id: RecordSortDirectionEnum
  tppltf_id: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input WebhookResponseFindInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Template ID of the webhookresponse."""
  tppltf_id: FindOperatorDto

  """Response ID of the webhookresponse."""
  resp_id: FindOperatorDto

  """Reference ID of the webhookresponse."""
  ref_id: FindOperatorDto

  """Reference type of the webhookresponse."""
  ref_type: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response data."""
  fr_webhook_response_data: [WebhookResponseDataFindInputWhere!]

  """Queue sms."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Queue whatsapp messages."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Third party platform."""
  fr_third_party_platform: [ThirdPartyPlatformFindInputWhere!]
}

input WebhookResponseFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type WebhookResponseFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [WebhookResponseEntity!]!
}

input WebhookResponseRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseRecoverInputWhere!]
}

input WebhookResponseRecoverInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Template ID of the webhookresponse."""
  tppltf_id: FindOperatorDto

  """Response ID of the webhookresponse."""
  resp_id: FindOperatorDto

  """Reference ID of the webhookresponse."""
  ref_id: FindOperatorDto

  """Reference type of the webhookresponse."""
  ref_type: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response data."""
  fr_webhook_response_data: [WebhookResponseDataFindInputWhere!]

  """Queue sms."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Queue whatsapp messages."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Third party platform."""
  fr_third_party_platform: [ThirdPartyPlatformFindInputWhere!]
}

type WebhookResponseRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebhookResponseEntity!]!
}

input WebhookResponseRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseRemoveInputWhere!]
}

input WebhookResponseRemoveInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Template ID of the webhookresponse."""
  tppltf_id: FindOperatorDto

  """Response ID of the webhookresponse."""
  resp_id: FindOperatorDto

  """Reference ID of the webhookresponse."""
  ref_id: FindOperatorDto

  """Reference type of the webhookresponse."""
  ref_type: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response data."""
  fr_webhook_response_data: [WebhookResponseDataFindInputWhere!]

  """Queue sms."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Queue whatsapp messages."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Third party platform."""
  fr_third_party_platform: [ThirdPartyPlatformFindInputWhere!]
}

type WebhookResponseRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebhookResponseEntity!]!
}

input WebhookResponseRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseRestoreInputWhere!]
}

input WebhookResponseRestoreInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Template ID of the webhookresponse."""
  tppltf_id: FindOperatorDto

  """Response ID of the webhookresponse."""
  resp_id: FindOperatorDto

  """Reference ID of the webhookresponse."""
  ref_id: FindOperatorDto

  """Reference type of the webhookresponse."""
  ref_type: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response data."""
  fr_webhook_response_data: [WebhookResponseDataFindInputWhere!]

  """Queue sms."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Queue whatsapp messages."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Third party platform."""
  fr_third_party_platform: [ThirdPartyPlatformFindInputWhere!]
}

type WebhookResponseRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input WebhookResponseSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseSoftDeleteInputWhere!]
}

input WebhookResponseSoftDeleteInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Template ID of the webhookresponse."""
  tppltf_id: FindOperatorDto

  """Response ID of the webhookresponse."""
  resp_id: FindOperatorDto

  """Reference ID of the webhookresponse."""
  ref_id: FindOperatorDto

  """Reference type of the webhookresponse."""
  ref_type: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response data."""
  fr_webhook_response_data: [WebhookResponseDataFindInputWhere!]

  """Queue sms."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Queue whatsapp messages."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Third party platform."""
  fr_third_party_platform: [ThirdPartyPlatformFindInputWhere!]
}

type WebhookResponseSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input WebhookResponseSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseSoftRemoveInputWhere!]
}

input WebhookResponseSoftRemoveInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Template ID of the webhookresponse."""
  tppltf_id: FindOperatorDto

  """Response ID of the webhookresponse."""
  resp_id: FindOperatorDto

  """Reference ID of the webhookresponse."""
  ref_id: FindOperatorDto

  """Reference type of the webhookresponse."""
  ref_type: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response data."""
  fr_webhook_response_data: [WebhookResponseDataFindInputWhere!]

  """Queue sms."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Queue whatsapp messages."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Third party platform."""
  fr_third_party_platform: [ThirdPartyPlatformFindInputWhere!]
}

type WebhookResponseSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebhookResponseEntity!]!
}

input WebhookResponseUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebhookResponseUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: WebhookResponseUpdateInputSets!
}

input WebhookResponseUpdateInputSets {
  """Template ID of the webhookresponse."""
  tppltf_id: Int

  """Response ID of the webhookresponse."""
  resp_id: String

  """Reference ID of the webhookresponse."""
  ref_id: String

  """Reference type of the webhookresponse."""
  ref_type: String
}

input WebhookResponseUpdateInputWhere {
  """Unique ID of the webhookresponse, auto generated."""
  id: FindOperatorDto

  """Template ID of the webhookresponse."""
  tppltf_id: FindOperatorDto

  """Response ID of the webhookresponse."""
  resp_id: FindOperatorDto

  """Reference ID of the webhookresponse."""
  ref_id: FindOperatorDto

  """Reference type of the webhookresponse."""
  ref_type: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Webhook response data."""
  fr_webhook_response_data: [WebhookResponseDataFindInputWhere!]

  """Queue sms."""
  fr_queue_sms: [QueueSmsFindInputWhere!]

  """Queue whatsapp messages."""
  fr_queue_whatsapp: [QueueWhatsappFindInputWhere!]

  """Third party platform."""
  fr_third_party_platform: [ThirdPartyPlatformFindInputWhere!]
}

type WebhookResponseUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [WebhookResponseEntity!]!
}

input WebhookResponseUpsertInput {
  """Template ID of the webhookresponse."""
  tppltf_id: Int!

  """Response ID of the webhookresponse."""
  resp_id: String!

  """Reference ID of the webhookresponse."""
  ref_id: String!

  """Reference type of the webhookresponse."""
  ref_type: String!

  """Unique ID of the webhookresponse, auto generated. undefined"""
  id: Int
}

type WebhookResponseUpsertOutput {
  """Unique ID of the webhookresponse, auto generated."""
  id: Int

  """Template ID of the webhookresponse."""
  tppltf_id: Int

  """Response ID of the webhookresponse."""
  resp_id: String

  """Reference ID of the webhookresponse."""
  ref_id: String

  """Reference type of the webhookresponse."""
  ref_type: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """
  If record is updated, then date time value will be saved otherwise null to indicate record is not updated.
  """
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Webhook response data."""
  fr_webhook_response_data: [WebhookResponseDataEntity!]

  """Queue sms."""
  fr_queue_sms: [QueueSmsEntity!]

  """Queue whatsapp messages."""
  fr_queue_whatsapp: [QueueWhatsappEntity!]

  """Third party platform."""
  fr_third_party_platform: ThirdPartyPlatformEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input WebPageHierarchyCreateInput {
  """Parent page id of the web page hierarchy."""
  parent_page_id: Int!

  """Child page Id of the web page hierarchy."""
  child_page_id: Int!

  """Order of the web page hierarchy."""
  order: Int
}

type WebPageHierarchyCreateOutput {
  """Unique ID of the web page hierarchy, auto generated."""
  id: Int

  """Parent page id of the web page hierarchy."""
  parent_page_id: Int

  """Child page Id of the web page hierarchy."""
  child_page_id: Int

  """Order of the web page hierarchy."""
  order: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Parent page of the web page hierarchy."""
  fr_parent_pages: WebPageMasterEntity

  """Child page of the web page hierarchy."""
  fr_child_pages: WebPageMasterEntity
}

input WebPageHierarchyDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageHierarchyDeleteInputWhere!]
}

input WebPageHierarchyDeleteInputWhere {
  """Unique ID of the web page hierarchy, auto generated."""
  id: FindOperatorDto

  """Parent page id of the web page hierarchy."""
  parent_page_id: FindOperatorDto

  """Child page Id of the web page hierarchy."""
  child_page_id: FindOperatorDto

  """Order of the web page hierarchy."""
  order: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of the web page hierarchy."""
  fr_parent_pages: [WebPageMasterFindInputWhere!]

  """Child page of the web page hierarchy."""
  fr_child_pages: [WebPageMasterFindInputWhere!]
}

type WebPageHierarchyDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type WebPageHierarchyEntity {
  """Unique ID of the web page hierarchy, auto generated."""
  id: Int

  """Parent page id of the web page hierarchy."""
  parent_page_id: Int

  """Child page Id of the web page hierarchy."""
  child_page_id: Int

  """Order of the web page hierarchy."""
  order: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Parent page of the web page hierarchy."""
  fr_parent_pages: WebPageMasterEntity

  """Child page of the web page hierarchy."""
  fr_child_pages: WebPageMasterEntity
}

input WebPageHierarchyFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageHierarchyFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: WebPageHierarchyFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: WebPageHierarchyFindInputSortOrder
}

input WebPageHierarchyFindInputGroupBy {
  parent_page_id: Boolean
  child_page_id: Boolean
  order: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input WebPageHierarchyFindInputSortOrder {
  id: RecordSortDirectionEnum
  parent_page_id: RecordSortDirectionEnum
  child_page_id: RecordSortDirectionEnum
  order: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input WebPageHierarchyFindInputWhere {
  """Unique ID of the web page hierarchy, auto generated."""
  id: FindOperatorDto

  """Parent page id of the web page hierarchy."""
  parent_page_id: FindOperatorDto

  """Child page Id of the web page hierarchy."""
  child_page_id: FindOperatorDto

  """Order of the web page hierarchy."""
  order: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of the web page hierarchy."""
  fr_parent_pages: [WebPageMasterFindInputWhere!]

  """Child page of the web page hierarchy."""
  fr_child_pages: [WebPageMasterFindInputWhere!]
}

input WebPageHierarchyFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type WebPageHierarchyFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [WebPageHierarchyEntity!]!
}

input WebPageHierarchyRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageHierarchyRecoverInputWhere!]
}

input WebPageHierarchyRecoverInputWhere {
  """Unique ID of the web page hierarchy, auto generated."""
  id: FindOperatorDto

  """Parent page id of the web page hierarchy."""
  parent_page_id: FindOperatorDto

  """Child page Id of the web page hierarchy."""
  child_page_id: FindOperatorDto

  """Order of the web page hierarchy."""
  order: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of the web page hierarchy."""
  fr_parent_pages: [WebPageMasterFindInputWhere!]

  """Child page of the web page hierarchy."""
  fr_child_pages: [WebPageMasterFindInputWhere!]
}

type WebPageHierarchyRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebPageHierarchyEntity!]!
}

input WebPageHierarchyRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageHierarchyRemoveInputWhere!]
}

input WebPageHierarchyRemoveInputWhere {
  """Unique ID of the web page hierarchy, auto generated."""
  id: FindOperatorDto

  """Parent page id of the web page hierarchy."""
  parent_page_id: FindOperatorDto

  """Child page Id of the web page hierarchy."""
  child_page_id: FindOperatorDto

  """Order of the web page hierarchy."""
  order: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of the web page hierarchy."""
  fr_parent_pages: [WebPageMasterFindInputWhere!]

  """Child page of the web page hierarchy."""
  fr_child_pages: [WebPageMasterFindInputWhere!]
}

type WebPageHierarchyRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebPageHierarchyEntity!]!
}

input WebPageHierarchyRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageHierarchyRestoreInputWhere!]
}

input WebPageHierarchyRestoreInputWhere {
  """Unique ID of the web page hierarchy, auto generated."""
  id: FindOperatorDto

  """Parent page id of the web page hierarchy."""
  parent_page_id: FindOperatorDto

  """Child page Id of the web page hierarchy."""
  child_page_id: FindOperatorDto

  """Order of the web page hierarchy."""
  order: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of the web page hierarchy."""
  fr_parent_pages: [WebPageMasterFindInputWhere!]

  """Child page of the web page hierarchy."""
  fr_child_pages: [WebPageMasterFindInputWhere!]
}

type WebPageHierarchyRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input WebPageHierarchySoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageHierarchySoftDeleteInputWhere!]
}

input WebPageHierarchySoftDeleteInputWhere {
  """Unique ID of the web page hierarchy, auto generated."""
  id: FindOperatorDto

  """Parent page id of the web page hierarchy."""
  parent_page_id: FindOperatorDto

  """Child page Id of the web page hierarchy."""
  child_page_id: FindOperatorDto

  """Order of the web page hierarchy."""
  order: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of the web page hierarchy."""
  fr_parent_pages: [WebPageMasterFindInputWhere!]

  """Child page of the web page hierarchy."""
  fr_child_pages: [WebPageMasterFindInputWhere!]
}

type WebPageHierarchySoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input WebPageHierarchySoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageHierarchySoftRemoveInputWhere!]
}

input WebPageHierarchySoftRemoveInputWhere {
  """Unique ID of the web page hierarchy, auto generated."""
  id: FindOperatorDto

  """Parent page id of the web page hierarchy."""
  parent_page_id: FindOperatorDto

  """Child page Id of the web page hierarchy."""
  child_page_id: FindOperatorDto

  """Order of the web page hierarchy."""
  order: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of the web page hierarchy."""
  fr_parent_pages: [WebPageMasterFindInputWhere!]

  """Child page of the web page hierarchy."""
  fr_child_pages: [WebPageMasterFindInputWhere!]
}

type WebPageHierarchySoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebPageHierarchyEntity!]!
}

input WebPageHierarchyUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageHierarchyUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: WebPageHierarchyUpdateInputSets!
}

input WebPageHierarchyUpdateInputSets {
  """Parent page id of the web page hierarchy."""
  parent_page_id: Int

  """Child page Id of the web page hierarchy."""
  child_page_id: Int

  """Order of the web page hierarchy."""
  order: Int
}

input WebPageHierarchyUpdateInputWhere {
  """Unique ID of the web page hierarchy, auto generated."""
  id: FindOperatorDto

  """Parent page id of the web page hierarchy."""
  parent_page_id: FindOperatorDto

  """Child page Id of the web page hierarchy."""
  child_page_id: FindOperatorDto

  """Order of the web page hierarchy."""
  order: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of the web page hierarchy."""
  fr_parent_pages: [WebPageMasterFindInputWhere!]

  """Child page of the web page hierarchy."""
  fr_child_pages: [WebPageMasterFindInputWhere!]
}

type WebPageHierarchyUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [WebPageHierarchyEntity!]!
}

input WebPageHierarchyUpsertInput {
  """Parent page id of the web page hierarchy."""
  parent_page_id: Int!

  """Child page Id of the web page hierarchy."""
  child_page_id: Int!

  """Order of the web page hierarchy."""
  order: Int

  """Unique ID of the web page hierarchy, auto generated. undefined"""
  id: Int
}

type WebPageHierarchyUpsertOutput {
  """Unique ID of the web page hierarchy, auto generated."""
  id: Int

  """Parent page id of the web page hierarchy."""
  parent_page_id: Int

  """Child page Id of the web page hierarchy."""
  child_page_id: Int

  """Order of the web page hierarchy."""
  order: Int

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Parent page of the web page hierarchy."""
  fr_parent_pages: WebPageMasterEntity

  """Child page of the web page hierarchy."""
  fr_child_pages: WebPageMasterEntity

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input WebPageMasterCreateInput {
  """Title of the web page master."""
  title: String!

  """Url slug of the web page master."""
  url_slug: String

  """Position of the web page master."""
  position: positionEnum!

  """Type of the web page master."""
  type: pgTypeEnum

  """Content of the web page master."""
  content: String!

  """Browser title of the web page master."""
  browser_title: String!

  """Meta keyword of the pagemaster."""
  meta_keyword: String!

  """Meta description of the web page master."""
  meta_desc: String!

  """Visible of the web page master."""
  active: DateTime
}

type WebPageMasterCreateOutput {
  """Unique ID of the webpagemaster, auto generated."""
  id: Int

  """Title of the web page master."""
  title: String

  """Url slug of the web page master."""
  url_slug: String

  """Position of the web page master."""
  position: positionEnum

  """Type of the web page master."""
  type: pgTypeEnum

  """Content of the web page master."""
  content: String

  """Browser title of the web page master."""
  browser_title: String

  """Meta keyword of the pagemaster."""
  meta_keyword: String

  """Meta description of the web page master."""
  meta_desc: String

  """Visible of the web page master."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Parent page of web page master."""
  fr_parent_page: [WebPageHierarchyEntity!]

  """Child page of web page master."""
  fr_child_page: [WebPageHierarchyEntity!]
}

input WebPageMasterDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageMasterDeleteInputWhere!]
}

input WebPageMasterDeleteInputWhere {
  """Unique ID of the webpagemaster, auto generated."""
  id: FindOperatorDto

  """Title of the web page master."""
  title: FindOperatorDto

  """Url slug of the web page master."""
  url_slug: FindOperatorDto

  """Position of the web page master."""
  position: FindOperatorDto

  """Type of the web page master."""
  type: FindOperatorDto

  """Visible of the web page master."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of web page master."""
  fr_parent_page: [WebPageHierarchyFindInputWhere!]

  """Child page of web page master."""
  fr_child_page: [WebPageHierarchyFindInputWhere!]
}

type WebPageMasterDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type WebPageMasterEntity {
  """Unique ID of the webpagemaster, auto generated."""
  id: Int

  """Title of the web page master."""
  title: String

  """Url slug of the web page master."""
  url_slug: String

  """Position of the web page master."""
  position: positionEnum

  """Type of the web page master."""
  type: pgTypeEnum

  """Content of the web page master."""
  content: String

  """Browser title of the web page master."""
  browser_title: String

  """Meta keyword of the pagemaster."""
  meta_keyword: String

  """Meta description of the web page master."""
  meta_desc: String

  """Visible of the web page master."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Parent page of web page master."""
  fr_parent_page: [WebPageHierarchyEntity!]

  """Child page of web page master."""
  fr_child_page: [WebPageHierarchyEntity!]
}

input WebPageMasterFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageMasterFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: WebPageMasterFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: WebPageMasterFindInputSortOrder
}

input WebPageMasterFindInputGroupBy {
  title: Boolean
  url_slug: Boolean
  position: Boolean
  type: Boolean
  active: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input WebPageMasterFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  url_slug: RecordSortDirectionEnum
  position: RecordSortDirectionEnum
  type: RecordSortDirectionEnum
  active: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input WebPageMasterFindInputWhere {
  """Unique ID of the webpagemaster, auto generated."""
  id: FindOperatorDto

  """Title of the web page master."""
  title: FindOperatorDto

  """Url slug of the web page master."""
  url_slug: FindOperatorDto

  """Position of the web page master."""
  position: FindOperatorDto

  """Type of the web page master."""
  type: FindOperatorDto

  """Visible of the web page master."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of web page master."""
  fr_parent_page: [WebPageHierarchyFindInputWhere!]

  """Child page of web page master."""
  fr_child_page: [WebPageHierarchyFindInputWhere!]
}

input WebPageMasterFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type WebPageMasterFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [WebPageMasterEntity!]!
}

input WebPageMasterRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageMasterRecoverInputWhere!]
}

input WebPageMasterRecoverInputWhere {
  """Unique ID of the webpagemaster, auto generated."""
  id: FindOperatorDto

  """Title of the web page master."""
  title: FindOperatorDto

  """Url slug of the web page master."""
  url_slug: FindOperatorDto

  """Position of the web page master."""
  position: FindOperatorDto

  """Type of the web page master."""
  type: FindOperatorDto

  """Visible of the web page master."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of web page master."""
  fr_parent_page: [WebPageHierarchyFindInputWhere!]

  """Child page of web page master."""
  fr_child_page: [WebPageHierarchyFindInputWhere!]
}

type WebPageMasterRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebPageMasterEntity!]!
}

input WebPageMasterRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageMasterRemoveInputWhere!]
}

input WebPageMasterRemoveInputWhere {
  """Unique ID of the webpagemaster, auto generated."""
  id: FindOperatorDto

  """Title of the web page master."""
  title: FindOperatorDto

  """Url slug of the web page master."""
  url_slug: FindOperatorDto

  """Position of the web page master."""
  position: FindOperatorDto

  """Type of the web page master."""
  type: FindOperatorDto

  """Visible of the web page master."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of web page master."""
  fr_parent_page: [WebPageHierarchyFindInputWhere!]

  """Child page of web page master."""
  fr_child_page: [WebPageHierarchyFindInputWhere!]
}

type WebPageMasterRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebPageMasterEntity!]!
}

input WebPageMasterRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageMasterRestoreInputWhere!]
}

input WebPageMasterRestoreInputWhere {
  """Unique ID of the webpagemaster, auto generated."""
  id: FindOperatorDto

  """Title of the web page master."""
  title: FindOperatorDto

  """Url slug of the web page master."""
  url_slug: FindOperatorDto

  """Position of the web page master."""
  position: FindOperatorDto

  """Type of the web page master."""
  type: FindOperatorDto

  """Visible of the web page master."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of web page master."""
  fr_parent_page: [WebPageHierarchyFindInputWhere!]

  """Child page of web page master."""
  fr_child_page: [WebPageHierarchyFindInputWhere!]
}

type WebPageMasterRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input WebPageMasterSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageMasterSoftDeleteInputWhere!]
}

input WebPageMasterSoftDeleteInputWhere {
  """Unique ID of the webpagemaster, auto generated."""
  id: FindOperatorDto

  """Title of the web page master."""
  title: FindOperatorDto

  """Url slug of the web page master."""
  url_slug: FindOperatorDto

  """Position of the web page master."""
  position: FindOperatorDto

  """Type of the web page master."""
  type: FindOperatorDto

  """Visible of the web page master."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of web page master."""
  fr_parent_page: [WebPageHierarchyFindInputWhere!]

  """Child page of web page master."""
  fr_child_page: [WebPageHierarchyFindInputWhere!]
}

type WebPageMasterSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input WebPageMasterSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageMasterSoftRemoveInputWhere!]
}

input WebPageMasterSoftRemoveInputWhere {
  """Unique ID of the webpagemaster, auto generated."""
  id: FindOperatorDto

  """Title of the web page master."""
  title: FindOperatorDto

  """Url slug of the web page master."""
  url_slug: FindOperatorDto

  """Position of the web page master."""
  position: FindOperatorDto

  """Type of the web page master."""
  type: FindOperatorDto

  """Visible of the web page master."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of web page master."""
  fr_parent_page: [WebPageHierarchyFindInputWhere!]

  """Child page of web page master."""
  fr_child_page: [WebPageHierarchyFindInputWhere!]
}

type WebPageMasterSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WebPageMasterEntity!]!
}

input WebPageMasterUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WebPageMasterUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: WebPageMasterUpdateInputSets!
}

input WebPageMasterUpdateInputSets {
  """Title of the web page master."""
  title: String

  """Url slug of the web page master."""
  url_slug: String

  """Position of the web page master."""
  position: positionEnum

  """Type of the web page master."""
  type: pgTypeEnum

  """Content of the web page master."""
  content: String

  """Browser title of the web page master."""
  browser_title: String

  """Meta keyword of the pagemaster."""
  meta_keyword: String

  """Meta description of the web page master."""
  meta_desc: String

  """Visible of the web page master."""
  active: DateTime
}

input WebPageMasterUpdateInputWhere {
  """Unique ID of the webpagemaster, auto generated."""
  id: FindOperatorDto

  """Title of the web page master."""
  title: FindOperatorDto

  """Url slug of the web page master."""
  url_slug: FindOperatorDto

  """Position of the web page master."""
  position: FindOperatorDto

  """Type of the web page master."""
  type: FindOperatorDto

  """Visible of the web page master."""
  active: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """Parent page of web page master."""
  fr_parent_page: [WebPageHierarchyFindInputWhere!]

  """Child page of web page master."""
  fr_child_page: [WebPageHierarchyFindInputWhere!]
}

type WebPageMasterUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [WebPageMasterEntity!]!
}

input WebPageMasterUpsertInput {
  """Title of the web page master."""
  title: String!

  """Url slug of the web page master."""
  url_slug: String

  """Position of the web page master."""
  position: positionEnum!

  """Type of the web page master."""
  type: pgTypeEnum

  """Content of the web page master."""
  content: String!

  """Browser title of the web page master."""
  browser_title: String!

  """Meta keyword of the pagemaster."""
  meta_keyword: String!

  """Meta description of the web page master."""
  meta_desc: String!

  """Visible of the web page master."""
  active: DateTime

  """Unique ID of the webpagemaster, auto generated. undefined"""
  id: Int
}

type WebPageMasterUpsertOutput {
  """Unique ID of the webpagemaster, auto generated."""
  id: Int

  """Title of the web page master."""
  title: String

  """Url slug of the web page master."""
  url_slug: String

  """Position of the web page master."""
  position: positionEnum

  """Type of the web page master."""
  type: pgTypeEnum

  """Content of the web page master."""
  content: String

  """Browser title of the web page master."""
  browser_title: String

  """Meta keyword of the pagemaster."""
  meta_keyword: String

  """Meta description of the web page master."""
  meta_desc: String

  """Visible of the web page master."""
  active: DateTime

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """Parent page of web page master."""
  fr_parent_page: [WebPageHierarchyEntity!]

  """Child page of web page master."""
  fr_child_page: [WebPageHierarchyEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

input WorkStatusCreateInput {
  """Title of the email template."""
  title: String!
}

type WorkStatusCreateOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """News letter user for work status."""
  fr_nl_status: [NewsLetterUserEntity!]

  """News letter user for work status."""
  fr_nl_schedule_status: [NewsLetterScheduleEntity!]

  """News letter user for work status."""
  fr_nl_schedule_approval_status: [NewsLetterScheduleEntity!]
}

input WorkStatusDeleteInput {
  """
  Where criteria for delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WorkStatusDeleteInputWhere!]
}

input WorkStatusDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """News letter user for work status."""
  fr_nl_status: [NewsLetterUserFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_status: [NewsLetterScheduleFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_approval_status: [NewsLetterScheduleFindInputWhere!]
}

type WorkStatusDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

type WorkStatusEntity {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """News letter user for work status."""
  fr_nl_status: [NewsLetterUserEntity!]

  """News letter user for work status."""
  fr_nl_schedule_status: [NewsLetterScheduleEntity!]

  """News letter user for work status."""
  fr_nl_schedule_approval_status: [NewsLetterScheduleEntity!]
}

input WorkStatusFindInput {
  """
  Default is 0. Skip N rows from the result set. Forammly known as offset.
  """
  skip: Int = 0

  """
  IGNORED if rows empty. Default limit is 25. Limit the number of rows returned in the result set. Forammly known as limit.
  """
  take: Int = 25

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false

  """
  Where criteria for find operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WorkStatusFindInputWhere!]

  """
  Group by criteria for find operation. Specifies how to group the rows returned by the SELECT statement. You can also use multiple group by criteria at once.
  """
  groupBy: WorkStatusFindInputGroupBy

  """
  Order criteria for find operation. Sort the result set by fields using ascending or descending order. You can also use multiple order criteria at once.
  """
  order: WorkStatusFindInputSortOrder
}

input WorkStatusFindInputGroupBy {
  title: Boolean
  created: Boolean
  updated: Boolean
  deleted: Boolean
}

input WorkStatusFindInputSortOrder {
  id: RecordSortDirectionEnum
  title: RecordSortDirectionEnum
  created: RecordSortDirectionEnum
  updated: RecordSortDirectionEnum
  deleted: RecordSortDirectionEnum
}

input WorkStatusFindInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """News letter user for work status."""
  fr_nl_status: [NewsLetterUserFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_status: [NewsLetterScheduleFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_approval_status: [NewsLetterScheduleFindInputWhere!]
}

input WorkStatusFindOneByIdInput {
  """Please enter a numeric id as an input"""
  id: Int!

  """
  With deleted criteria for your operation. You can specify if you want to include soft deleted or removed records in result set or not. Retrive soft deleted or soft removed records..
  """
  withDeleted: Boolean = false
}

type WorkStatusFindOutput {
  """Total number of records found for the query"""
  total: Int!

  """Total number of remain records in paging"""
  remain: Int!

  """Total number of available pages for paging"""
  pages: Int!

  """Number of records limit for 1 page"""
  take: Int!

  """Pagination information"""
  pagination: FindOutputPagination!

  """
  List of records found for the find query. It is an array of objects with fields and values as per entity schema.
  """
  rows: [WorkStatusEntity!]!
}

input WorkStatusRecoverInput {
  """
  Where criteria for recover operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WorkStatusRecoverInputWhere!]
}

input WorkStatusRecoverInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """News letter user for work status."""
  fr_nl_status: [NewsLetterUserFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_status: [NewsLetterScheduleFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_approval_status: [NewsLetterScheduleFindInputWhere!]
}

type WorkStatusRecoverOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WorkStatusEntity!]!
}

input WorkStatusRemoveInput {
  """
  Where criteria for remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WorkStatusRemoveInputWhere!]
}

input WorkStatusRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """News letter user for work status."""
  fr_nl_status: [NewsLetterUserFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_status: [NewsLetterScheduleFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_approval_status: [NewsLetterScheduleFindInputWhere!]
}

type WorkStatusRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WorkStatusEntity!]!
}

input WorkStatusRestoreInput {
  """
  Where criteria for restore operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WorkStatusRestoreInputWhere!]
}

input WorkStatusRestoreInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """News letter user for work status."""
  fr_nl_status: [NewsLetterUserFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_status: [NewsLetterScheduleFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_approval_status: [NewsLetterScheduleFindInputWhere!]
}

type WorkStatusRestoreOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input WorkStatusSoftDeleteInput {
  """
  Where criteria for soft delete operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WorkStatusSoftDeleteInputWhere!]
}

input WorkStatusSoftDeleteInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """News letter user for work status."""
  fr_nl_status: [NewsLetterUserFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_status: [NewsLetterScheduleFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_approval_status: [NewsLetterScheduleFindInputWhere!]
}

type WorkStatusSoftDeleteOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
}

input WorkStatusSoftRemoveInput {
  """
  Where criteria for soft remove operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WorkStatusSoftRemoveInputWhere!]
}

input WorkStatusSoftRemoveInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """News letter user for work status."""
  fr_nl_status: [NewsLetterUserFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_status: [NewsLetterScheduleFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_approval_status: [NewsLetterScheduleFindInputWhere!]
}

type WorkStatusSoftRemoveOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!
  affectedRows: [WorkStatusEntity!]!
}

input WorkStatusUpdateInput {
  """
  Where criteria for update operation. You can only use and condition. You can also use multiple where criteria at once.
  """
  where: [WorkStatusUpdateInputWhere!]!

  """
  Sets criteria for update operation. Update set which needs to be updated in database. You can also use multiple sets criteria at once.
  """
  sets: WorkStatusUpdateInputSets!
}

input WorkStatusUpdateInputSets {
  """Title of the email template."""
  title: String
}

input WorkStatusUpdateInputWhere {
  """Unique ID of the email template, auto generated."""
  id: FindOperatorDto

  """Title of the email template."""
  title: FindOperatorDto

  """When record is created, date-time will be saved."""
  created: FindOperatorDto

  """When record is updated, date-time will be saved."""
  updated: FindOperatorDto

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: FindOperatorDto

  """News letter user for work status."""
  fr_nl_status: [NewsLetterUserFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_status: [NewsLetterScheduleFindInputWhere!]

  """News letter user for work status."""
  fr_nl_schedule_approval_status: [NewsLetterScheduleFindInputWhere!]
}

type WorkStatusUpdateOutput {
  """Important snapshots of technical process."""
  snapshot: SnapshotListDto

  """Number of affected records during process."""
  affected: Int!

  """
  List of records updated for the update query. It is an array of objects with fields and values as per entity schema.
  """
  affectedRows: [WorkStatusEntity!]!
}

input WorkStatusUpsertInput {
  """Title of the email template."""
  title: String!

  """Unique ID of the email template, auto generated. undefined"""
  id: Int
}

type WorkStatusUpsertOutput {
  """Unique ID of the email template, auto generated."""
  id: Int

  """Title of the email template."""
  title: String

  """When record is created, date-time will be saved."""
  created: DateTime

  """When record is updated, date-time will be saved."""
  updated: DateTime

  """
  When record is soft deleted or soft removed, date-time will be saved otherwise null to indicate record is not deleted.
  """
  deleted: DateTime

  """News letter user for work status."""
  fr_nl_status: [NewsLetterUserEntity!]

  """News letter user for work status."""
  fr_nl_schedule_status: [NewsLetterScheduleEntity!]

  """News letter user for work status."""
  fr_nl_schedule_approval_status: [NewsLetterScheduleEntity!]

  """
  Action type performed during upsert process, because upsert can create or update.
  """
  upsert_process: UpsertStatusEnum
}

"""Used at various place for Yes | No value."""
enum YesNoEnum {
  """True type value."""
  YES

  """False type value."""
  NO
}
